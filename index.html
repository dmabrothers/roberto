<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Роберту Иерузалимски" />
  <meta name="dcterms.date" content="2015-08-07" />
  <title>Программирование на языке Lua</title>
  <LINK REL="stylesheet" TYPE="text/css" HREF="css/lua-dark.css">
   <LINK REL="stylesheet" TYPE="text/css" HREF="css/manual.css">
<link rel="stylesheet" href="styles/tomorrow-night.css">
<script src="highlight.pack.js"></script>
            <script>
            hljs.configure({
              languages: ['lua']
            });
            hljs.initHighlightingOnLoad();
</script>

<link type="text/css" rel="stylesheet" href="just_term/just_term.css"/>
<script src="just_term/jquery.min.js" type="text/javascript"></script>
<script src="just_term/jquery.terminal-0.4.7.js" type="text/javascript" charset="utf-8"></script>
<link type="text/css" rel="stylesheet" href="just_term/jquery.terminal.css"/>
<script type="text/javascript" src="just_term/console_min.js"></script>


</head>
<body>

		<div id="console" class="prefix1">		
			<div id="interpreter"></div>
		</div>
<script src="just_term/lua.js" type="text/javascript"></script>

<p><span id="Title.xhtml"></span></p>
<p><strong>Программирование на языке Lua</strong></p>
<p><em>Третье издание</em></p>
<p><strong>Роберту Иерузалимски</strong></p>
<p><strong>Programming in Lua</strong></p>
<p><em>Third Edition</em></p>
<p><strong>Roberto Ierusalimschy</strong></p>
<p><em><strong>Посвящается Иде, Ноэми и Анне Лучии.</strong></em></p>
<p><font face="Liberation Mono"><strong>перевод и оформление: N1cke</strong></font></p>
<p><span id="TOC.xhtml"></span></p>
<div class="sgc-toc-title">
Оглавление
</div>
<div class="sgc-toc-level-1">
<a href="../Text/Preface.xhtml">Введение</a>
<div class="sgc-toc-level-2">
<a href="../Text/Preface.xhtml#sigil_toc_id_1">Аудитория</a>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Preface.xhtml#sigil_toc_id_2">О третьем издании</a>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Preface.xhtml#sigil_toc_id_3">Другие ресурсы</a>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Preface.xhtml#sigil_toc_id_4">Некоторые типографские соглашения</a>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Preface.xhtml#sigil_toc_id_5">Запуск примеров</a>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Preface.xhtml#sigil_toc_id_6">Благодарности</a>
</div>
</div>
<div class="sgc-toc-level-1">
<a href="../Text/Part1.xhtml">I. Язык</a>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter01.xhtml">1. Начало работы</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter01.xhtml#sigil_toc_id_9">1.1. Куски</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter01.xhtml#sigil_toc_id_10">1.2. Некоторые лексические соглашения</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter01.xhtml#sigil_toc_id_11">1.3. Глобальные переменные</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter01.xhtml#sigil_toc_id_12">1.4. Автономный интерпретатор</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter01.xhtml#sigil_toc_id_13">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter02.xhtml">2. Типы и значения</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_15">2.1. Отсутствие значения (nil)</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_16">2.2. Логические значения (boolean)</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_17">2.3. Числа (number)</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_18">2.4. Строки (string)</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_19">Cтроковые литералы</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_20">Дпинные строки</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_21">Приведения типов</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_22">2.5. Таблицы (table)</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_23">2.6. Функции (function)</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_24">2.7. Пользовательские данные (userdata)</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_25">2.8. Нити (thread)</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter02.xhtml#sigil_toc_id_26">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter03.xhtml">3. Выражения</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter03.xhtml#sigil_toc_id_28">3.1. Арифметические операции</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter03.xhtml#sigil_toc_id_29">3.2. Операции сравнения</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter03.xhtml#sigil_toc_id_30">3.3. Логические операции</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter03.xhtml#sigil_toc_id_31">3.4. Конкатенация</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter03.xhtml#sigil_toc_id_32">3.5. Операция длины</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter03.xhtml#sigil_toc_id_33">3.6. Приоритеты операций</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter03.xhtml#sigil_toc_id_34">Конструкторы таблиц</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter03.xhtml#sigil_toc_id_35">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter04.xhtml">4. Операторы</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter04.xhtml#sigil_toc_id_37">4.1. Операторы присваивания</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter04.xhtml#sigil_toc_id_38">4.2. Локальные переменные и блоки</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter04.xhtml#sigil_toc_id_39">4.3. Управляющие конструкции</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter04.xhtml#sigil_toc_id_40">if then else</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter04.xhtml#sigil_toc_id_41">while</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter04.xhtml#sigil_toc_id_42">repeat</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter04.xhtml#sigil_toc_id_43">Числовой for</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter04.xhtml#sigil_toc_id_44">Общий for</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter04.xhtml#sigil_toc_id_45">4.4. break, return и goto</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter04.xhtml#sigil_toc_id_46">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter05.xhtml">5. Функции</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter05.xhtml#sigil_toc_id_48">5.1. Множественные результаты</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter05.xhtml#sigil_toc_id_49">5.2. Вариадические функции</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter05.xhtml#sigil_toc_id_50">5.3. Именованные аргументы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter05.xhtml#sigil_toc_id_51">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter06.xhtml">6. Еще раз о функциях</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter06.xhtml#sigil_toc_id_53">6.1. Замыкания</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter06.xhtml#sigil_toc_id_54">6.2. Неглобальные функции</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter06.xhtml#sigil_toc_id_55">6.3. Корректные хвостовые вызовы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter06.xhtml#sigil_toc_id_56">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter07.xhtml">7. Итераторы и общий for</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter07.xhtml#sigil_toc_id_58">7.1. Итераторы и замыкания</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter07.xhtml#sigil_toc_id_59">7.2. Семантика общего for</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter07.xhtml#sigil_toc_id_60">7.3. Итераторы без состояния</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter07.xhtml#sigil_toc_id_61">7.4. Итераторы со сложным состоянием</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter07.xhtml#sigil_toc_id_62">7.5. Подлинные итераторы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter07.xhtml#sigil_toc_id_63">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter08.xhtml">8. Компиляция, выполнение и ошибки</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter08.xhtml#sigil_toc_id_65">8.1. Компиляция</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter08.xhtml#sigil_toc_id_66">8.2. Предкомпилированный код</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter08.xhtml#sigil_toc_id_67">8.3. Код С</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter08.xhtml#sigil_toc_id_68">8.4. Ошибки</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter08.xhtml#sigil_toc_id_69">8.5. Обработка ошибок и исключений</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter08.xhtml#sigil_toc_id_70">8.6. Сообщения об ошибках и обратные трассировки</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter08.xhtml#sigil_toc_id_71">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter09.xhtml">9. Сопрограммы</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter09.xhtml#sigil_toc_id_73">9.1. Основы сопрограмм</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter09.xhtml#sigil_toc_id_74">9.2. Каналы и фильтры</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter09.xhtml#sigil_toc_id_75">9.3. Сопрограммы как итераторы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter09.xhtml#sigil_toc_id_76">9.4. Невытесняющая многонитевость</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter09.xhtml#sigil_toc_id_77">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter10.xhtml">10. Законченные примеры</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter10.xhtml#sigil_toc_id_79">10.1. Задача о восьми королевах</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter10.xhtml#sigil_toc_id_80">10.2. Самые часто встречающиеся слова</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter10.xhtml#sigil_toc_id_81">10.3. Алгоритм цепи Маркова</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter10.xhtml#sigil_toc_id_82">Упражнения</a>
</div>
</div>
</div>
<div class="sgc-toc-level-1">
<a href="../Text/Part2.xhtml">II. Таблицы и объекты</a>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter11.xhtml">11. Структуры данных</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter11.xhtml#sigil_toc_id_85">11.1. Массивы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter11.xhtml#sigil_toc_id_86">11.2. Матрицы и многомерные массивы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter11.xhtml#sigil_toc_id_87">11.3. Связанные списки</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter11.xhtml#sigil_toc_id_88">11.4. Очереди и двойные очереди</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter11.xhtml#sigil_toc_id_89">11.5. Множества и мультимножества</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter11.xhtml#sigil_toc_id_90">11.6. Строковые буферы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter11.xhtml#sigil_toc_id_91">11.7. Графы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter11.xhtml#sigil_toc_id_92">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter12.xhtml">12. Файлы с данными и сохраняемость</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter12.xhtml#sigil_toc_id_94">12.1. Файлы с данными</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter12.xhtml#sigil_toc_id_95">12.2. Сериализация</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter12.xhtml#sigil_toc_id_96">Сохранение таблиц без циклов</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter12.xhtml#sigil_toc_id_97">Сохранение таблиц с циклами</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter12.xhtml#sigil_toc_id_98">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter13.xhtml">13. Метатаблицы и метаметоды</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter13.xhtml#sigil_toc_id_100">13.1. Арифметические метаметоды</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter13.xhtml#sigil_toc_id_101">13.2. Метаметоды сравнения</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter13.xhtml#sigil_toc_id_102">13.3. Библиотечные метаметоды</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter13.xhtml#sigil_toc_id_103">13.4. Метаметоды доступа к таблице</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter13.xhtml#sigil_toc_id_104">Метаметод __index</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter13.xhtml#sigil_toc_id_105">Метаметод __newindex</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter13.xhtml#sigil_toc_id_106">Таблицы со значениями по умолчанию</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter13.xhtml#sigil_toc_id_107">Отслеживание доступа к таблице</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter13.xhtml#sigil_toc_id_108">Таблицы, доступные только для чтения</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter13.xhtml#sigil_toc_id_109">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter14.xhtml">14. Окружение</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter14.xhtml#sigil_toc_id_111">14.1. Глобальные переменные с динамическими именами</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter14.xhtml#sigil_toc_id_112">14.2. Объявления глобальных переменных</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter14.xhtml#sigil_toc_id_113">14.3. Неглобальные окружения</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter14.xhtml#sigil_toc_id_114">14.4. Использование _ENV</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter14.xhtml#sigil_toc_id_115">14.5. _ENV и load</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter14.xhtml#sigil_toc_id_116">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter15.xhtml">15. Модули и пакеты</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter15.xhtml#sigil_toc_id_118">15.1. Функция require</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter15.xhtml#sigil_toc_id_119">Переименование модуля</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter15.xhtml#sigil_toc_id_120">Поиск пути</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter15.xhtml#sigil_toc_id_121">Искатели</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter15.xhtml#sigil_toc_id_122">15.2. Основной подход к написанию модулей на Lua</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter15.xhtml#sigil_toc_id_123">15.3. Использование окружений</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter15.xhtml#sigil_toc_id_124">15.4. Подмодули и пакеты</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter15.xhtml#sigil_toc_id_125">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter16.xhtml">16. Объектно-ориентированное программирование</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter16.xhtml#sigil_toc_id_127">16.1. Классы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter16.xhtml#sigil_toc_id_128">16.2. Наследование</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter16.xhtml#sigil_toc_id_129">16.3. Множественное наследование</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter16.xhtml#sigil_toc_id_130">16.4. Конфиденциальность</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter16.xhtml#sigil_toc_id_131">16.5. Подход с единственным методом</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter16.xhtml#sigil_toc_id_132">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter17.xhtml">17. Слабые таблицы и финализаторы</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter17.xhtml#sigil_toc_id_134">17.1. Слабые таблицы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter17.xhtml#sigil_toc_id_135">17.2. Функции с запоминанием</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter17.xhtml#sigil_toc_id_136">17.3. Атрибуты объекта</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter17.xhtml#sigil_toc_id_137">17.4. Вновь таблицы со значениями по умолчанию</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter17.xhtml#sigil_toc_id_138">17.5. Эфемерные таблицы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter17.xhtml#sigil_toc_id_139">17.6. Финализаторы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter17.xhtml#sigil_toc_id_140">Упражнения</a>
</div>
</div>
</div>
<div class="sgc-toc-level-1">
<a href="../Text/Part3.xhtml">III. Стандартные библиотеки</a>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter18.xhtml">18. Математическая библиотека</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter18.xhtml#sigil_toc_id_143">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter19.xhtml">19. Побитовая библиотека</a>
</div>
<div class="sgc-toc-level-2">
<div class="sgc-toc-level-3">
<a href="../Text/Chapter19.xhtml#sigil_toc_id_145">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter20.xhtml">20. Табличная библиотека</a>
</div>
<div class="sgc-toc-level-2">
<div class="sgc-toc-level-3">
<a href="../Text/Chapter20.xhtml#sigil_toc_id_147">20.1. Функции insert и remove</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter20.xhtml#sigil_toc_id_148">20.2. Сортировка</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter20.xhtml#sigil_toc_id_149">20.3. Конкатенация</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter20.xhtml#sigil_toc_id_150">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter21.xhtml">21. Строковая библиотека</a>
</div>
<div class="sgc-toc-level-2">
<div class="sgc-toc-level-3">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_152">21.1. Основные строковые функции</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_153">21.2. Функции сопоставления с образцом</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_154">Функция string.find</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_155">Функция string.match</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_156">Функция string.gsub</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_157">Функция string.gmatch</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_158">21.3. Образцы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_159">21.4. Захваты</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_160">21.5. Замены</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_161">Кодировка URL</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_162">Разложение символов табуляции на пробелы</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_163">21.6. Специфические приемы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_164">21.7. Юникод</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter21.xhtml#sigil_toc_id_165">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter22.xhtml">22. Библиотека ввода-вывода</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter22.xhtml#sigil_toc_id_167">22.1. Простая модель ввода-вывода</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter22.xhtml#sigil_toc_id_168">22.2. Полная модель ввода-вывода</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter22.xhtml#sigil_toc_id_169">Небольшой прием для увеличения быстродействия</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter22.xhtml#sigil_toc_id_170">Бинарные файлы</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter22.xhtml#sigil_toc_id_171">22.3. Прочие операции над файлами</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter22.xhtml#sigil_toc_id_172">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter23.xhtml">23. Библиотека операционной системы</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter23.xhtml#sigil_toc_id_174">23.1. Дата и время</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter23.xhtml#sigil_toc_id_175">23.2. Прочие системные вызовы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter23.xhtml#sigil_toc_id_176">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter24.xhtml">24. Отладочная библиотека</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter24.xhtml#sigil_toc_id_178">24.1. Интроспективные средства</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter24.xhtml#sigil_toc_id_179">Доступ к локальным переменным</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter24.xhtml#sigil_toc_id_180">Доступ к нелокальным переменным</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter24.xhtml#sigil_toc_id_181">Доступ к другим сопрограммам</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter24.xhtml#sigil_toc_id_182">24.2. Ловушки</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter24.xhtml#sigil_toc_id_183">24.3. Профилирование</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter24.xhtml#sigil_toc_id_184">Упражнения</a>
</div>
</div>
</div>
<div class="sgc-toc-level-1">
<a href="../Text/Part4.xhtml">IV. C API</a>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter25.xhtml">25. Обзор С API</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter25.xhtml#sigil_toc_id_187">25.1. Первый пример</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter25.xhtml#sigil_toc_id_188">25.2. Стек</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter25.xhtml#sigil_toc_id_189">Заталкивание элементов</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter25.xhtml#sigil_toc_id_190">Обращение к элементам</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter25.xhtml#sigil_toc_id_191">Другие стековые операции</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter25.xhtml#sigil_toc_id_192">25.3. Обработка ошибок в C API</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter25.xhtml#sigil_toc_id_193">Обработка ошибок в прикладном коде</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter25.xhtml#sigil_toc_id_194">Обработка ошибок в библиотечном коде</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter25.xhtml#sigil_toc_id_195">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter26.xhtml">26. Расширение вашего приложения</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter26.xhtml#sigil_toc_id_197">26.1. Основы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter26.xhtml#sigil_toc_id_198">26.2. Работа с таблицами</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter26.xhtml#sigil_toc_id_199">26.3. Вызовы функций Lua</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter26.xhtml#sigil_toc_id_200">26.4. Обобщенный вызов функции</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter26.xhtml#sigil_toc_id_201">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter27.xhtml">27. Вызываем С из Lua</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter27.xhtml#sigil_toc_id_203">27.1. Функции С</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter27.xhtml#sigil_toc_id_204">27.2. Продолжения</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter27.xhtml#sigil_toc_id_205">27.3. Модули С</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter27.xhtml#sigil_toc_id_206">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter28.xhtml">28. Приемы написания функций С</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter28.xhtml#sigil_toc_id_208">28.1. Обработка массивов</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter28.xhtml#sigil_toc_id_209">28.2. Обработка строк</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter28.xhtml#sigil_toc_id_210">28.3. Хранение состояния в функциях С</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter28.xhtml#sigil_toc_id_211">Реестр</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter28.xhtml#sigil_toc_id_212">Верхние значения</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter28.xhtml#sigil_toc_id_213">Общие верхние значения</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter28.xhtml#sigil_toc_id_214">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter29.xhtml">29. Задаваемые пользователем типы в С</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter29.xhtml#sigil_toc_id_216">29.1. Пользовательские данные (userdata)</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter29.xhtml#sigil_toc_id_217">29.2. Метатаблицы</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter29.xhtml#sigil_toc_id_218">29.3. Объектно-ориентированный доступ</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter29.xhtml#sigil_toc_id_219">29.4. Доступ как к массиву</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter29.xhtml#sigil_toc_id_220">29.5. Облегченные пользовательские данные</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter29.xhtml#sigil_toc_id_221">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter30.xhtml">30. Управление ресурсами</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter30.xhtml#sigil_toc_id_223">30.1. Итератор по директории</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter30.xhtml#sigil_toc_id_224">30.2. Парсер XML</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter30.xhtml#sigil_toc_id_225">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter31.xhtml">31. Нити и состояния</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter31.xhtml#sigil_toc_id_227">31.1. Многонитевость</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter31.xhtml#sigil_toc_id_228">31.2. Состояния Lua</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter31.xhtml#sigil_toc_id_229">Упражнения</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/Chapter32.xhtml">32. Управление памятью</a>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter32.xhtml#sigil_toc_id_231">32.1. Выделяющая функция</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter32.xhtml#sigil_toc_id_232">32.2. Сборщик мусора</a>
<div class="sgc-toc-level-4">
<a href="../Text/Chapter32.xhtml#sigil_toc_id_233">API сборщика мусора</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/Chapter32.xhtml#sigil_toc_id_234">Упражнения</a>
</div>
</div>
</div>
<div class="sgc-toc-level-1">
<a href="../Text/Appendix.xhtml">Приложения. Lua 5.3</a>
<div class="sgc-toc-level-2">
<a href="../Text/AppendixA.xhtml">А. Переход на Lua 5.3</a>
<div class="sgc-toc-level-3">
<a href="../Text/AppendixA.xhtml#sigil_toc_id_236">А.1. Изменения в языке</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/AppendixA.xhtml#sigil_toc_id_237">А.2. Изменения в библиотеках</a>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/AppendixA.xhtml#sigil_toc_id_238">А.3. Изменения в API</a>
</div>
</div>
<div class="sgc-toc-level-2">
<a href="../Text/AppendixB.xhtml">Б. Новое в Lua 5.3</a>
<div class="sgc-toc-level-3">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_239">Б.1. Язык</a>
<div class="sgc-toc-level-4">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_240">Целые числа</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_241">Официальная поддержка 32-битных чисел</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_242">Побитовые операции</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_243">Базовая поддержка UTF-8</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_244">Целочисленное деление</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_245">Б.2. Библиотеки</a>
<div class="sgc-toc-level-4">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_246">Опция strip в string.dump</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_247">Функция table.move</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_248">Функции string.pack, string.unpack, string.packsize</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_249">Б.3. C API</a>
<div class="sgc-toc-level-4">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_250">Опция strip в lua.dump</a>
</div>
<div class="sgc-toc-level-4">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_251">Функции</a>
</div>
</div>
<div class="sgc-toc-level-3">
<a href="../Text/AppendixB.xhtml#sigil_toc_id_252">Б.4. Автономный интерпретатор Lua</a>
</div>
</div>
</div>
<p><span id="Preface.xhtml"></span></p>
<h2>Введение</h2>
<p>Когда Вальдемар, Луис и я начали разработку Lua в 1993 году, мы с трудом могли себе представить, что Lua сможет так распространиться. Начавшись как домашний язык для двух специфичных проектов, сейчас Lua широко используется во всех областях, которые могут получить выигрыш от простого, расширяемого, переносимого и эффективного скриптового языка, таких как встроенные системы, мобильные устройства и, конечно, игры.</p>
<p>С самого начала мы разрабатывали Lua для интеграции с программным обеспечением, написанным на C/C++ и других общепринятых языках. Эта интеграция дает много преимуществ. Lua — это крошечный и простой язык, частично из-за того, что он не пытается превзойти С в том, в чем он уже хорош, например: высочайшее быстродействие, низкоуровневые операции и взаимодействие со сторонним программным обеспечением. Для этих задач Lua полагается на С. Lua предлагает как раз то, для чего С недостаточно хорош: высокая степень независимости от аппаратного обеспечения, динамические структуры, отсутствие избыточности и легкость тестирования и отладки. Для этих целей Lua располагает безопасным окружением, автоматическим управлением памятью и хорошими средствами для работы со строками и другими видами данных с динамически изменяемым размером.</p>
<p>Часть силы Lua идет от его библиотек, и это не случайно. В конце концов, одной из самых сильных сторон Lua является его расширяемость. Многие качества языка вносят в это свой вклад. Динамическая типизация обеспечивает высокую степень полиморфизма. Автоматическое управление памятью упрощает создание интерфейсов, поскольку нет необходимости решать, кто отвечает за выделение и освобождение памяти, или как обрабатывать ее переполнение. Функции высшего порядка и анонимные функции обеспечивают высокую степень параметризации, делая функции более универсальными.</p>
<p>Lua является не только расширяемым, но и <em>связующим языком</em>. Lua поддерживает подход для разработки программного обеспечения на основе компонентов, когда мы создаем приложение, связывая вместе существующие высокоуровневые компоненты. Эти компоненты пишутся на компилируемом языке со статической типизацией, таком как C или C++; Lua является «клеем», который мы используем для компоновки и соединения этих компонентов. Обычно, компоненты (или объекты) представляют более конкретные низкоуровневые сущности (такие как виджеты и структуры данных), которые почти не меняются во время разработки программы, и которые расходуют большую часть процессорного времени итоговой программы. Lua придает окончательную форму приложению, которая, вероятно, будет неоднократно изменяться во время жизненного цикла данной программы. Однако, в отличие от других связующих технологий, Lua при этом является полноценным языком программирования. Поэтому мы можем использовать Lua не только для связывания компонентов, но и для их адаптации и настройки, а также для создания полностью новых компонентов.</p>
<p>Разумеется, Lua — не единственный скриптовый язык. Существуют другие языки, которые вы можете использовать примерно для тех же целей. Тем не менее, Lua предоставляет набор возможностей, которые делают его лучшим выбором для многих ваших задач, и которые придают ему свой уникальный профиль:</p>
<ul>
<li><em>Расширяемость</em>. Расширяемость Lua настолько значительна, что многие рассматривают Lua не как язык, а как набор для построения предметно-ориентированных языков <strong>(domain-specific language — DSL)</strong>. Мы с самого начала разрабатывали Lua так, чтобы он был расширяемым как через код Lua, так и через код С. В качестве доказательства этой концепции Lua реализует большую часть своей базовой функциональности через внешние библиотеки. Обеспечить взаимодействие Lua с C/C++ действительно просто, и Lua был успешно интегрирован со многими другими языками, такими как Fortran, Java, Smalltalk, Ada, С#, и даже со скриптовыми языками, такими как Perl и Python.</li>
<li><em>Простота</em>. Lua — это простой и маленький язык. У него мало концепций (зато они эффективные). Эта простота облегчает изучение Lua и помогает сохранять его размер небольшим. Полный дистрибутив (исходный код, руководство, бинарные файлы для некоторых платформ) спокойно размещается на одном флоппи-диске.</li>
<li><em>Эффективность</em>. Lua обладает весьма эффективной реализацией. Независимые тесты показывают, что Lua является одним из самых быстрых среди скриптовых языков.</li>
<li><em>Переносимость</em>. Когда мы говорим о переносимости, то имеем в виду запуск Lua на всех платформах, о которых вы только слышали: все версии Unix и Windows, PlayStation, Xbox, Mac OS X и iOS, Android, Kindle Fire, NOOK, Haiku, QUALCOMM Brew, мейнфреймы IBM, RISC OS, Symbian OS, процессоры Rabbit, Raspberry Pi, Arduino и многие другие. Исходный код для каждой из этих платформ практически одинаков. Lua не использует условную компиляцию для адаптации своего кода под различные машины; вместо этого он придерживается стандартного ANSI (ISO) С. Таким образом, вам обычно не нужно адаптировать его под новую среду: если у вас есть компилятор ANSI С, то вам всего лишь нужно скомпилировать Lua без каких-либо предварительных настроек.</li>
</ul>
<h3 id="Preface.xhtml#sigil_toc_id_1">Аудитория</h3>
<p>Пользователи Lua обычно относятся к одной из трех широких групп: те, кто используют Lua, уже встроенный в приложение, те, кто используют Lua автономно, и те, кто используют Lua и С вместе.</p>
<p>Многие используют Lua, встроенный в какую-либо прикладную программу, например, Adobe Lightroom, Nmap или World of Warcraft. Эти приложения используют Lua-C API для регистрации новых функций, создания новых типов и изменения поведения некоторых операций языка, конфигурируя Lua под свою специфическую область. Часто пользователи таких приложений даже не знают, что Lua является независимым языком, адаптированным под данную область. Например, многие разработчики плагинов для Lightroom не знают о других способах использования этого языка; пользователи Nmap, как правило, рассматривают Lua как язык Nmap Scripting Engine; игроки в World of Warcraft могут считать Lua языком исключительно для данной игры.</p>
<p>Lua также полезен как самостоятельный язык, не только для обработки текста и одноразовых маленьких программ, но также и для различных проектов от среднего до большого размера. При данном применении основную функциональность Lua дают его библиотеки. Стандартные библиотеки, например, предлагают базовое сопоставление с образцом и другие функции для работы со строками. Улучшение поддержки своих библиотек у Lua привело к быстрому увеличению количества внешних пакетов. Lua Rocks, система внедрения и управления модулями для Lua, на данный момент насчитывает более 150 пакетов.</p>
<p>Наконец, есть программисты, которые работают на другой стороне скамьи, и которые пишут приложения, использующие Lua как библиотеку С. Такие люди больше пишут на С, чем на Lua, хотя им требуется хорошее понимание Lua для создания интерфейсов, которые будут простыми, легкими в использовании и хорошо интегрированными с языком.</p>
<p>Данной книге есть что предложить всем этим людям. Первая часть охватывает сам язык, показывая, как мы можем раскрыть весь его потенциал. Мы фокусируемся на различных конструкциях языка и используем многочисленные примеры и упражнения, чтобы показать, как их использовать для практических задач. Некоторые главы этой части охватывают базовые понятия, такие как управляющие структуры, в то время как остальные главы охватывают более продвинутые темы, такие как итераторы и сопрограммы.</p>
<p>Вторая часть полностью посвящена таблицам, единственной структуре данных в Lua. Главы этой части обсуждают структуры данных, их сохраняемость, пакеты и объектно-ориентированное программирование. Именно там мы раскроем настоящую мощь языка.</p>
<p>Третья часть представляет стандартные библиотеки. Эта часть особенно полезна для тех, кто использует Lua как самостоятельный язык, хотя многие другие приложения также частично или полностью включают в себя стандартные библиотеки. Данная часть отводит по одной главе для каждой стандартной библиотеки: математическая библиотека, побитовая библиотека, табличная библиотека, строковая библиотека, библиотека ввода-вывода, библиотека операционной системы и отладочная библиотека.</p>
<p>Наконец, последняя часть книги охватывает API между Lua и С для тех, кто использует C, чтобы овладеть полной мощью Lua. Подача материала данной части в силу необходимости весьма отличается от всей остальной книги. Здесь мы будем программировать на С, а не на Lua, так что нам придется сменить амплуа. Для некоторых читателей обсуждение C API может представлять незначительный интерес; для других эта часть может оказаться самой важной.</p>
<h3 id="Preface.xhtml#sigil_toc_id_2">О третьем издании</h3>
<p>Эта книга является обновленной и расширенной версией второго издания книги <em>«Programming in Lua»</em> (также известной как <em>PiL 2</em>). Хотя структура книги практически та же самая, это издание включает в себя изрядное количество нового материала.</p>
<p>Во-первых, я обновил всю книгу до Lua 5.2. Особую значимость представляет глава об окружениях, которая была практически полностью переписана. Я также переписал несколько примеров, чтобы показать преимущества от использования новых возможностей, предоставляемых Lua 5.2. Тем не менее, я четко обозначил отличия от Lua 5.1, поэтому вы можете использовать книгу и для этой версии языка.</p>
<p>Во-вторых, что более важно, я добавил упражнения во все главы книги. Эти упражнения варьируются от простых вопросов о языке до небольших полноценных проектов. Некоторые примеры иллюстрируют важные аспекты программирования на Lua и так же важны, как примеры, которые расширяют ваш набор полезных приемов.</p>
<p>Как и в случае с первым и вторым изданиями «Programming in Lua», мы опубликовали это третье издание самостоятельно. Несмотря на ограниченные возможности распространения, этот подход обладает рядом преимуществ: мы сохраняем полный контроль над содержимым книги; мы сохраняем все права на предложение книги в других формах; мы свободны выбирать, когда выпустить следующее издание; мы можем быть уверены, что выпуск данной книги не будет прекращен.</p>
<h3 id="Preface.xhtml#sigil_toc_id_3">Другие ресурсы</h3>
<p>Справочник <strong>(reference manual)</strong> по языку необходим всем, кто действительно хочет его освоить. Эта книга не заменяет справочник Lua. Напротив, они дополняют друг друга. Справочник лишь описывает Lua. Он не показывает ни примеров, ни объяснений для конструкций языка. С другой стороны, он полностью описывает язык: эта книга опускает некоторые редко используемые «темные углы» Lua. Более того, справочник является официальным документом о Lua. Там, где эта книга расходится со справочником, доверяйте справочнику. Чтобы получить справочник и дополнительную информацию о Lua, посетите веб-сайт <a href="http://www.lua.org" class="uri">http://www.lua.org</a>.</p>
<p>Вы также можете найти полезную информацию на сайте пользователей Lua, поддерживаемом их сообществом: <a href="http://lua-users.org" class="uri">http://lua-users.org</a>. Среди прочих ресурсов он предлагает учебное пособие <strong>(tutorial)</strong>, список сторонних пакетов и документации, и архив официальной рассылки по Lua.</p>
<p>Эта книга описывает Lua 5.2, хотя большая часть ее содержимого также применима к Lua 5.1 и Lua 5.0. Некоторые отличия Lua 5.2 от предыдущих версий Lua 5 четко обозначены в тексте книги. Если вы используете более новую версию (выпущенную после этой книги), обратитесь к соответственному руководству по поводу отличий между версиями. Если вы используете версию старше 5.2, то пришла пора подумать об обновлении.</p>
<h3 id="Preface.xhtml#sigil_toc_id_4">Некоторые типографские соглашения</h3>
<p>В данной книге &quot;<code>строковые литералы</code>&quot; заключены в двойные кавычки, а одиночные символы, например '<code>а</code>', заключены в одинарные кавычки. Строки, которые применяются как образцы, также заключены в одинарные кавычки, например '<code>[%w_]*</code>'. Книга использует моноширинный шрифт как для <code>кусков кода</code>, так и для <code>идентификаторов</code>. Для <strong>зарезервированных слов</strong> используется полужирный шрифт. Крупные куски кода показаны с применением следующего стиля:</p>
<pre><code>-- программа &quot;Hello World&quot;
print (&quot;Hello World&quot;)    --&gt; Hello World</code></pre>
<p>Обозначение <code>--&gt;</code> показывает результат выполнения оператора или, изредка, результат выражения:</p>
<pre><code>print(10)    --&gt; 10
13+3         --&gt; 16</code></pre>
<p>Поскольку двойной дефис (<code>--</code>) начинает комментарий в Lua, вы можете без проблем применять данные обозначения в ваших программах. Наконец, в книге используется обозначение <code>&lt;--&gt;</code> для указания на то, что что-то эквивалентно чему-то другому:</p>
<pre><code>this    &lt;--&gt;    that</code></pre>
<p>(<span class="underline">Примечание</span>: так выглядят примечания от автора книги.) <strong>(А так выглядят примечания от переводчика.)</strong></p>
<h3 id="Preface.xhtml#sigil_toc_id_5">Запуск примеров</h3>
<p>Вам понадобится интерпретатор Lua для запуска примеров из этой книги. В идеале вам следует использовать Lua 5.2, но большинство примеров без каких-либо изменений будет работать и на Lua 5.1.</p>
<p>Сайт Lua (<a href="http://www.lua.org" class="uri">http://www.lua.org</a>) хранит исходный код этого интерпретатора. Если у вас есть компилятор С и знание того, как скомпилировать код С на вашем компьютере, то вам стоит попробовать установить Lua из его исходного кода; это действительно легко. Сайт <em>Lua Binaries</em> (поищите <code>luabinaries</code>) предлагает заранее скомпилированные интерпретаторы для большинства основных платформ. Если вы используете Linux или другую UNIX-подобную систему, вы можете проверить репозиторий вашего дистрибутива; некоторые дистрибутивы уже предлагают готовые пакеты с Lua. Для Windows хорошим выбором является <em>Lua for Windows</em> (поищите <code>luaforwindows</code>), являющийся «заряженной средой» для Lua. Он включает в себя интерпретатор, интегрированный текстовый редактор и множество библиотек.</p>
<p>Если вы используете Lua, встроенный в приложение, такое как WoW или Nmap, то вам может понадобиться руководство по данному приложению (или помощь «местного гуру»), чтобы разобраться, как запускать ваши программы. Тем не менее, Lua остается все тем же языком; большинство вещей, которое мы увидим в этой книге, применимо независимо то того, как вы используете Lua. Однако, я рекомендую начать изучение Lua с автономного интерпретатора для запуска ваших первых примеров и экспериментов.</p>
<h3 id="Preface.xhtml#sigil_toc_id_6">Благодарности</h3>
<p>Прошло уже почти десять лет с тех пор, как я опубликовал первое издание этой книги. Ряд друзей и организаций помогал мне на этом пути.</p>
<p>Как всегда, Луиг Хенрик де Фигуредо и Вальдемар Селес, соавторы Lua, предложили все виды помощи. Андре Карригал, Аско Кауппи, Бретт Капилик, Диего Мехаб, Эдвин Морагас, Фернандо Джефферсон, Гэвин Врес, Джон Д. Рамсделл и Норман Ремси предоставили неоценимые замечания и полезную аналитическую информацию для различных изданий этой книги.</p>
<p>Луиза Новаэс, глава отдела искусства и дизайна в PUC-Rio, смогла найти время в своем занятом графике, чтобы создать идеальную обложку для данного издания.</p>
<p>Lightning Source, Inc. предложило надежный и эффективный вариант для печати и распространения данной книги. Без них о самостоятельной публикации этой книги не могло бы быть и речи.</p>
<p>Центр латиноамериканских исследований в Стендфордском университете предоставил мне крайне необходимый перерыв от регулярной работы в очень стимулирующем окружении, во время которого я и сделал большую часть работы над третьим изданием.</p>
<p>Я также хотел бы поблагодарить Папский католический университет Рио де Жанейро (PUC-Rio) и Бразильский национальный исследовательский совет (CNPq) за их постоянную поддержку моей работы.</p>
<p>Наконец, я должен выразить мою глубокую благодарность Ноэми Родригес за все виды помощи (в том числе и технической) и скрашивание моей жизни.</p>
<p><span id="Part1.xhtml"></span></p>
<div style="text-align: center; padding: 0pt; margin: 0pt;">
<h1>Часть I</h1>
<h1 id="Part1.xhtml#sigil_toc_id_7" class="part">Язык</h1>
<svg xmlns="http://www.w3.org/2000/svg" height="75%" preserveaspectratio="xMidYMid meet" version="1.1" viewbox="0 0 1400 1300" width="100%" xlink="http://www.w3.org/1999/xlink">

</svg>
</div>
<p><span id="Chapter01.xhtml"></span></p>
<h2 id="Chapter01.xhtml#sigil_toc_id_8">ГЛАВА 1</h2>
<h2>Начало работы</h2>
<p>Продолжая сложившуюся традицию, наша первая программа на Lua всего лишь печатает &quot;<code>Hello World</code>&quot;:</p>
<pre><code>print(&quot;Hello World&quot;)</code></pre>
<p>Если вы используете автономный интерпретатор Lua, то все, что вам требуется для запуска вашей первой программы — это вызвать интерпретатор (обычно он называется <code>lua</code> или <code>lua5.2</code>) с именем текстового файла, содержащего вашу программу. Если вы сохраните вышеприведенную программу в файл <code>hello.lua</code>, то следующая команда должна его запустить:</p>
<pre><code>% lua hello.lua</code></pre>
<p>В качестве более сложного примера следующая программа определяет функцию для вычисления факториала заданного числа, запрашивает у пользователя число и печатает его факториал:</p>
<pre><code>-- определяет функцию факториала
function fact (n)
  if n == 0 then
    return 1
  else
    return n * fact(n-1)
  end
end</code></pre>
<pre><code>print(&quot;enter a number:&quot;)
a = io.read(&quot;*n&quot;)        -- считывает число
print(fact(a))</code></pre>
<h3 id="Chapter01.xhtml#sigil_toc_id_9">1.1. Куски</h3>
<p>Каждый выполняемый Lua фрагмент кода, такой как файл или отдельная строка в интерактивном режиме, называется куском. <em>Кусок</em> <strong>(chunk)</strong> — это просто последовательность команд (или операторов).</p>
<p>Lua не нужен разделитель между идущими подряд операторами, но вы можете использовать точку с запятой, если хотите. Мое личное правило — использовать точки с запятой только для разделения двух или более операторов, записанных в одной строке. Переводы строк не играют никакой роли в синтаксисе Lua; например, следующие четыре куска допустимы и эквивалентны:</p>
<pre><code>a = 1
b = a*2

a = 1;
b = a*2;

a = 1; b = a*2

a = 1 b = a*2     -- уродливо, но допустимо</code></pre>
<p>Кусок может быть просто одиночным оператором, как в примере «Hello World», или состоять из набора операторов и определений функций (которые на самом деле являются присваиваниями, как мы увидим позже), как в примере с факториалом. Кусок может быть настолько большим, насколько вы захотите. Поскольку Lua также используется как язык для описания данных, куски в несколько мегабайт не являются редкостью. У интерпретатора Lua не возникает никаких проблем при работе с большими кусками.</p>
<p>Вместо записи вашей программы в файл вы можете запустить автономный интерпретатор в интерактивном режиме. Если вы запустите <code>lua</code> без аргументов, то увидите его приглашение ввода:</p>
<pre><code>% lua
Lua 5.2 Copyright (С) 1994-2012 Lua.org, PUC-Rio
&gt;</code></pre>
<p>С этого момента каждая команда, которую вы наберете (как, например, <code>print &quot;Hello World</code>&quot;), выполняется сразу после ее ввода. Для выхода из интерактивного режима и интерпретатора просто наберите управляющий символ конца файла (<code>ctrl-D</code> в UNIX, <code>ctrl-Z</code> в Windows) или вызовите функцию <code>exit</code> из библиотеки операционной системы — для этого нужно набрать <code>os.exit()</code>.</p>
<p>В интерактивном режиме Lua обычно интерпретирует каждую строку, которую вы набираете, как законченный кусок. Однако, если он обнаруживает, что строка не образует законченный кусок, то он ждет продолжения ввода до тех пор, пока этот кусок не будет закончен. Таким образом, вы можете вводить многострочные определения наподобие функции <code>factorial</code> прямо в интерактивном режиме. Тем не менее, обычно более удобно помещать подобные определения в файл и затем вызывать Lua для его выполнения.</p>
<p>Вы можете использовать опцию <code>-i</code>, чтобы дать указание Lua начать интерактивный сеанс после выполнения заданного куска:</p>
<pre><code>% lua -i prog</code></pre>
<p>Строка с командой вроде этой выполнит кусок в файле <code>prog</code> и затем выведет приглашение ввода интерактивного режима. Это особенно удобно для отладки и тестирования вручную. В конце данной главы мы рассмотрим другие опции автономного интерпретатора.</p>
<p>Другой способ выполнять куски состоит в применении функции <code>dofile</code>, которая немедленно выполняет файл. Например, допустим, у вас есть файл <code>lib1.lua</code> со следующим кодом:</p>
<pre><code>function norm (x, y)
  return (x^2 + y^2)^0.5
end

function twice (x)
  return 2*x
end</code></pre>
<p>Тогда в интерактивном режиме вы можете набрать</p>
<pre><code>&gt; dofile(&quot;lib1.lua&quot;)    -- загружает вашу библиотеку
&gt; n = norm(3.4, 1.0)
&gt; print(twice(n))       --&gt; 7.0880180586677</code></pre>
<p>Функция <code>dofile</code> также удобна, когда вы тестируете фрагмент кода. Вы можете работать с двумя окнами: одно будет текстовым редактором с вашей программой (скажем, в файле <code>prog.lua</code>), а другое консолью, выполняющей Lua в интерактивном режиме. После сохранения изменений в вашей программе, вы выполняете <code>dofile(&quot;prog.lua&quot;)</code> в консоли Lua для загрузки нового кода; затем вы проверяете этот новый код, вызывая его функции и печатая результаты.</p>
<h3 id="Chapter01.xhtml#sigil_toc_id_10">1.2. Некоторые лексические соглашения</h3>
<p>Идентификаторы (или имена) в Lua могут быть любой последовательностью из букв, цифр и символов подчеркивания, не начинающейся с цифры, например:</p>
<pre><code>i       j      i10      _ij
aSomewhatLongName    _INPUT</code></pre>
<p>Вы должны избегать идентификаторов, начинающихся с символа подчеркивания, за которым следует одна или несколько заглавных букв (как, например, <code>_VERSION</code>); они зарезервированы в Lua для особых целей. Обычно я использую идентификатор <code>_</code> (одиночный символ подчеркивания) для пустых переменных.</p>
<p>В старых версиях Lua понятие того, что является буквой, зависело от локали. Однако, подобные буквы делают вашу программу непригодной для выполнения на системах, которые не поддерживают данную локаль. Поэтому Lua 5.2 разрешает использовать в идентификаторах только буквы из диапазонов <code>A-Z</code> и <code>a-z</code>.</p>
<p>Следующие слова зарезервированы; мы не можем использовать их в качестве идентификаторов:</p>
<pre><code>and      break    do       else    elseif
end      false    goto     for     function
if       in       local    nil     not
or       repeat   return   then    true
until    while</code></pre>
<p>Lua учитывает регистр букв: <strong>and</strong> — это зарезервированное слово, но <code>And</code> и <code>AND</code> — это два отличных от него и друг от друга идентификатора.</p>
<p>Комментарий начинается в любом месте с двойного дефиса (<code>--</code>) и длится до конца строки кода. Lua также поддерживает блочный комментарий, который начинается с <code>-[[</code> и длится до ближайших <code>]]</code>. (<span class="underline">Примечание</span>: Блочные комментарии могут быть более сложными, как мы увидим в разделе 2.4). Распространенным приемом для закомментирования фрагмента кода является заключение этого кода между <code>--[[</code> и <code>--]]</code>, как показано ниже:</p>
<pre><code>--[[
  print(10)        -- ничего не происходит (закомментировано)
--]]</code></pre>
<p>Для восстановления работоспособности этого кода мы добавляем один дефис к первой строке:</p>
<pre><code>---[[
  print(10)        --&gt; 10
--]]</code></pre>
<p>В первом примере <code>--[[</code> в первой строке начинает блочный комментарий, а двойной дефис в последней строке по-прежнему находится внутри этого комментария. Во втором примере последовательность <code>---[[</code> начинает обычный однострочный комментарий, поэтому первая и последняя строки становятся независимыми комментариями. В этом случае <code>print</code> находится вне комментариев.</p>
<h3 id="Chapter01.xhtml#sigil_toc_id_11">1.3. Глобальные переменные</h3>
<p>Глобальным переменным не нужны объявления; вы их просто используете. Обратиться к неинициализированной переменной не является ошибкой; вы всего лишь получите значение nil в качестве результата:</p>
<pre><code>print(b)    --&gt; nil
b = 10
print(b)    --&gt; 10</code></pre>
<p>Если вы присвоите nil глобальной переменной, то Lua поведет себя так, как если бы эта переменная никогда не использовалась:</p>
<pre><code>b = nil
print(b)    --&gt; nil</code></pre>
<p>После данного присваивания Lua может со временем высвободить память, выделенную под эту переменную.</p>
<h3 id="Chapter01.xhtml#sigil_toc_id_12">1.4. Автономный интерпретатор</h3>
<p>Автономный интерпретатор (также называемый <code>lua.с</code> в связи с названием его исходного файла или просто <code>lua</code> из-за имени его выполнимого файла) — это небольшая программа, которая позволяет использовать Lua непосредственно. В данном разделе представлены ее основные опции.</p>
<p>Когда интерпретатор загружает файл, то он пропускает первую строку кода, если она начинается с октоторпа ('<code>#</code>'). Это свойство позволяет использовать Lua как скриптовый интерпретатор в UNIX-системах. Если вы начнете ваш скрипт с чего-нибудь вроде</p>
<pre><code>#!/usr/local/bin/lua</code></pre>
<p>(при условии, что автономный интерпретатор находится в <code>/usr/local/bin</code>) или</p>
<pre><code>#!/usr/bin/env lua</code></pre>
<p>то вы можете вызвать ваш скрипт напрямую, без явного вызова интерпретатора Lua.</p>
<p>Использование <code>lua</code> следующее:</p>
<pre><code>lua [options] [script [args]]</code></pre>
<p>Все параметры необязательны. Как мы уже видели, когда мы запускаем <code>lua</code> без аргументов, интерпретатор переходит в интерактивный режим.</p>
<p>Опция <code>-e</code> позволяет нам вводить код прямо в командной строке, как показано ниже:</p>
<pre><code>% lua -е &quot;print (math.sin(12))&quot;    --&gt; -0.53657291800043</code></pre>
<p>(UNIX требует двойных кавычек, чтобы командная оболочка не стала интерпретировать круглые скобки).</p>
<p>Опция <code>-l</code> загружает библиотеку. Как мы уже видели ранее, <code>-i</code> вызывает интерактивный режим после выполнения остальных аргументов. Таким образом, следующий вызов загрузит библиотеку <code>lib</code>, затем выполнит присваивание <code>х=10</code> и выведет приглашение ввода для взаимодействия.</p>
<pre><code>% lua -i -llib -е &quot;х = 10&quot;</code></pre>
<p>В интерактивном режиме вы можете напечатать значение любого выражения, набрав строку, начинающуюся со знака равенства, за которым следует выражение:</p>
<pre><code>&gt; = math.sin(3)   --&gt; 0.14112000805987
&gt; а = 30
&gt; = а             --&gt; 30</code></pre>
<p>Это особенность позволяет использовать Lua как калькулятор.</p>
<p>Перед выполнением своих аргументов интерпретатор ищет переменную окружения с именем <code>LUA_INIT_5_2</code> или, если такой переменной нет, <code>LUA_INIT</code>. Если одна из этих переменных присутствует и содержит <code>@</code><em>имя_файла</em>, то интерпретатор выполнит заданный файл. Если <code>LUA_INIT_5_2</code> (или <code>LUA_INIT</code>) определена, но ее содержимое не начинается с '<code>@</code>', то интерпретатор считает, что она содержит код Lua и выполняет его. <code>LUA_INIT</code> предоставляет огромные возможности по конфигурированию автономного интерпретатора, поскольку при конфигурировании нам доступна вся функциональность Lua. Мы можем предварительно загружать пакеты, изменять текущий путь, определять наши собственные функции, переименовывать или уничтожать функции и т. д.</p>
<p>Скрипт может получать свои аргументы из предопределенной глобальной переменной <code>arg</code>. При таком вызове, как <code>%lua script a b c</code>, интерпретатор перед выполнением скрипта создаст таблицу <code>arg</code> со всеми аргументами командной строки. Имя скрипта располагается по индексу 0, первый аргумент (в примере это <code>а</code>) располагается по индексу 1 и т. д. Предшествующие опции располагаются по отрицательным индексам, поскольку они находятся перед скриптом. Например, рассмотрим этот вызов:</p>
<pre><code>% lua -e &quot;sin=math.sin&quot; script a b</code></pre>
<p>Интерпретатор собирает аргументы следующим образом:</p>
<pre><code>arg[-3] = &quot;lua&quot;
arg[-2] = &quot;-e&quot;
arg[-1] = &quot;sin=math.sin&quot;
arg[0]  = &quot;script&quot;
arg[1]  = &quot;a&quot;
arg[2]  = &quot;b&quot;</code></pre>
<p>Чаще всего скрипт использует только положительные индексы (в примере это <code>arg[1]</code> и <code>arg[2]</code>).</p>
<p>Начиная с Lua 5.1 скрипт также может получить свои аргументы посредством выражения с переменным числом аргументов. В главном теле скрипта выражение <code>...</code> (три точки) передает в скрипт эти аргументы (мы обсудим выражения с переменным числом аргументов в разделе 5.2).</p>
<h3 id="Chapter01.xhtml#sigil_toc_id_13">Упражнения</h3>
<p><strong>Упражнение 1.1.</strong> Запустите пример с факториалом. Что случится с вашей программой, если вы введете отрицательное число? Измените пример, чтобы избежать этой проблемы.</p>
<p><strong>Упражнение 1.2.</strong> Запустите пример <code>twice</code>, один раз загружая файл при помощи опции <code>-l</code>, а другой раз через <code>dofile</code>. Что для вас предпочтительнее?</p>
<p><strong>Упражнение 1.3.</strong> Можете ли вы назвать другой язык, использующий <code>--</code> для комментариев?</p>
<p><strong>Упражнение 1.4.</strong> Какие из следующих строк являются допустимыми идентификаторами?</p>
<pre><code>___    _end    End    end    until?    nil    NULL</code></pre>
<p><strong>Упражнение 1.5.</strong> Напишите простой скрипт, который печатает свое имя, не зная его заранее.</p>
<p><span id="Chapter02.xhtml"></span></p>
<h2>ГЛАВА 2</h2>
<h2 id="Chapter02.xhtml#sigil_toc_id_14">Типы и значения</h2>
<p>Lua — язык с динамической типизацией. В нем нет определений типов; каждое значение содержит в себе свой собственный тип.</p>
<p>В Lua существует восемь базовых типов: <em>nil</em>, <em>boolean</em>, <em>number</em>, <em>string</em>, <em>table,</em> <em>function</em>, <em>userdata</em> и <em>thread</em>. Функция <code>type</code> возвращает имя типа любого заданного значения:</p>
<pre><code>print(type(&quot;Hello world&quot;))    --&gt; string
print(type(10.4*3))           --&gt; number
print(type(print))            --&gt; function
print(type(type))             --&gt; function
print(type(true))             --&gt; boolean
print(type(nil))              --&gt; nil
print(type(type(X)))          --&gt; string</code></pre>
<p>Последняя строка вернет <code>string</code> вне зависимости от значения <code>X</code>, поскольку результат <code>type</code> всегда является строкой.</p>
<p>У переменных нет предопределенных типов; любая переменная может содержать значения любого типа:</p>
<pre><code>print(type(a))    --&gt; nil (&#39;a&#39; не инициализирована)
a = 10
print(type(a))    --&gt; number
a = &quot;a string!!&quot;
print(type(a))    --&gt; string
a = print         -- да, это допустимо!
a(type(a))        --&gt; function</code></pre>
<p>Обратите внимание на последние две строки: в Lua функции являются значениями первого класса; ими можно манипулировать, как и любыми другими значениями. (Более подробно мы рассмотрим данные средства в главе 6.)</p>
<p>Обычно, когда вы используете одну и ту же переменную для значений разных типов, это приводит к запутанному коду. Однако, иногда разумное использование этой возможности оказывается полезным, например, при использовании nil, чтобы отличать нормальное возвращаемое значение от непредусмотренного состояния.</p>
<h3 id="Chapter02.xhtml#sigil_toc_id_15">2.1. Отсутствие значения (<span class="code">nil</span>)</h3>
<p>Тип <strong>nil</strong> — это тип с единственным значением, <strong><em>nil</em></strong>, основная задача которого состоит в том, чтобы отличаться от всех остальных значений. Lua использует nil как нечто, не являющееся значением, чтобы изобразить отсутствие подходящего значения. Как мы уже видели, глобальные переменные по умолчанию имеют значение nil до своего первого присваивания, и вы можете присвоить nil глобальной переменной, чтобы удалить ее.</p>
<h3 id="Chapter02.xhtml#sigil_toc_id_16">2.2. Логические значения (<span class="code">boolean</span>)</h3>
<p>Тип <strong>boolean</strong> обладает двумя значениями — <em><strong>true</strong></em> и <em><strong>false</strong></em>, которые представляют традиционные логические (или булевы) значения. Однако, не только булевы значения могут выражать условие: в Lua условие может быть представлено любым значением. Проверки условий (например, условий в управляющих структурах) считают nil и булево false ложными, а все прочие значения истинными. В частности, при проверках условий Lua считает ноль и пустую строку истинными значениями.</p>
<p>На протяжении данной книги «ложными» будут называться значения nil и false, а «истинными» — все остальные. Когда речь идет именно о булевых значениях, они указываются явно как false или true.</p>
<h3 id="Chapter02.xhtml#sigil_toc_id_17">2.3. Числа (<span class="code">number</span>)</h3>
<p>Тип <strong>number</strong> представляет вещественные числа, т.е. числа двойной точности с плавающей точкой <strong>(тип double в C)</strong>. В Lua нет целочисленного типа <strong>(тип integer в C)</strong>.</p>
<p>Некоторые опасаются, что даже простые операции инкремента или сравнения могут некорректно работать с числами с плавающей точкой. Однако, на самом деле это не так. Практически все платформы в наше время поддерживают стандарт IEEE 754 для представления чисел с плавающей точкой. Согласно этому стандарту, единственным возможным источником ошибок является ошибка представления, которая происходит, когда число не может быть точно представлено. Операция округляет свой результат, только если у него нет точного представления. Любая операция, результат которой может быть точно представлен, должна выдавать его без округления.</p>
<p>Ha самом деле любое целое число вплоть до 2<sup>53</sup> (приблизительно 10<sup>16</sup>) имеет точное представление в виде числа двойной точности с плавающей точкой. Когда вы используете вещественные числа для представления целых, никаких ошибок округления не происходит, пока модуль числа не превышает 2<sup>53</sup>. В частности, число Lua может представлять любые 32-битовые целые числа без проблем с округлением.</p>
<p>Разумеется, у дробных чисел могут быть ошибки представления. Эта ситуация не отличается от той, когда вы пользуетесь ручкой и бумагой. Если мы хотим записать <code>1/7</code> в десятичном виде, то мы должны будем где-то остановиться. Если мы используем десять цифр для представления числа, то <code>1/7</code> будет округлено до <code>0.142857142</code>. Если мы вычислим <code>1/7*7</code> при помощи десяти цифр, то получим <code>0.999999994</code>, что отличается от <code>1</code>. Более того, дробные числа, которые имеют конечное представление в десятичном виде, могут иметь бесконечное представление в двоичном виде. Например, <code>12.7-20+7.3</code> не равно нулю, поскольку у обоих чисел, <code>12.7</code> и <code>7.3</code>, нет точного конечного представления в двоичном виде (см. упражнение 2.3).</p>
<p>Прежде чем мы продолжим, запомните: у целых чисел есть точное представление и потому нет ошибок округления.</p>
<p>Большинство современных процессоров выполняет операции с плавающей точкой так же быстро, как и с целыми числами (или даже быстрее). Тем не менее, легко скомпилировать Lua так, чтобы он использовал для числовых значений другой тип, например, длинные целые числа <strong>(тип long в C)</strong> или числа одинарной точности с плавающей точкой <strong>(тип float в C)</strong>. Это особенно удобно для платформ без аппаратной поддержки чисел с плавающей точкой, например, для встраиваемых систем. Подробности смотрите в файле <code>luaconf.h</code> из дистрибутива.</p>
<p>Мы можем записывать числовые константы вместе с необязательной десятичной дробной частью и необязательным десятичным порядком. Примеры допустимых числовых констант:</p>
<pre><code>4    0.4    4.57е-3    0.3е12    5Е+20</code></pre>
<p>Более того, мы также можем использовать шестнадцатеричные константы, применив префикс <code>0x</code>. Начиная с Lua 5.2, шестнадцатеричные константы также могут иметь дробную часть и двоичный порядок (с префиксом '<code>р</code>' или '<code>Р</code>'), как в следующих примерах:</p>
<pre><code>Oxff (255)    0х1АЗ (419)    0x0.2 (0.125)    0х1р-1 (0.5)
0ха.Ьр2 (42.75)</code></pre>
<p>(Для каждой константы мы добавили в круглых скобках ее десятичное представление.)</p>
<h3 id="Chapter02.xhtml#sigil_toc_id_18">2.4. Строки (<span class="code">string</span>)</h3>
<p>Тип <strong>string</strong> в Lua имеет обычный смысл: последовательность символов. Lua поддерживает все 8-битовые символы, и его строки могут содержать символы с любыми числовыми кодами, включая нуль-символы. Это значит, что вы можете хранить в виде строк любые бинарные данные. Вы также можете хранить строки Юникода в любом представлении (UTF-8, UTF-16 и т. д.). Стандартная библиотека, которая идет вместе с Lua, не предлагает явную поддержку этих представлений. Тем не менее, вы можете работать со строками UTF-8 вполне привычным образом, что будет рассмотрено в разделе 21.7.</p>
<p>Строки в Lua являются неизменяемыми значениями. Вы не можете изменить символ внутри строки, как вы делаете это в С; вместо этого вы создаете новую строку с необходимыми изменениями, как показано в следующем примере:</p>
<pre><code>a = &quot;one string&quot;
b = string.gsub(a, &quot;one&quot;, &quot;another&quot;)    -- меняет части строки
print(a)    --&gt; строка &quot;one&quot;
print(b)    --&gt; строка &quot;another&quot;</code></pre>
<p>Строки в Lua подвержены автоматическому управлению памятью, как и любые другие объекты Lua (таблицы, функции и т. д.). Это значит, что вам не нужно беспокоиться о выделении и освобождении строк; этим за вас займется Lua. Строка может состоять из одного символа или целой книги. Программы, которые обрабатывают строки из 100К или 10М символов, — не редкость в Lua.</p>
<p>Вы можете получить длину строки, используя префиксную операцию '<code>#</code>' (называемую <em>операцией длины</em>):</p>
<pre><code>a = &quot;hello&quot;
print(#a)              --&gt; 5
print(#&quot;good\0bye&quot;)    --&gt; 8</code></pre>
<h4 id="Chapter02.xhtml#sigil_toc_id_19">Cтроковые литералы</h4>
<p>Мы можем определять границы строковых литералов при помощи пар одинарных или двойных кавычек:</p>
<pre><code>a = &quot;a line&quot;
b = &#39;another line&#39;</code></pre>
<p>Эти виды записи эквиваленты; единственное отличие состоит в том, что внутри одного вида кавычек вы можете использовать другой, не применяя экраны (т.е. экранированные/управляющие последовательности).</p>
<p>Это дело вкуса, но большинство программистов всегда использует кавычки одного вида для одних и тех же видов строк, где «виды» строк зависят от программы. Например, библиотека, которая работает с XML, может зарезервировать строки в одинарных кавычках для фрагментов XML, поскольку эти фрагменты часто содержат двойные кавычки.</p>
<p>Строки в Lua могут содержать следующие C-образные экранированные последовательности:</p>
<table>
<tbody>
<tr class="odd">
<td><code>\а</code> звонок<br />
<code>\b</code> возврат на одну позицию (backspace)<br />
<code>\f</code> перевод страницы<br />
<code>\n</code> перевод строки<br />
<code>\г</code> возврат каретки<br />
<code>\t</code> горизонтальная табуляция<br />
<code>\v</code> вертикальная табуляция<br />
<code>\\</code> обратный слеш<br />
<code>\&quot;</code> двойная кавычка<br />
<code>\'</code> одинарная кавычка<br />
</td>
</tr>
</tbody>
</table>
<p>Следующие примеры иллюстрируют их использование:</p>
<pre><code>&gt; print(&quot;one line\nnext line\n\&quot;in quotes\&quot;, &#39;in quotes&#39;&quot;)
one line
next line
&quot;in quotes&quot;, &#39;in quotes&#39;

&gt; print(&#39;a backslash inside quotes: \&#39;\\\&#39;&#39;)
a backslash inside quotes: &#39;\&#39;

&gt; print(&quot;a simpler way: &#39;\\&#39;&quot;)
a simpler way: &#39;\&#39;</code></pre>
<p>Мы также можем задать символ в строке при помощи его числового значения через экранированные последовательности <code>\</code><em>ddd</em> и <code>\x\</code><em>hh</em>, где <em>ddd</em> — это последовательность не более чем из трех десятичных цифр, a <em>hh</em> — последовательность ровно из двух шестнадцатеричных цифр. В качестве примера посложнее возьмем два литерала: &quot;<code>alo\n123\</code>&quot; и '<code>\971o\10\04923</code>'. Они обладают одним и тем же значением в системе, использующей ASCII: 97 — это код ASCII для '<code>а</code>', 10 — это код для символа перевода строки, а 49 — это код для цифры '<code>1</code>'. (В этом примере мы должны записать значение 49 при помощи трех десятичных цифр как <code>\049</code>, поскольку за ним следует другая цифра; иначе Lua прочтет это число как 492). Мы также можем записать эту строку как '<code>\x61\x6c\x6f\x0a\x31\x32\x33\x22</code>', представляя каждый символ его шестнадцатеричным кодом.</p>
<h4 id="Chapter02.xhtml#sigil_toc_id_20">Дпинные строки</h4>
<p>Мы можем задавать строковые литералы при помощи пар из двойных квадратных скобок, как мы делали это с длинными комментариями. Литералы в этой скобочной форме могут занимать несколько строк, а экранированные последовательности в этих строках не будут интерпретироваться. Более того, эта форма игнорирует первый символ строки, если это перевод строки. Эта форма особенно удобна для написания строк, содержащих большие фрагменты кода, как в следующем примере:</p>
<pre><code>page = [[
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;An HTML Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;a href=&quot;http://www.lua.org&quot;&gt;Lua&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
]]

write(page)</code></pre>
<p>Иногда вам может потребоваться заключить в квадратные скобки фрагмент кода, который содержит нечто вроде <code>a = b[c[i]]</code> (обратите внимание на <code>]]</code> в этом коде) или содержит уже закомментированный фрагмент. Чтобы справиться с подобными ситуациями, вы можете добавить любое количество знаков равенства между двумя открывающими квадратными скобками, например, так: <code>[===[</code>. После этого изменения строковый литерал завершится только на следующих закрывающих квадратных скобках с тем же самым количеством знаков равенства между ними (<code>]===]</code> для нашего примера). Сканер Lua игнорирует пары скобок с разным количеством знаков равенства. Путем подбора подходящего количества знаков равенства вы можете заключить в квадратные скобки любой строковый литерал без необходимости добавлять в него экраны.</p>
<p>Такая же возможность действует и для комментариев. Например, если вы начнете длинный комментарий с <code>--[=[</code>, то он будет продолжаться вплоть до следующей пары <code>]=]</code>. Эта возможность позволяет запросто закомментировать фрагмент кода, который содержит уже закомментированные части.</p>
<p>Длинные строки — это идеальный формат для включения текста в виде литерала в ваш код, но вам не следует использовать их для нетекстовых литералов. Хотя строковые литералы в Lua могут содержать любые символы, использовать такие символы в своем коде — не очень хорошая идея: вы можете столкнуться с проблемами при работе с вашим текстовым редактором; более того, последовательности для завершения строк наподобие &quot;<code>\r\n</code>&quot; могут при чтении измениться на &quot;<code>\n</code>&quot;. Вместо этого лучше кодировать произвольные бинарные данные при помощи числовых (десятичных и шестнадцатеричных) экранированных последовательностей, таких как &quot;<code>\х13\х01\хА1\хВВ</code>&quot;. Однако, это представляет проблему для длинных строк, поскольку может привести к строкам довольно большого размера.</p>
<p>Для подобных ситуаций Lua 5.2 предлагает экранированную последовательность <code>\z</code>: она пропускает все последующие символы в строке вплоть до первого непробельного символа. Следующий пример иллюстрирует ее применение:</p>
<pre><code>data = &quot;\x00\x01\х02\x03\x04\x05\x06\x07\z

        \x08\x09\xOMxOB\xOC\xOD\xOE\xOF&quot;</code></pre>
<p>Находящаяся в конце первой строки <code>\z</code> пропускает последующий конец строки и отступ следующей строки, поэтому в итоговой строке за байтом <code>\х07</code> сразу же следует байт <code>\х08</code>.</p>
<h4 id="Chapter02.xhtml#sigil_toc_id_21">Приведения типов</h4>
<p>Lua обеспечивает автоматическое преобразование между числами и строками во время выполнения программ. Любая числовая операция, примененная к строке, пытается преобразовать эту строку в число:</p>
<pre><code>print(&quot;10&quot; + 1)         --&gt; 11
print(&quot;10 + 1&quot;)         --&gt; 10 + 1
print(&quot;-5.3e-10&quot;*&quot;2&quot;)   --&gt; -1.06e-09
print(&quot;hello&quot; + 1)      -- ОШИБКА (невозможно преобразовать &quot;hello&quot;)</code></pre>
<p>Lua применяет подобные преобразования не только в арифметических операциях, но и в других местах, где ожидается число, таких как аргумент <code>math.sin</code>.</p>
<p>Верно и обратное — каждый раз, когда Lua находит число там, где ожидает строку, он преобразует это число в строку:</p>
<pre><code>print(10 .. 20)         --&gt; 1020</code></pre>
<p>(Операция <code>..</code> служит в Lua для конкатенации строк. Когда вы записываете ее сразу после числа, вы должны отделить их друг от друга при помощи пробела; иначе Lua решит, что первая точка — это десятичная точка числа.)</p>
<p>Сегодня мы не уверены, что эти автоматические приведения типов были хорошей идеей в дизайне Lua. Как правило, лучше на них не рассчитывать. Они удобны в некоторых местах; но добавляют сложности как языку, так и программам, которые их используют. В конце концов, строки и числа — это разные вещи, несмотря на все эти преобразования. Сравнение вроде <code>10=&quot;</code><code>10&quot;</code> дает в результате false, поскольку <code>10</code> <span>— это число, а</span> <code>&quot;</code>10</code><code>&quot;</code> <span>— это строка.</span></p>
<p>Если вам нужно явно преобразовать строку в число, то вы можете воспользоваться функцией <code>tonumber</code>, которая возвращает nil, если строка не является правильным числом Lua:</p>
<pre><code>line = io.read()           -- читает строку
n = tonumber(line)         -- пытается преобразовать ее в число
if n == nil then
  error(line .. &quot; is not a valid number&quot;)
else
  print(n*2)
end</code></pre>
<p>Для преобразования числа в строку вы можете использовать функцию <code>tostring</code> или конкатенировать число с пустой строкой:</p>
<pre><code>print(tostring(10) == &quot;10&quot;)    --&gt; true
print(10 .. &quot;&quot; == &quot;10&quot;)        --&gt; true</code></pre>
<p>Эти преобразования всегда работают.</p>
<h3 id="Chapter02.xhtml#sigil_toc_id_22">2.5. Таблицы (<span class="code">table</span>)</h3>
<p>Тип <strong>table</strong> представляет ассоциативные массивы. Ассоциативный массив — это массив, который может быть индексирован не только числами, но и строками или любым другим значением языка, кроме nil.</p>
<p>Таблицы являются главным (на самом деле единственным) механизмом структурирования данных в Lua, притом очень эффективным. Мы используем таблицы для представления обычных массивов, множеств, записей и других структур данных простым, однородным и эффективным способом. Также Lua использует таблицы для представления пакетов и объектов. Когда мы пишем <code>io.read</code>, мы думаем о «функции <code>read</code> из модуля <code>io</code>». Для Lua это выражение означает «индексировать таблицу <code>io</code>, используя строку <code>read</code> в качестве ключа».</p>
<p>Таблицы в Lua не являются ни значениями, ни переменными; они <em>объекты</em>. Если вы знакомы с массивами в Java или Scheme, то вы понимаете, что я имею в виду. Вы можете рассматривать таблицу как динамически выделяемый объект; ваша программа работает только со ссылками (указателями) на них. Lua никогда не прибегает к скрытому копированию или созданию новых таблиц. Более того, вам не нужно объявлять таблицу в Lua; на самом деле для этого даже не существует способа. Вы создаете таблицы при помощи <em>выражения-конструктора</em>, которое в своей простейшей форме записывается как <code>{}</code>:</p>
<pre><code>a = {}            -- создает таблицу и сохраняет ссылку на нее в &#39;a&#39;
k = &quot;x&quot;
a[k] = 10         -- новая запись с ключом &quot;x&quot; и значением 10
a[20] = &quot;great&quot;   -- новая запись с ключом 20 и значением &quot;great&quot;
print(a[&quot;x&quot;])     --&gt; 10
k = 20
print(a[k])       --&gt; &quot;great&quot;
a[&quot;x&quot;] = a[&quot;x&quot;] + 1    -- инкрементирует запись &quot;x&quot;
print(a[&quot;x&quot;])     --&gt; 11</code></pre>
<p>Таблица всегда анонимна. Не существует постоянной связи между переменной, которая хранит таблицу, и самой таблицей:</p>
<pre><code>a = {}
a[&quot;x&quot;] = 10
b = a            -- &#39;b&#39; ссылается на ту же таблицу, что и &#39;a&#39;
print(b[&quot;x&quot;])    --&gt; 10
b[&quot;x&quot;] = 20
print(a[&quot;x&quot;])    --&gt; 20
a = nil          -- лишь &#39;b&#39; по-прежнему ссылается на ту таблицу
b = nil          -- ссылок на таблицу не осталось</code></pre>
<p>Когда в программе больше не остается ссылок на таблицу, сборщик мусора Lua со временем удалит эту таблицу, чтобы повторно использовать ее память.</p>
<p>Каждая таблица может хранить значения с разными типами индексов и растет по мере добавления новых записей:</p>
<pre><code>a = {}           -- пустая таблица
-- создает 1000 новых записей
for i = 1, 1000 do a[i] = i*2 end
print(a[9])      --&gt; 18
a[&quot;x&quot;] = 10
print(a[&quot;x&quot;])    --&gt; 10
print(a[&quot;y&quot;])    --&gt; nil</code></pre>
<p>Обратите внимание на последнюю строку: как и глобальные переменные, поля таблицы возвращают nil, когда не инициализированы. Так же, как и с глобальными переменными, вы можете присвоить полю таблицы nil, чтобы его удалить. Это не совпадение: Lua хранит глобальные переменные в обыкновенных таблицах. Мы рассмотрим это подробнее в главе 14.</p>
<p>Для представления записей вы используете имя поля как индекс. Lua поддерживает это представление, предлагая <code>a.name</code> в качестве синтаксического сахара для <code>a[&quot;name&quot;]</code>. Таким образом, мы можем переписать последние строки предыдущего примера следующим, более чистым образом:</p>
<pre><code>a.x = 10      -- то же, что и a[&quot;x&quot;] = 10
print(a.x)    -- то же, что и print(a[&quot;x&quot;])
print(a.y)    -- то же, что и print(a[&quot;y&quot;])</code></pre>
<p>Для Lua эти две формы эквивалентны и могут свободно использоваться вместе. Для читателя, однако, каждая форма может сообщать о разном намерении. Точечная нотация ясно показывает, что мы используем таблицу как запись, где у нас есть некоторый набор постоянных, предопределенных ключей. Строковая нотация дает представление о том, что у таблицы в качестве ключа может быть любая строка, и что по некоторой причине мы работаем с этим конкретным ключом.</p>
<p>Типичная ошибка новичков — спутать <code>а.х</code> с <code>а[х]</code>. Первая форма соответствует <code>а[&quot;х&quot;]</code>, то есть таблица индексирована при помощи строки &quot;<code>х</code>&quot;. Вторая форма означает, что таблица индексирована при помощи значения переменной <code>х</code>. Взгляните на разницу:</p>
<pre><code>a = {}
x = &quot;y&quot;
a[x] = 10                 -- записывает 10 в поле &quot;y&quot;
print(a[x])    --&gt; 10     -- значение поля &quot;y&quot;
print(a.x)     --&gt; nil    -- значение поля &quot;x&quot; (не определено)
print(a.y)     --&gt; 10     -- значение поля &quot;y&quot;</code></pre>
<p>Чтобы представить традиционный массив или список, просто используйте таблицу с целочисленными ключами. Нет ни способа, ни необходимости объявлять размер; вы всего лишь инициализируете те элементы, которые вам нужны:</p>
<pre><code>-- считывает 10 строк, сохраняя их в таблице
a = {}
for i = 1, 10 do
  a[i] = io.read()
end</code></pre>
<p>Поскольку вы можете индексировать таблицу любым значением, вы можете начинать индексы массива с любого числа, которое вам нравится. Однако, в Lua принято начинать массивы с единицы (а не с нуля, как в С), и некоторые средства Lua придерживаются этого соглашения.</p>
<p>Обычно, когда вы работаете со списком, вам нужно знать его длину. Она может быть константой или храниться где-то еще. Часто мы храним длину списка в нечисловом поле таблицы; по историческим причинам некоторые программы используют для этих целей поле &quot;<code>n</code>&quot;.</p>
<p>Однако, зачастую длина не может быть явно определена. Как вы помните, любой неинициализированный индекс равен nil; вы можете использовать это значение как граничную метку для обозначения конца списка. Например, после считывания десяти строк в список легко запомнить, что его длина равна 10, поскольку его числовыми ключами являются <code>1,2,...,10</code>. Этот прием работает только тогда, когда у списка нет <em>дыр</em>, т.е. элементов nil внутри него. Мы называем такой список <em>последовательностью</em> <strong>(sequence)</strong>.</p>
<p>Для последовательностей Lua предлагает операцию длины '<code>#</code>'. Она возвращает последний индекс или длину последовательности. Например, вы можете напечатать строки, cчитанные в предыдущем примере, при помощи следующего кода:</p>
<pre><code>-- печатает строки
for i = 1, #a do
  print(a[i])
end</code></pre>
<p>Поскольку мы можем индексировать таблицу с помощью любого типа, то при индексировании таблицы возникают те же тонкости, что и при проверке на равенство. Хотя мы можем индексировать таблицу и с помощью целого числа <code>0</code>, и с помощью строки &quot;<code>0</code>&quot;, эти два значения различны и тем самым соответствуют разным записям таблицы. Аналогично, строки &quot;<code>+1</code>&quot;, &quot;<code>01</code>&quot; и &quot;<code>1</code>&quot; также соответствуют разным записям таблицы. Когда вы не уверены насчет действительных типов ваших индексов, для верности используйте явное приведение типов:</p>
<pre><code>i = 10; j = &quot;10&quot;; k = &quot;+10&quot;
a = {}
a[i] = &quot;one value&quot;
a[j] = &quot;another value&quot;
a[k] = &quot;yet another value&quot;
print(a[i])                   --&gt; one value
print(a[j])                   --&gt; another value
print(a[k])                   --&gt; yet another value
print(a[tonumber(j)])         --&gt; one value
print(a[tonumber(k)])         --&gt; one value</code></pre>
<p>В вашей программе могут появиться трудноуловимые ошибки, если не уделять внимание данному моменту.</p>
<h3 id="Chapter02.xhtml#sigil_toc_id_23">2.6. Функции (<span class="code">function</span>)</h3>
<p>Функции (тип <strong>function</strong>) являются в Lua значениями первого класса: программы могут хранить функции в переменных, передавать функции как аргументы для других функций и возвращать функции как результаты. Подобные возможности придают языку огромную гибкость; программа может переопределить функцию, чтобы добавить новую функциональность, или просто стереть функцию для создания безопасного окружения при выполнении фрагмента ненадежного кода (например, кода, полученного по сети). Более того, Lua предоставляет хорошую поддержку функционального программирования, включая вложенные функции с соответствующим лексическим окружением; просто дождитесь главы 6. Наконец, функции первого класса играют ключевую роль в объектно-ориентированных возможностях Lua, как мы увидим в главе 16.</p>
<p>Lua может вызывать функции, написанные на Lua, и функции, написанные на С. Обычно мы прибегаем к функциям С для достижения более высокого быстродействия и для доступа к средствам, недоступным непосредственно из Lua, таким как средства операционной системы. Все стандартные библиотеки в Lua написаны на С. Они включают в себя функции обработки строк, обработки таблиц, ввода-вывода, доступа к базовым средствам операционной системы, математические и отладочные функции.</p>
<p>Мы обсудим функции Lua в главе 5, а функции С в главе 27.</p>
<h3 id="Chapter02.xhtml#sigil_toc_id_24">2.7. Пользовательские данные (<span class="code">userdata</span>)</h3>
<p>Тип <strong>userdata</strong> позволяет запоминать произвольные данные С в переменных Lua. У него нет предопределенных операций в Lua, за исключением присваивания и проверки на равенство. Пользовательские данные используются для представления новых типов, созданных прикладной программой или библиотекой, написанной на С; например, стандартная библиотека ввода-вывода использует их для представления открытых файлов. Мы более подробно обсудим этот тип позже, когда перейдем к С API.</p>
<h3 id="Chapter02.xhtml#sigil_toc_id_25">2.8. Нити (<span class="code">thread</span>)</h3>
<p>Тип <strong>thread</strong> будет разобран в главе 9, где мы рассмотрим сопрограммы.</p>
<h3 id="Chapter02.xhtml#sigil_toc_id_26">Упражнения</h3>
<p><strong>Упражнение 2.1.</strong> Что является значением выражения <code>type(nil)==nil</code>? (Вы можете использовать Lua для проверки своего ответа.) Можете ли вы объяснить результат?</p>
<p><strong>Упражнение 2.2.</strong> Какие из приведенных ниже чисел являются допустимыми в Lua? Каковы их значения?</p>
<pre><code>.0e12    .e12    0.0e    0x12    0xABFG    0xA FFFF    0xFFFFFFFF
0x    0x1P10    0.1e1    0x0.1p1</code></pre>
<p><strong>Упражнение 2.3.</strong> Число <code>12.7</code> равно дроби <code>127/10</code>, где знаменатель является степенью десяти. Можете ли вы представить его в виде простой дроби, где знаменатель является степенью двойки? Как насчет числа <code>5.5</code>?</p>
<p><strong>Упражнение 2.4.</strong> Как вы можете вставить следующий фрагмент XML в виде строки в Lua?</p>
<pre><code>&lt;![CDATA[
Hello world
]]&gt;</code></pre>
<p>Используйте не менее двух разных способов.</p>
<p><strong>Упражнение 2.5.</strong> Допустим, вам нужно записать длинную последовательность произвольных байт в виде строкового литерала в Lua. Как вы это сделаете? Обратите внимание на такие моменты, как читаемость, максимальную длину строки и быстродействие.</p>
<p><strong>Упражнение 2.6.</strong> Рассмотрите следующий код:</p>
<pre><code>а = {}; а.а = а</code></pre>
<p>Что будет значением <code>а.а.а.а</code>? Какое-либо <code>а</code> в этой последовательности как-то отличается от остальных?</p>
<p>Теперь добавьте следующую строку к предыдущему коду:</p>
<pre><code>а.а.а.а = 3</code></pre>
<p>Что теперь будет значением <code>а.а.а.а</code>?</p>
<p><span id="Chapter03.xhtml"></span></p>
<h2>ГЛАВА 3</h2>
<h2 id="Chapter03.xhtml#sigil_toc_id_27">Выражения</h2>
<p>Выражения служат для получения значений. Выражения в Lua включают числовые константы, строковые литералы, переменные, унарные и бинарные операции и вызовы функций. В выражения также могут входить нетрадиционные определения функций и конструкторы таблиц.</p>
<h3 id="Chapter03.xhtml#sigil_toc_id_28">3.1. Арифметические операции</h3>
<p>Lua поддерживает стандартные арифметические операции: бинарные '<code>+</code>' (сложение), '<code>-</code>' (вычитание), '<code>*</code>' (умножение), '<code>/</code>' (деление), '<code>^</code>' (возведение в степень), '<code>%</code>' (остаток от деления) и унарную '<code>-</code>' (отрицание). Все они работают с вещественными числами. Например, <code>х^0.5</code> вычисляет квадратный корень из <code>х</code>, а <code>х^(-1/3)</code> вычисляет обратно пропорциональное значение его кубического корня.</p>
<p>Следующее правило определяет операцию остатка от деления:</p>
<pre><code>а % b == а - math.floor(a/b)*b</code></pre>
<p>Для целочисленных операндов она работает обычным образом и дает результат с тем же знаком, что и у второго аргумента. Для вещественных операндов у нее есть некоторое дополнительное применение. Например, <code>х%1</code> дает дробную часть <code>х</code>, следовательно, <code>х-х%1</code> дает его целую часть. Аналогично, <code>х-х%0.01</code> дает <code>х</code> ровно с двумя десятичными цифрами после запятой:</p>
<pre><code>х = math.pi
print(х - х%0.01)                   --&gt; 3.14</code></pre>
<p>В качестве другого примера применения операции остатка от деления допустим, что вам требуется проверить, будет ли транспортное средство после поворота на заданный угол возвращаться в исходное положение. Если угол задан в градусах, то вы можете использовать следующую формулу:</p>
<pre><code>local tolerance = 10
function isturnback (angle)
  angle = angle % 360
  return (math.abs(angle - 180) &lt; tolerance)
end</code></pre>
<p>Это определение работает даже для отрицательных углов:</p>
<pre><code>print(isturnback(-180))         --&gt; true</code></pre>
<p>Если нам потребуется работать с радианами вместо градусов, то мы просто изменим константы в нашей функции:</p>
<pre><code>local tolerance = 0.17
function isturnback (angle)
  angle = angle % (2*math.pi)
  return (math.abs(angle - math.pi) &lt; tolerance)
end</code></pre>
<p>Операция <code>angle%(2*math.pi)</code> — это все, что нам нужно для приведения любого угла к значению в интервале [0, 2π).</p>
<h3 id="Chapter03.xhtml#sigil_toc_id_29">3.2. Операции сравнения</h3>
<p>Lua предоставляет следующие операции сравнения:</p>
<pre><code>&lt;    &gt;    &lt;=    &gt;=    ==    ~=</code></pre>
<p>Все эти операции всегда производят булево значение.</p>
<p>Операция <code>==</code> проверяет на равенство; операция <code>~=</code> проверяет на неравенство. Мы можем применять обе эти операции к любым двум значениям. Если значения обладают разными типами, то Lua считает, что они не равны. В противном случае Lua сравнивает их в соответствии с их типами. В частности, nil равно только самому себе.</p>
<p>Lua сравнивает таблицы и пользовательские данные по ссылке, то есть два таких значения считаются равными, только если они являются одним и тем же объектом. Например, после выполнения следующего кода:</p>
<pre><code>a = {}; a.x = 1; a.y = 0
b = {}; b.x = 1; b.y = 0
c = a</code></pre>
<p>мы получим <code>а == с</code>, но <code>а ~= b</code>.</p>
<p>Мы можем применять операции порядка лишь к двум числам или двум строкам. Lua сравнивает строки в алфавитном порядке, следуя установленной для Lua локали. Например, для португальской локали Latin-1 мы получим <code>&quot;acai&quot; &lt; &quot;açaí&quot; &lt; &quot;acorde&quot;</code>. Значения, отличные от чисел и строк, можно сравнивать только на равенство (и неравенство).</p>
<p>При сравнении значений разных типов нужно быть аккуратным: помните, что &quot;<code>0</code>&quot; отличается от <code>0</code>. Более того, <code>2&lt;15</code> очевидно истинно, но <code>&quot;2&quot;&lt;&quot;15&quot;</code> ложно (из-за алфавитного порядка). Чтобы избежать непостоянных результатов, Lua выбрасывает ошибку, когда вы смешиваете строки и числа при выявлении их порядка, таком как <code>2&lt;&quot;15&quot;</code>.</p>
<h3 id="Chapter03.xhtml#sigil_toc_id_30">3.3. Логические операции</h3>
<p>Логические операции — это <strong>and</strong>, <strong>or</strong> и <strong>not</strong>. Как и управляющие структуры, все логические операции трактуют false и nil как ложные, а все остальные — как истинные значения. Операция <strong>and</strong> возвращает свой первый аргумент, если он ложный, иначе она возвращает свой второй аргумент. Операция <strong>or</strong> возвращает свой первый аргумент, если он не ложный; иначе она возвращает свой второй аргумент:</p>
<pre><code>print(4 and 5)         --&gt; 5
print(nil and 13)      --&gt; nil
print(false and 13)    --&gt; false
print(4 or 5)          --&gt; 4
print(false or 5)      --&gt; 5</code></pre>
<p>Обе операции, <strong>and</strong> и <strong>or</strong>, используют сокращенное вычисление, то есть они вычисляют свой второй операнд только при необходимости. Сокращенное вычисление обеспечивает отсутствие ошибок во время выполнения для выражений вроде <code>(type(v) == &quot;table&quot; and v.tag == &quot;h1&quot;)</code>: Lua не будет пытаться вычислить <code>v.tag</code>, когда <code>v</code> не является таблицей.</p>
<p>Полезной идиомой Lua является <code>х=х or v</code>, которая эквивалентна</p>
<pre><code>if not х then х = v end</code></pre>
<p>To есть значение <code>x</code> по умолчанию устанавливается равным значению <code>v</code>, если <code>х</code> не определен (при условии, что <code>х</code> не равен false).</p>
<p>Другой полезной идиомой является <code>(a and b) or с</code> или просто <code>a and b or с</code>, поскольку у <strong>and</strong> более высокий приоритет, чем у <strong>or</strong>. Она эквивалентна выражению <code>а?b:с</code> в языке С, при условии что <code>b</code> не ложно. Например, мы можем выбрать максимум из двух чисел <code>х</code> и <code>у</code> при помощи такого оператора:</p>
<pre><code>max = (х &gt; у) and х or у</code></pre>
<p>Когда <code>х &gt; у</code>, первое выражение с <strong>and</strong> истинно, поэтому <strong>and</strong> возвращает свое второе выражение (<code>х</code>), которое всегда истинно (поскольку это число), и затем выражение с <strong>or</strong> возвращает значение своего первого выражения, <code>х</code>. Когда <code>х &gt; у</code> ложно, выражение с <strong>and</strong> тоже ложно, поэтому <strong>or</strong> возвращает свое второе выражение, <code>у</code>.</p>
<p>Операция <strong>not</strong> всегда возвращает булево значение:</p>
<pre><code>print(not nil)        --&gt; true
print(not false)      --&gt; true
print(not 0)          --&gt; false
print(not not 1)      --&gt; true
print(not not nil)    --&gt; false</code></pre>
<h3 id="Chapter03.xhtml#sigil_toc_id_31">3.4. Конкатенация</h3>
<p>Lua обозначает операцию конкатенации строк как <code>..</code> (две точки). Если один из операндов является числом, то Lua переведет его в строку. (Некоторые языки используют для конкатенации операцию '<code>+</code>', но в Lua <code>3+5</code> отличается от <code>3..5</code>.)</p>
<pre><code>print(&quot;Hello &quot; .. &quot;World&quot;)    --&gt; Hello World
print(0 .. 1)                 --&gt; 01
print(000 .. 01)              --&gt; 01</code></pre>
<p>Помните, что строки в Lua являются неизменяемыми значениями. Операция конкатенации всегда создает новую строку, не изменяя свои операнды:</p>
<pre><code>a = &quot;Hello&quot;
print(a .. &quot; World&quot;)    --&gt; Hello World
print(a)                --&gt; Hello</code></pre>
<h3 id="Chapter03.xhtml#sigil_toc_id_32">3.5. Операция длины</h3>
<p>Операция длины работает со строками и таблицами. Со строками она дает количество байт в строке. С таблицами она возвращает длину представленной ими <em>последовательности</em>.</p>
<p>С операцией длины связано несколько распространенных идиом для работы с последовательностями:</p>
<pre><code>print(a[#a])     -- печатает последнее значение последовательности &#39;a&#39;
a[#a] = nil      -- удаляет это последнее значение
a[#a + 1] = v    -- добавляет &#39;v&#39; к концу списка</code></pre>
<p>Как мы видели в предыдущей главе, операция длины непредсказуема для списков с дырами (т.е. nil). Она работает только для последовательностей, которые определены как списки без дыр. Более точно, <em>последовательность</em> — это таблица, где числовые ключи образуют множество <code>1,...,</code><em>n</em> для некоторого <em>n</em>. (Помните, что любой ключ со значением nil на самом деле в таблице отсутствует.) В частности, таблица без числовых ключей — это последовательность нулевой длины.</p>
<p>С годами было много предложений по расширению значения операции длины на списки с дырами, но это легче сказать, чем сделать. Проблема в том, что поскольку список на самом деле является таблицей, то понятие «длины» несколько расплывчато. Например, рассмотрим список, получаемый в результате следующего кода:</p>
<pre><code>a = {}
a[1] = 1
a[2] = nil    -- ничего не делает, так как a[2] уже nil
a[3] = 1
a[4] = 1</code></pre>
<p>Легко сказать, что длина этого списка четыре, и у него есть дыра по индексу 2. Однако, что можно сказать о следующем похожем примере?</p>
<pre><code>a = {}
a[1] = 1
a[10000] = 1</code></pre>
<p>Должны ли мы рассматривать <code>a</code> как список с 10 000 элементами, где 9 998 из них равны nil? Теперь программа делает следующее:</p>
<pre><code>a[10000] = nil</code></pre>
<p>Какова теперь длина этого списка? Должна ли она быть равна 9 999, поскольку программа удалила последний элемент? Или может быть она по-прежнему равна 10 000, так как программа всего лишь изменила значение последнего элемента на nil? Или же длина должна уменьшиться до 1?</p>
<p>Другое распространенное предложение — сделать так, чтобы операция <code>#</code> возвращала общее число элементов в таблице. Эта семантика ясна и хорошо определена, но не несет в себе никакой пользы. Рассмотрим все предыдущие примеры и представим, насколько полезной оказалось бы подобная операция для алгоритмов, работающих со списками или массивами.</p>
<p>Еще более проблемными являются значения nil в конце списка. Какой должна быть длина следующего списка?</p>
<pre><code>a = {10, 20, 30, nil, nil}</code></pre>
<p>Вспомним, что для Lua поле с nil не отличается от отсутствующего поля. Таким образом, предыдущая таблица эквивалентна <code>{10,20,30}</code>; ее длина равна 3, а не 5.</p>
<p>Вы можете считать, что nil в конце списка — это крайне особенный случай. Однако, многие списки строятся путем добавления элементов по одному за раз. Любой список с дырами, построенный таким образом, должен был иметь значения nil в своем конце во время построения.</p>
<p>Многие списки, которые мы используем в наших программах, являются последовательностями (например, строка файла не может быть nil), и поэтому большую часть времени применение операции длины безопасно. Если вам действительно нужно обрабатывать списки с дырами, то вы должны хранить их длину явным образом где-то еще.</p>
<h3 id="Chapter03.xhtml#sigil_toc_id_33">3.6. Приоритеты операций</h3>
<p>Приоритеты операций в Lua, от высшего к низшему, следуют этой таблице:</p>
<pre><code>^
not    #     - (унарный)
*      /     %
+      -
..
&lt;      &gt;      &lt;=      &gt;=      ~=      ==
and
or</code></pre>
<p>Все бинарные операции левоассоциативны, за исключением '<code>^</code>' (возведение в степень) и '<code>..</code>' (конкатенация), которые правоассоциативны. Поэтому следующие выражения слева эквивалентны выражениям справа:</p>
<pre><code>a+i &lt; b/2+1         &lt;--&gt;    (a+i) &lt; ((b/2)+1)
5+x^2*8             &lt;--&gt;    5+((x^2)*8)
a &lt; y and y &lt;= z    &lt;--&gt;    (a &lt; y) and (y &lt;= z)
-x^2                &lt;--&gt;    -(x^2)
x^y^z               &lt;--&gt;    x^(y^z)</code></pre>
<p>Когда сомневаетесь, всегда используйте круглые скобки. Это легче, чем заглядывать в справочник, так как при перечитывании кода у вас вновь могут возникнуть те же сомнения.</p>
<h3 id="Chapter03.xhtml#sigil_toc_id_34">Конструкторы таблиц</h3>
<p>Конструкторы — это выражения, которые создают и инициализируют таблицы. Они являются отличительной чертой Lua и одним из его наиболее полезных и универсальных механизмов.</p>
<p>Простейший конструктор — это пустой конструктор, <code>{}</code>, который создает пустую таблицу; мы уже видели его раньше. Конструкторы также инициализируют списки. Например, оператор</p>
<pre><code>days = {&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;}</code></pre>
<p>проинициализирует <code>days[1]</code> строкой &quot;<code>Sunday</code>&quot; (первый элемент конструктора имеет индекс 1, а не 0), <code>days[2]</code> строкой &quot;<code>Monday</code>&quot; и т. д.:</p>
<pre><code>print(days[4])    --&gt; Wednesday</code></pre>
<p>Lua также предлагает специальный синтаксис для инициализации таблиц, похожий на записи, как в следующем примере;</p>
<pre><code>a = {x=10, y=20}</code></pre>
<p>Эта строка эквивалентна следующим командам:</p>
<pre><code>a = {}; a.x=10; a.y=20</code></pre>
<p>Исходное выражение, тем не менее, проще и быстрее, поскольку Lua сразу создает таблицу с правильным размером.</p>
<p>Вне зависимости от того, каким конструктором мы пользовались для создания таблицы, из нее всегда можно добавлять и удалять поля:</p>
<pre><code>w = {x=0, y=0, label=&quot;console&quot;}
x = {math.sin(0), math.sin(1), math.sin(2)}
w[1] = &quot;another field&quot;    -- добавляет ключ 1 в таблицу &#39;w&#39;
x.f = w                   -- добавляет ключ &quot;f&quot; в таблицу &#39;x&#39;
print(w[&quot;x&quot;])             --&gt; 0
print(w[1])               --&gt; another field
print(x.f[1])             --&gt; another field
w.x = nil                 -- удаляет поле &quot;x&quot;</code></pre>
<p>Однако, как я только что заметил, создание таблицы при помощи правильного конструктора более эффективно и, кроме того, более наглядно.</p>
<p>Мы можем смешивать эти два стиля инициализации (записи и списки) в одном и том же конструкторе:</p>
<pre><code>polyline = {color=&quot;blue&quot;,
            thickness=2,
            npoints=4,
            {x=0, y=0},      -- polyline[1]
            {x=-10, y=0},    -- polyline[2]
            {x=-10, y=1},    -- polyline[3]
            {x=0, y=1}       -- polyline[4]
           }</code></pre>
<p>Приведенный выше пример также показывает, как можно вкладывать конструкторы один в другой для представления более сложных структур данных. Каждый из элементов <code>polyline[i]</code> — это таблица, представляющая собой запись:</p>
<pre><code>print(polyline[2].x)    --&gt; -10
print(polyline[4].y)    --&gt; 1</code></pre>
<p>У этих двух форм конструктора есть свои ограничения. Например, вы не можете инициализировать поля отрицательными индексами или строковыми индексами, которые не являются правильными идентификаторами. Для таких целей есть другой, более общий формат. В этом формате мы явно пишем индекс, который должен быть инициализирован как выражение, между квадратными скобками:</p>
<pre><code>opnames = {[&quot;+&quot;] = &quot;add&quot;, [&quot;-&quot;] = &quot;sub&quot;,
           [&quot;*&quot;] = &quot;mul&quot;, [&quot;/&quot;] = &quot;div&quot;}

i = 20; s = &quot;-&quot;
a = {[i+0] = s, [i+1] = s..s, [i+2] = s..s..s}

print(opnames[s])    --&gt; sub
print(a[22])         --&gt; ---</code></pre>
<p>Этот синтаксис хоть и более громоздкий, но при этом более гибкий: обе формы (в стиле списков и в стиле записей) являются частными случаями этого более общего синтаксиса. Конструктор <code>{x = 0, y = 0}</code> эквивалентен <code>{[&quot;x&quot;] = 0, [&quot;y&quot;] = 0}</code>, а конструктор <code>{&quot;r&quot;, &quot;g&quot;, &quot;b&quot;}</code> эквивалентен <code>{[1] = &quot;r&quot;, [2] = &quot;g&quot;, [3] = &quot;b&quot;}</code>.</p>
<p>Вы всегда можете поставить запятую после последней записи. Эти замыкающие запятые необязательны, но всегда допустимы:</p>
<pre><code>a = {[1]=&quot;red&quot;, [2]=&quot;green&quot;, [3]=&quot;blue&quot;,}</code></pre>
<p>Данная гибкость освобождает программы, генерирующие конструкторы Lua, от необходимости обрабатывать последний элемент особым образом.</p>
<p>Наконец, вы всегда можете использовать в конструкторе точку с запятой вместо запятой. Я обычно использую точки с запятой для отделения различных секций в конструкторе, например, для отделения части в виде списка от части в виде записей:</p>
<pre><code>{x=10, y=45; &quot;one&quot;, &quot;two&quot;, &quot;three&quot;}</code></pre>
<h3 id="Chapter03.xhtml#sigil_toc_id_35">Упражнения</h3>
<p><strong>Упражнение 3.1.</strong> Что напечатает следующая программа?</p>
<pre><code>for i = -10, 10 do
  print(i, i % 3)
end</code></pre>
<p><strong>Упражнение 3.2.</strong> Что является результатом выражения <code>2^3^4</code>? А что насчет <code>2^-3^4</code>?</p>
<p><strong>Упражнение 3.3.</strong> Мы можем представить многочлен <font size="3"><em>a<sub>n</sub>x<sup>n</sup> + a<sub>n−1</sub>x<sup>n−1</sup> + ... + a<sub>1</sub>x<sup>1</sup> + a<sub>0</sub></em> в</font> Lua как список его коэффициентов {<em>a0, a1, ..., an</em>}.</p>
<p>Напишите функцию, которая получает многочлен (представленный в виде таблицы) и значение <code>x</code>, а затем возвращает значение многочлена.</p>
<p><strong>Упражнение 3.4.</strong> Можете ли вы написать функцию из предыдущего упражнения так, чтобы использовать <em>n</em> сложений и <em>n</em> умножений (и не использовать возведение в степень)?</p>
<p><strong>Упражнение 3.5.</strong> Как вы можете проверить, что значение является булевым, не прибегая к функции <code>type</code>?</p>
<p><strong>Упражнение 3.6.</strong> Рассмотрим следующее выражение:</p>
<pre><code>(x and y and (not z)) or ((not y) and x)</code></pre>
<p>Нужны ли в этом выражении круглые скобки? Как бы вы посоветовали использовать их в данном выражении?</p>
<p><strong>Упражнение 3.7.</strong> Что напечатает следующий скрипт? Объясните.</p>
<pre><code>sunday = &quot;monday&quot;; monday = &quot;sunday&quot;
t = {sunday = &quot;monday&quot;, [sunday] = monday}
print(t.sunday, t[sunday], t[t.sunday])</code></pre>
<p><strong>Упражнение 3.8.</strong> Предположим, вы хотите создать таблицу, которая связывает каждую экранированную последовательность для строк (см. раздел 2.4) с ее значением. Как бы вы написали конструктор для такой таблицы?</p>
<p><span id="Chapter04.xhtml"></span></p>
<h2>ГЛАВА 4</h2>
<h2 id="Chapter04.xhtml#sigil_toc_id_36">Операторы</h2>
<p>Lua поддерживает почти традиционный набор операторов, похожих на операторы в С или Pascal. Традиционные операторы включают в себя присваивание, управляющие структуры и вызовы процедур. Lua также поддерживает менее распространенные операторы, такие как множественное присваивание и объявления локальных переменных.</p>
<h3 id="Chapter04.xhtml#sigil_toc_id_37">4.1. Операторы присваивания</h3>
<p>Присваивание — это базовое средство изменения значения переменной или поля таблицы:</p>
<pre><code>a = &quot;hello&quot; .. &quot;world&quot;
t.n = t.n + 1</code></pre>
<p>Lua позволяет осуществлять <em>множественное присваивание</em> <strong>(multiple assignment)</strong>, которое присваивает список значений списку переменных за один шаг. Например, в присваивании</p>
<pre><code>a, b = 10, 2*x</code></pre>
<p>переменная <code>a</code> получает значение <code>10</code>, а переменная <code>b</code> — значение <code>2*x</code>.</p>
<p>Во множественном присваивании Lua сперва вычисляет все значения и только затем выполняет присваивания. Поэтому мы можем использовать множественное присваивание, чтобы поменять местами два значения, как в следующих примерах:</p>
<pre><code>x, y = y, x                -- меняет местами значения &#39;x&#39; с &#39;y&#39;
a[i], a[j] = a[j], a[i]    -- меняет местами значения &#39;a[i]&#39; с &#39;a[j]&#39;</code></pre>
<p>Lua всегда приводит количество значений к количеству переменных: когда список значений короче списка переменных, дополнительные переменные получают в качестве своих значений nil; когда длиннее список значений, дополнительные значения просто отбрасываются:</p>
<pre><code>a, b, c = 0, 1
print(a, b, c)          --&gt; 0    1     nil
a, b = a+1, b+1, b+2    -- значение b+2 игнорируется
print(a, b)             --&gt; 1    2
a, b, c = 0
print(a, b, c)          --&gt; 0    nil   nil</code></pre>
<p>Последнее присваивание в примере выше показывает распространенную ошибку. Для инициализации набора переменных вы должны предоставить значение для каждой из них:</p>
<pre><code>a, b, c = 0, 0, 0
print(a, b, c)       --&gt; 0   0   0</code></pre>
<p>В действительности большинство предыдущих примеров в чем-то искусственно. Я редко использую множественное присваивание просто, чтобы записать несколько не связанных между собой присваиваний в одну строку. В частности, множественное присваивание не быстрее эквивалентных ему одиночных присваиваний. Тем не менее, зачастую нам действительно требуется множественное присваивание. Мы уже видели пример, меняющий местами значения у двух переменных. Более распространенное использование заключается в получении нескольких значений при вызове функции. Как мы подробно обсудим в разделе 5.1, вызов функции может возвращать несколько значений. В таких случаях единственное выражение может предоставить значения для нескольких переменных. Например, в присваивании <code>a,b=f()</code> вызов <code>f</code> возвращает два значения: <code>a</code> получает первое, а <code>b</code> получает второе.</p>
<h3 id="Chapter04.xhtml#sigil_toc_id_38">4.2. Локальные переменные и блоки</h3>
<p>Кроме глобальных, Lua поддерживает и локальные переменные. Мы создаем локальные переменные при помощи оператора <code>local</code>:</p>
<pre><code>j = 10          -- глобальная переменная
local i = 1     -- локальная переменная</code></pre>
<p>В отличие от глобальных переменных, область видимости локальной переменной ограничена блоком, где она была объявлена. <em>Блок</em> — это тело управляющей структуры, тело функции или кусок кода (файл или строка, где переменная была объявлена):</p>
<pre><code>x = 10
local i = 1         -- локальная для куска

while i &lt;= x do
  local x = i*2     -- локальная для тела while
  print(x)          --&gt; 2, 4, 6, 8, ...
  i = i + 1
end

if i &gt; 20 then
  local x           -- локальная для тела &quot;then&quot;
  x = 20
  print(x + 2)      -- (напечатает 22, если условие выполнится)
else
  print(x)          --&gt; 10 (глобальная переменная)
end

print(x)            --&gt; 10 (глобальная переменная)</code></pre>
<p>Обратите внимание, что этот пример не будет работать так, как вы ожидаете, если ввести его в интерактивном режиме. В интерактивном режиме каждая строка — это самостоятельный кусок (кроме случая, когда команда набрана не полностью). Как только вы введете вторую строку примера (<code>local i=1</code>), Lua выполнит ее и начнет новый кусок кода со следующей строки. К тому моменту локальное объявление уже выйдет из своей области видимости. Для решения этой проблемы мы можем явно ограничить весь этот блок, заключив его между ключевыми словами <strong>do</strong> и <strong>end</strong>. Как только вы введете <strong>do</strong>, команда закончится только на соответствующем ему <strong>end</strong>, поэтому Lua не будет пытаться выполнить каждую строку по отдельности.</p>
<p>Подобные блоки с <strong>do</strong> удобны и тогда, когда вам нужен более точный контроль над областью видимости некоторых локальных переменных:</p>
<pre><code>do
  local a2 = 2*a
  local d = (b^2 - 4*a*c)^(1/2)
  x1 = (-b + d)/a2
  x2 = (-b - d)/a2
end                -- область видимости &#39;a2&#39; и &#39;d&#39; заканчивается здесь
print(x1, x2)</code></pre>
<p>Хороший стиль программирования заключается в применении локальных переменных везде, где это возможно. Локальные переменные помогают вам избежать засорения глобального окружения ненужными именами. Более того, доступ к локальной переменной быстрее, чем к глобальной. И наконец, локальная переменная перестает существовать, как только заканчивается ее область видимости, позволяя сборщику мусора освободить память, занимаемую ее значением.</p>
<p>Lua обрабатывает объявления локальных переменных как операторы. Таким образом, вы можете записывать локальные объявления везде, где вы можете записать оператор. Область видимости объявленных переменных начинается сразу после объявления и длится до конца блока. Каждое объявление может включать инициализирующее присваивание, которое действует так же, как и традиционное присваивание: лишние значения отбрасываются, а лишние переменные получают значение nil. Если в объявлении нет инициализирующего присваивания, то оно инициализирует все свои переменные значением nil:</p>
<pre><code>local a, b = 1, 10
if a &lt; b then
  print(a)     --&gt; 1
  local a      -- неявное &#39;= nil&#39;
  print(a)     --&gt; nil
  end          -- завершает блок, начатый с &#39;then&#39;
print(a, b)    --&gt; 1    10</code></pre>
<p>В Lua распространена следующая идиома:</p>
<pre><code>local foo = foo</code></pre>
<p>Этот код создает локальную переменную <code>foo</code> и инициализирует ее значением глобальной переменной <code>foo</code>. (Локальная <code>foo</code> становится видимой только <em>после</em> этого объявления.) Эта идиома удобна, когда куску необходимо предварительно сохранить первоначальное значение переменной, даже если позже какая-нибудь другая функция изменит значение глобальной <code>foo</code>; это также ускоряет доступ к <code>foo</code>.</p>
<p>Поскольку многие языки вынуждают вас объявлять все локальные переменные в начале блока (или процедуры), некоторые считают, что объявлять переменные в середине блока является плохой практикой. Все как раз наоборот: объявляя переменную, только когда она действительно нужна, вам редко понадобится объявлять ее без инициализирующего значения (и поэтому вы вряд ли забудете ее проинициализироватъ). Более того, вы уменьшаете область видимости переменной, что облегчает чтение кода.</p>
<h3 id="Chapter04.xhtml#sigil_toc_id_39">4.3. Управляющие конструкции</h3>
<p>Lua предоставляет небольшой и традиционный набор управляющих структур: <strong>if</strong> для условного выполнения, а <strong>while</strong>, <strong>repeat</strong> и <strong>for</strong> для итерации. Все управляющие структуры обладают явным завершающим элементом: <strong>end</strong> завершает <strong>if</strong>, <strong>for</strong> и <strong>while</strong>, а <strong>until</strong> завершает <strong>repeat</strong>.</p>
<p>Условное выражение управляющей структуры может дать любое значение. Помните о том, что Lua считает все значения, отличные от false и nil, истинными. (В частности, Lua считает истинными ноль и пустую строку.)</p>
<h4 id="Chapter04.xhtml#sigil_toc_id_40">if then else</h4>
<p>Оператор <strong>if</strong> проверяет свое условие и в зависимости от результата выполняет одну из своих частей, <strong>then</strong> или <strong>else</strong>. Часть с <strong>else</strong> является необязательной.</p>
<pre><code>if a &lt; 0 then a = 0 end

if a &lt; b then return a else return b end

if line &gt; MAXLINES then
  showpage()
  line = 0
end</code></pre>
<p>Для записи вложенных операторов <strong>if</strong> вы можете использовать <strong>elseif</strong>. Это аналогично <strong>else</strong>, за которым следует <strong>if</strong>, но при этом не возникает необходимости в нескольких <strong>end</strong>:</p>
<pre><code>if op == &quot;+&quot; then
  r = a + b
elseif op == &quot;-&quot; then
  r = a - b
elseif op == &quot;*&quot; then
  r = a*b
elseif op == &quot;/&quot; then
  r = a/b
else
  error(&quot;invalid operation&quot;)
end</code></pre>
<p>Поскольку в Lua нет оператора switch, такие конструкции довольно распространены.</p>
<h4 id="Chapter04.xhtml#sigil_toc_id_41">while</h4>
<p>Как следует из названия, <strong>while</strong> повторяет свое тело до тех пор, <em>пока</em> условие истинно. Как обычно, Lua сперва проверяет условие <strong>while</strong>; если оно ложно, то цикл завершается; в противном случае Lua выполняет тело цикла и повторяет данный процесс.</p>
<pre><code>local i = 1
while a[i] do
  print(a[i])
  i = i + 1
end</code></pre>
<h4 id="Chapter04.xhtml#sigil_toc_id_42">repeat</h4>
<p>Как следует из названия, оператор <strong>repeat</strong>–<strong>until</strong> <em>повторяет</em> свое тело до тех пор, <em>пока</em> условие <em>не</em> станет истинным. Данный оператор производит проверку условия после выполнения тела, поэтому тело цикла будет выполнено хотя бы один раз.</p>
<pre><code>-- печатает первую непустую введенную строку
repeat
  line = io.read()
until line ~= &quot;&quot;
print(line)</code></pre>
<p>В отличие от многих других языков, в Lua условие входит в область видимости локальной переменной, объявленной внутри цикла:</p>
<pre><code>local sqr = x/2
repeat
  sqr = (sqr + x/sqr)/2
  local error = math.abs(sqr^2 - x)
until error &lt; x/10000 -- local &#39;error&#39; still visible here</code></pre>
<h4 id="Chapter04.xhtml#sigil_toc_id_43">Числовой for</h4>
<p>Оператор <strong>for</strong> существует в двух вариантах: <em>числовой</em> <strong>for</strong> и <em>общий</em> <strong>for</strong>.</p>
<p>Числовой <strong>for</strong> имеет следующий синтаксис:</p>
<pre><code>for var = exp1, exp2, exp3 do
  &lt;что-либо&gt;
end</code></pre>
<p>Этот цикл будет выполнять <em>что-либо</em> для каждого значения <code>var</code> от <code>exp1</code> до <code>ехр2</code>, используя <code>ехр3</code> как <em>шаг</em> для увеличения <code>var</code>. Это третье выражение необязательно; когда оно отсутствует, Lua считает значение шага равным 1. В качестве типичных примеров можно привести</p>
<pre><code>for i = 1, f(x) do print(i) end

for i = 10, 1, -1 do print(i) end</code></pre>
<p>Если вам нужен цикл без верхнего предела, то вы можете использовать константу <code>math.huge</code>:</p>
<pre><code>for i = 1, math.huge do
  if (0.3*i^3 - 20*i^2 - 500 &gt;= 0) then
    print(i)
    break
  end
end</code></pre>
<p>У цикла <strong>for</strong> есть некоторые тонкости, которые вам желательно знать, чтобы применять его наиболее эффективно. Во-первых, все три выражения вычисляются только один раз, перед началом цикла. Скажем, в нашем первом примере Lua вызовет <code>f(х)</code> всего один раз. Во-вторых, управляющая переменная является локальной переменной, автоматически объявляемой оператором <strong>for</strong>, и она видна лишь внутри цикла. Типичная ошибка — полагать, что эта переменная все еще существует после окончания цикла:</p>
<pre><code>for i = 1, 10 do print(i) end
max = i       -- вероятно, неправильно! здесь &#39;i&#39; глобальная</code></pre>
<p>Если вам нужно значение управляющей переменной после цикла (обычно когда вы прерываете цикл), то вы должны сохранить ее значение в другой переменной:</p>
<pre><code>-- находит значение в списке
local found = nil
for i = 1, #a do
  if a[i] &lt; 0 then
    found = i          -- сохраняет значение &#39;i&#39;
    break
  end
end
print(found)</code></pre>
<p>В-третьих, вы никогда не должны изменять значение управляющей переменной: эффект подобных изменений не предсказуем. Если вы хотите закончить цикл <strong>for</strong> до его нормального завершения, используйте <strong>break</strong> (как в предыдущем примере).</p>
<h4 id="Chapter04.xhtml#sigil_toc_id_44">Общий for</h4>
<p>Общий <strong>for</strong> обходит все значения, возвращаемые итерирующей функцией:</p>
<pre><code>-- печатает все значения таблицы &#39;t&#39;
for k, v in pairs(t) do print(k, v) end</code></pre>
<p>Этот пример использует <code>pairs</code>, удобную итерирующую функцию для перебора таблицы, предоставляемую базовой библиотекой Lua. На каждом шаге этого цикла <code>k</code> получает ключ, a <code>v</code> получает значение, связанное с этим ключом.</p>
<p>Несмотря на свою кажущуюся простоту, общий <strong>for</strong> обладает широкими возможностями. С подходящими итераторами вы можете в легкочитаемой форме перебрать практически все, что угодно. Стандартные библиотеки предоставляют несколько итераторов, позволяющих нам перебирать строки файла (<code>io.lines</code>), пары таблицы (<code>pairs</code>), элементы последовательности (<code>ipars</code>), слова внутри строки (<code>string.gmatch</code>) и т.д.</p>
<p>Конечно, мы можем написать и наши собственные итераторы. Хотя использовать общий <strong>for</strong> легко, у задачи написания итерирующих функций есть свои нюансы, поэтому мы рассмотрим эту тему позже, в главе 7.</p>
<p>У общего и числового циклов есть два одинаковых свойства: переменные цикла локальны для тела цикла, и вы никогда не должны присваивать им какие-либо значения.</p>
<p>Рассмотрим более конкретный пример применения общего <strong>for</strong>. Допустим, у вас есть таблица с названиями дней недели:</p>
<pre><code>days = {&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;,
        &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;}</code></pre>
<p>Теперь вы хотите перевести название дня в его номер по счету в неделе. Вы можете искать заданное имя в таблице. Однако, как вы скоро узнаете, в Lua поиск применяется редко. Более эффективным подходом является построение обратной таблицы, скажем, <code>revDays</code>, в которой названия дней используются как индексы, а номера используются как значения. Эта таблица выглядела бы следующим образом:</p>
<pre><code>revDays = {[&quot;Sunday&quot;]   = 1, [&quot;Monday&quot;]    = 2,
           [&quot;Tuesday&quot;]  = 3, [&quot;Wednesday&quot;] = 4,
           [&quot;Thursday&quot;] = 5, [&quot;Friday&quot;]    = 6,
           [&quot;Saturday&quot;] = 7}</code></pre>
<p>Тогда все, что вам нужно, чтобы найти номер дня по названию, — это обратиться по индексу этой обратной таблицы:</p>
<pre><code>x = &quot;Tuesday&quot;
print(revDays[x])    --&gt; 3</code></pre>
<p>Разумеется, нам не требуется объявлять эту обратную таблицу вручную. Мы можем автоматически построить ее из первоначальной:</p>
<pre><code>revDays = {}
for k,v in pairs(days) do
  revDays[v] = k
end</code></pre>
<p>Этот цикл выполнит присваивание для каждого элемента <code>days</code>, где переменная <code>k</code> получит ключ (<code>1, 2, ...</code>), a <code>v</code> получит значение (&quot;<code>Sunday&quot;, &quot;Monday&quot;, ...</code>).</p>
<h3 id="Chapter04.xhtml#sigil_toc_id_45">4.4. break, return и goto</h3>
<p>Операторы <strong>break</strong> и <strong>return</strong> позволяют нам выпрыгнуть <strong>(осуществить безусловный переход)</strong> из блока. Оператор <strong>goto</strong> позволяет нам прыгнуть практически в любую точку функции.</p>
<p>Мы используем оператор <strong>break</strong> для завершения цикла. Этот оператор прерывает внутренний цикл (<strong>for</strong>, <strong>repeat</strong> или <strong>while</strong>), который его содержит; он не может быть использован за пределами цикла. После прерывания программа продолжит выполнение с точки, следующей сразу после прерванного цикла.</p>
<p>Оператор <strong>return</strong> возвращает результаты из функции, если они есть, или просто завершает ее. В конце каждой функции присутствует неявный возврат из нее, поэтому вам необязательно его использовать, если ваша функция завершается естественным образом, не возвращая никакого значения.</p>
<p>Из синтаксических соображений оператор <strong>return</strong> может быть только последним оператором блока: другими словами, либо последним оператором в вашем куске, либо прямо перед <strong>end</strong>, <strong>else</strong> или <strong>until</strong>. В следующем примере <strong>return</strong> — это последний оператор блока <strong>then</strong>.</p>
<pre><code>local i = 1
while a[i] do
  if a[i] == v then return i end
  i = i + 1
end</code></pre>
<p>Обычно это именно те места, где мы используем <strong>return</strong>, поскольку любые другие операторы, следующие за ним, были бы недоступны. Иногда, тем не менее, удобно писать <strong>return</strong> в середине блока; например, вы можете отлаживать функцию и хотите избежать ее выполнения. В подобных случаях вы можете использовать явный блок <strong>do</strong> вокруг оператора <strong>return</strong>:</p>
<pre><code>function foo ()
  return                 --&lt;&lt; СИНТАКСИЧЕСКАЯ ОШИБКА
  -- &#39;return&#39; является последним оператором в следующем куске
  do return end          -- OK
  &lt;другие операторы&gt;
end</code></pre>
<p>Оператор <strong>goto</strong> передает выполнение программы соответствующей метке. Насчет <strong>goto</strong> были долгие обсуждения, и некоторые люди даже сейчас считают, что эти операторы вредны для языков программирования и должны быть из них исключены. Однако, ряд существующих языков предлагает <strong>goto</strong> совершенно обоснованно. Данные операторы являются мощным механизмом, который, будучи использованным с осторожностью, способен лишь улучшить качество вашего кода.</p>
<p>В Lua синтаксис для оператора <strong>goto</strong> вполне традиционный: это зарезервированное слово <strong>goto</strong>, за которым следует имя метки, которое может быть любым допустимым идентификатором. Синтаксис для метки немного более запутанный: два двоеточия, за которыми следует имя метки, после которого идут еще два двоеточия, например, как в <code>::name::</code>. Эта сложность намеренная, чтобы заставить программиста дважды подумать, прежде чем использовать <strong>goto</strong>.</p>
<p>Lua накладывает некоторые ограничения на то, куда вы можете прыгнуть при помощи <strong>goto</strong>. Во-первых, метки следуют обычным правилам видимости, поэтому вы не можете прыгнуть внутрь блока (поскольку метка внутри блока невидима за его пределами). Во-вторых, вы не можете выпрыгнуть из функции. (Обратите внимание, что первое правило уже исключает возможность прыгнуть внутрь функции.) В-третьих, вы не можете прыгнуть внутрь области видимости локальной переменной.</p>
<p>Типичным и хорошо зарекомендовавшим себя применением <strong>goto</strong> является моделирование некоторой конструкции, которую вы узнали из другого языка, но которая отсутствует в Lua, например continue, многоуровневые break, redo и т. п. Оператор continue — это просто безусловный переход к метке в конце блока цикла; оператор redo осуществляет переход к началу блока:</p>
<pre><code>while some_condition do
  ::redo::
  if some_other_condition then goto continue
  else if yet_another_condition then goto redo
  end
  &lt;какой-нибудь код&gt;
  ::continue::
end</code></pre>
<p>Полезной деталью в спецификации Lua является то, что область видимости локальной переменной заканчивается на первом <em>непустом</em> операторе блока, в котором эта переменная определена; метки считаются пустыми операторами. Чтобы увидеть полезность данной детали, рассмотрим следующий фрагмент кода:</p>
<pre><code>while some_condition do
  if some_other_condition then goto continue end
  local var = something
  &lt;какой-нибудь код&gt;
  ::continue::
end</code></pre>
<p>Вы можете подумать, что этот <strong>goto</strong> перепрыгивает в область видимости переменной <code>var</code>. Однако, метка <code>continue</code> находится после последнего непустого оператора блока, и поэтому не в области видимости переменной <code>var</code>.</p>
<p>Оператор <strong>goto</strong> также полезен при написании конечных автоматов (машин состояний). В качестве примера листинг 4.1 показывает программу, проверяющую, содержит ли ее ввод четное количество нулей. Существуют лучшие способы написания этой специфической программы, но данный подход удобен, если вы хотите автоматически перевести конечный автомат в код Lua (подумайте о динамической генерации кода).</p>
<p><strong>Листинг 4.1.</strong> Пример конечного автомата с использованием <span class="code">goto</span></p>
<pre><code>::s1:: do
  local c = io.read(1)
  if c == &#39;0&#39; then goto s2
  elseif c == nil then print&#39;ok&#39;; return
  else goto s1
  end
end

::s2:: do
  local c = io.read(1)
  if c == &#39;0&#39; then goto s1
  elseif c == nil then print&#39;not ok&#39;; return
  else goto s2
  end
end

goto s1</code></pre>
<p>В качестве другого примера рассмотрим простую игру в лабиринт. Лабиринт содержит несколько комнат, в каждой до четырех дверей: север, юг, восток и запад. На каждом шаге пользователь вводит направление движения. Если в этом направлении есть дверь, то пользователь переходит в соответствующую комнату; иначе программа печатает предупреждение. Целью является дойти от начальной комнаты до конечной.</p>
<p>Эта игра является типичной машиной состояний, где текущая комната является состоянием. Мы можем реализовать этот лабиринт, используя один блок для каждой комнаты и оператор <strong>goto</strong> для перехода из одной комнаты в другую. Листинг 4.2 показывает, как можно написать небольшой лабиринт с четыремя комнатами.</p>
<p>Для этой простой игры вы можете решить, что программа, управляемая данными, в которой вы описываете комнаты и перемещения при помощи таблиц, является более удачным решением. Однако, если в игре для каждой комнаты предусмотрены особые ситуации, то этот подход на основе конечного автомата является вполне уместным.</p>
<p><strong>Листинг 4.2.</strong> Игра «лабиринт»</p>
<pre><code>goto room1 -- начальная комната

::room1:: do
  local move = io.read()
  if move == &quot;south&quot; then goto room3
  elseif move == &quot;east&quot; then goto room2
  else
    print(&quot;invalid move&quot;)
    goto room1 -- остаемся в этой же комнате
  end
end

::room2:: do
  local move = io.read()
  if move == &quot;south&quot; then goto room4
  elseif move == &quot;west&quot; then goto room1
  else
    print(&quot;invalid move&quot;)
    goto room2
  end
end

::room3:: do
  local move = io.read()
  if move == &quot;north&quot; then goto room1
  elseif move == &quot;east&quot; then goto room4
  else
    print(&quot;invalid move&quot;)
    goto room3
  end
end

::room4:: do
  print(&quot;Congratulations, you won!&quot;)
end</code></pre>
<h3 id="Chapter04.xhtml#sigil_toc_id_46">Упражнения</h3>
<p><strong>Упражнение 4.1.</strong> Большинство языков с С-образным синтаксисом не предлагает конструкцию <strong>elseif</strong>. Почему эта конструкция больше нужна в Lua, чем в тех языках?</p>
<p><strong>Упражнение 4.2.</strong> Опишите четыре различных способа написать безусловный цикл в Lua. Какой способ предпочитаете вы?</p>
<p><strong>Упражнение 4.3.</strong> Многие считают, что <strong>repeat</strong>—<strong>until</strong> используется редко и потому не должен присутствовать в минималистических языках вроде Lua. Чты вы думаете об этом?</p>
<p><strong>Упражнение 4.4.</strong> Перепишите конечный автомат из листинга 4.2 без использования <strong>goto</strong>.</p>
<p><strong>Упражнение 4.5</strong>. Можете ли вы объяснить, почему в Lua присутствует ограничение на то, что <strong>goto</strong> не может выпрыгнуть из функции? (Подсказка: как бы вы реализовали данную возможность?)</p>
<p><strong>Упражнение 4.6.</strong> Допустив, что <strong>goto</strong> может выпрыгнуть из функции, объясните, что делала бы программа в листинге 4.3. (Попытайтесь рассуждать о метке при помощи тех же правил области видимости, что используются для локальных переменных.)</p>
<p><strong>Листинг 4.3.</strong> Странное (и недопустимое) использование <span class="code">goto</span></p>
<pre><code>function getlabel ()
  return function () goto L1 end
  ::L1::
  return 0
end

function f (n)
  if n == 0 then return getlabel()
  else
    local res = f(n - 1)
    print(n)
    return res
  end
end

x = f(10)
x()</code></pre>
<p><span id="Chapter05.xhtml"></span></p>
<h2>ГЛАВА 5</h2>
<h2 id="Chapter05.xhtml#sigil_toc_id_47">Функции</h2>
<p>Функции являются основным механизмом абстракции операторов и выражений в Lua. Функции могут выполнять определенное задание (иногда называемое <em>процедурой</em> или <em>подпрограммой</em> в других языках) или вычислять и возвращать значения. В первом случае мы используем вызов функции как оператор; во втором случае мы используем его как выражение:</p>
<pre><code>print(8*9, 9/8)
a = math.sin(3) + math.cos(10)
print(os.date())</code></pre>
<p>В обоих случаях заключение списка аргументов в круглые скобки обозначает вызов; если у вызова функции нет аргументов, то мы все равно должны написать пустой список <code>()</code> для обозначения вызова. Существует особое исключение из этого правила: если у функции всего один аргумент и этот аргумент либо строковый литерал, либо конструктор таблицы, то круглые скобки необязательны:</p>
<pre><code>print &quot;Hello World&quot;     &lt;--&gt;    print(&quot;Hello World&quot;)
dofile &#39;a.lua&#39;          &lt;--&gt;    dofile (&#39;a.lua&#39;)
print [[a multi-line    &lt;--&gt;    print([[a multi-line
 message]]              &lt;--&gt;     message]])
f{x=10, y=20}           &lt;--&gt;    f({x=10, y=20})
type{}                  &lt;--&gt;    type({})</code></pre>
<p>Lua также предлагает специальный синтаксис для объектно-ориентированных вызовов — операцию двоеточия. Выражение вроде <code>о:foo(x)</code> — это всего лишь другой способ написать <code>o.foo(o,x)</code>, то есть вызвать <code>o.foo</code>, добавляя <code>o</code> в качестве первого дополнительного аргумента. В главе 16 мы обсудим подобные вызовы (и объектно-ориентированное программирование) более подробно.</p>
<p>Программа Lua может использовать функции, написанные как на Lua, так и на С (или любом другом языке, который используется основным приложением). Например, все функции из стандартной библиотеки Lua написаны на С. Тем не менее, при вызове нет никакой разницы между функциями, определенными в Lua, и функциями, определенными в С.</p>
<p>Как мы видели в других примерах, определение функции следует традиционному синтаксису, например, как показано ниже:</p>
<pre><code>-- складывает элементы последовательности &#39;a&#39;
function add (a)
  local sum = 0
  for i = 1, #a do
    sum = sum + a[i]
  end
  return sum
end</code></pre>
<p>В этом синтаксисе определение функции содержит <em>имя</em> (в примере это <code>add</code>), список <em>параметров</em> и <em>тело</em>, которое является списком операторов.</p>
<p>Параметры работают в точности как локальные переменные, проинициализированные значениями аргументов, которые были переданы вызову функции. Вы можете вызвать функцию с числом аргументов, отличным от ее числа параметров. Lua приведет число аргументов к числу параметров так же, как и при множественном присваивании: лишние аргументы отбрасываются, лишние параметры получают nil. Например, рассмотрим следующую функцию:</p>
<pre><code>function f (a, b) print(a, b) end</code></pre>
<p>Она обладает следующим поведением:</p>
<pre><code>f(3)          --&gt; 3    nil
f(3, 4)       --&gt; 3    4
f(3, 4, 5)    --&gt; 3    4    (5 отбрасывается)</code></pre>
<p>Хотя подобное поведение может привести к ошибкам программирования (легко обнаруживаемым во время выполнения), оно довольно удобно, особенно для аргументов по умолчанию. Например, рассмотрим следующую функцию, инкрементирующую глобальный счетчик:</p>
<pre><code>function incCount (n)
  n = n or 1
  count = count + n
end</code></pre>
<p>У этой функции 1 служит в качестве аргумента по умолчанию; т.е. вызов <code>incCount()</code> без аргументов увеличит <code>count</code> на единицу. Когда вы вызываете <code>incCount()</code>, Lua сперва инициализирует <code>n</code> значением nil; выражение с <code>or</code> возвращает свой второй операнд, и в результате Lua присваивает переменной <code>n</code> стандартное значение 1.</p>
<h3 id="Chapter05.xhtml#sigil_toc_id_48">5.1. Множественные результаты</h3>
<p>Нетрадиционной, но довольно удобной особенностью Lua является то, что функции могут возвращать несколько значений. Так делают некоторые предопределенные функции в Lua. Примером является функция <code>string.find</code>, которая находит местоположение образца в строке. Эта функция возвращает два индекса, когда находит образец: индекс символа, с которого начинается образец, и индекс символа, на котором он заканчивается. Множественное присваивание позволяет программе получить оба результата:</p>
<pre><code>s, e = string.find(&quot;hello Lua users&quot;, &quot;Lua&quot;)
print(s, e)    --&gt; 7    9</code></pre>
<p>(Обратите внимание, что индекс первого символа строки равен 1.)</p>
<p>Функции, которые мы пишем в Lua, также могут возвращать множественные результаты при помощи перечисления их после ключевого слова <strong>return</strong>. Например, функция для нахождения максимального элемента в последовательности может возвращать и максимальный элемент, и его местонахождение:</p>
<pre><code>function maximum (a)
  local mi = 1            -- индекс максимального значения
  local m = a[mi]         -- максимальное значение
  for i = 1, #a do
    if a[i] &gt; m then
      mi = i; m = a[i]
    end
  end
  return m, mi
end

print(maximum({8,10,23,12,5}))    --&gt; 23    3</code></pre>
<p>Lua всегда приводит количество результатов функции к обстоятельствам ее вызова. Когда мы вызываем функцию как оператор, Lua отбрасывает все результаты функции. Когда мы используем вызов как выражение, Lua оставляет только первый результат. Мы получаем все результаты лишь тогда, когда вызов является последним (или единственным) выражением в списке выражений. В Lua эти списки встречаются в четырех конструкциях: множественные присваивания, аргументы в вызовах функций, конструкторы таблиц и операторы <strong>return</strong>. Для иллюстрации всех этих случаев допустим, что у нас есть такие определения для наших последующих примеров:</p>
<pre><code>function foo0() end                    -- возвращает 0 значений
function foo1() return &quot;a&quot; end         -- возвращает 1 значение
function foo2() return &quot;a&quot;, &quot;b&quot; end    -- возвращает 2 значения</code></pre>
<p>При множественном присваивании вызов функции в качестве последнего (или единственного) выражения произведет столько результатов, сколько у нас переменных:</p>
<pre><code>x,y = foo2()         -- x=&quot;a&quot;, y=&quot;b&quot;
x = foo2()           -- x=&quot;a&quot;, &quot;b&quot; отбрасывается
x,y,z = 10,foo2()    -- x=10, y=&quot;a&quot;, z=&quot;b&quot;</code></pre>
<p>Если функция не возвращает значения или возвращает их меньше, чем нужно, то Lua произведет в качестве недостающих значений nil:</p>
<pre><code>x,y = foo0()      -- x=nil, y=nil
x,y = foo1()      -- x=&quot;a&quot;, y=nil
x,y,z = foo2()    -- x=&quot;a&quot;, y=&quot;b&quot;, z=nil</code></pre>
<p>Вызов функции, который не является последним элементом в списке, всегда дает ровно один результат:</p>
<pre><code>x,y = foo2(), 20        -- x=&quot;a&quot;, y=20
x,y = foo0(), 20, 30    -- x=nil, y=20, 30 отбрасывается</code></pre>
<p>Когда вызов функции является последним (или единственным) аргументом другого вызова, то все результаты первого вызова передаются как аргументы для второго. Мы уже видели примеры этой конструкции с функцией <code>print</code>. Поскольку функция <code>print</code> может получать переменное число аргументов, оператор <code>print (g())</code> печатает все результаты, возвращенные функцией <code>g</code>.</p>
<pre><code>print(foo0())           --&gt;
print(foo1())           --&gt; a
print(foo2())           --&gt; a     b
print(foo2(), 1)        --&gt; a     1
print(foo2() .. &quot;x&quot;)    --&gt; ax    (смотрите далее)</code></pre>
<p>Когда вызов функции <code>foo2</code> происходит внутри выражения, Lua приводит число результатов к одному; поэтому в последней строке конкатенация использует только &quot;<code>а</code>&quot;.</p>
<p>Если мы напишем <code>f(g(х))</code>, где у <code>f</code> фиксированное число аргументов, то Lua приведет число результатов <code>g</code> к числу параметров <code>f</code>, как мы уже видели ранее.</p>
<p>Конструктор таблицы тоже собирает все результаты вызова, без каких-либо изменений:</p>
<pre><code>t = {foo0()}          -- t = {} (пустая таблица)
t = {foo1()}          -- t = {&quot;a&quot;}
t = {foo2()}          -- t = {&quot;a&quot;, &quot;b&quot;}</code></pre>
<p>Как обычно, это поведение встречается лишь тогда, когда вызов является последним выражением в списке; вызовы в любых других местах дают ровно один результат:</p>
<pre><code>t = {foo0(), foo2(), 4}    -- t[1] = nil, t[2] = &quot;a&quot;, t[3] = 4</code></pre>
<p>Наконец, оператор наподобие <code>return f()</code> возвращает все значения, возвращаемые <code>f</code>:</p>
<pre><code>function foo (i)
  if i == 0 then return foo0()
  elseif i == 1 then return foo1()
  elseif i == 2 then return foo2()
  end
end

print(foo(1))    --&gt; a
print(foo(2))    --&gt; a b
print(foo(0))    -- (без результатов)
print(foo(3))    -- (без результатов)</code></pre>
<p>Вы можете заставить вызов вернуть ровно один результат, заключив его в дополнительную пару круглых скобок:</p>
<pre><code>print((foo0()))    --&gt; nil
print((foo1()))    --&gt; a
print((foo2()))    --&gt; a</code></pre>
<p>Будьте внимательны, так как оператор <strong>return</strong> не требует скобок вокруг возвращаемого значения; любая пара круглых скобок, помещенная там, считается дополнительной. Поэтому оператор вроде <code>return(f(х))</code> всегда возвращает ровно одно значение, вне зависимости от того, сколько значений возвращает функция <code>f</code>. Иногда это именно то, что вам нужно, иногда нет.</p>
<p>Специальной функцией, возвращающей несколько значений, является <code>table.unpack</code>. Она получает массив и возвращает в качестве результатов все элементы этого массива, начиная с индекса 1:</p>
<pre><code>print(table.unpack{10,20,30})    --&gt; 10 20 30
a,b = table.unpack{10,20,30}     -- a=10, b=20, 30 отбрасывается</code></pre>
<p>Одна из важных областей применения <code>unpack</code> — механизм общего вызова. Механизм общего вызова позволяет вам динамически вызвать любую функцию с любыми аргументами. В ANSI С, например, нет способа написать код общего вызова. Вы можете объявить функцию, которая получает переменное число аргументов (при помощи <code>stdarg.h</code>), и вы можете вызвать функцию с несколькими переменными, используя указатели на функции. Однако, вы не можете вызвать функцию с переменным числом аргументов: у каждого вызова, который вы пишете на С, есть фиксированное число аргументов, а каждый аргумент обладает фиксированным типом. В Lua, если вы хотите вызвать функцию <code>f</code> с переменным числом аргументов, хранящимся в массиве <code>а</code>, вы просто пишите так:</p>
<pre><code>f(table.unpack(a))</code></pre>
<p>Вызов <code>unpack</code> возвращает все значения из <code>а</code>, которые становятся аргументами вызова <code>f</code>. Например, рассмотрим следующий вызов:</p>
<pre><code>print(string.find(&quot;hello&quot;, &quot;ll&quot;))</code></pre>
<p>Вы можете динамически построить эквивалентный вызов при помощи следующего кода:</p>
<pre><code>f = string.find
a = {&quot;hello&quot;, &quot;ll&quot;}

print(f(table.unpack(a)))</code></pre>
<p>Обычно <code>unpack</code> использует операцию длины, чтобы узнать, сколько элементов следует вернуть, поэтому она работает только с правильными последовательностями. При необходимости вы можете задать для нее явные границы:</p>
<pre><code>print(table.unpack({&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;}, 2, 3))
  --&gt; Mon    Tue</code></pre>
<p>Хотя предопределенная функция <code>unpack</code> написана на С, мы могли бы написать ее на Lua, используя рекурсию:</p>
<pre><code>function unpack (t, i, n)
  i = i or 1
  n = n or #t
  if i &lt;= n then
    return t[i], unpack(t, i + 1, n)
  end
end</code></pre>
<p>Первый раз, когда мы вызываем ее с единственным аргументом, <code>i</code> получает 1, а <code>n</code> получает длину последовательности. Затем функция возвращает <code>t[1]</code> вместе со всеми результатами <code>unpack(t,2,n)</code>, что, в свою очередь, возвращает <code>t[2]</code> со всеми результаты <code>unpack(t,3,n)</code> и т. д., останавливаясь после <code>n</code> элементов.</p>
<h3 id="Chapter05.xhtml#sigil_toc_id_49">5.2. Вариадические функции</h3>
<p>Функция в Lua может быть вариадической <strong>(variadic)</strong>, т.е. иметь переменное число аргументов. Например, мы уже вызывали <code>print</code> с одним, с двумя и более чем с двумя аргументами. Хотя <code>print</code> определена в С, мы можем определять вариадические функции и в Lua.</p>
<p>В качестве простого примера следующая функция возвращает сумму всех своих аргументов:</p>
<pre><code>function add (...)
  local s = 0
  for i, v in ipairs{...} do
    s = s + v
  end
  return s
end

print(add(3, 4, 10, 25, 12))    --&gt; 54</code></pre>
<p>Три точки (<code>...</code>) в списке параметров указывают на то, что эта функция является вариадической. При вызове этой функции Lua внутренним образом собирает все ее аргументы; мы называем эти собранные аргументы <em>дополнительными аргументами</em> функции. Функция может получать доступ к своим дополнительным аргументам опять же при помощи трех точек, теперь уже в качестве выражения. В нашем примере выражение <code>{...}</code> производит массив со всеми собранными аргументами. Затем функция обходит массив для сложения его элементов.</p>
<p>Мы называем выражение с <code>...</code> <em>выражением с переменным числом аргументов</em> <strong>(vararg expression)</strong>. Оно ведет себя как функция с возвратом нескольких значений, возвращая все дополнительные аргументы текущей функции. Например, команда <code>print(...)</code> напечатает все дополнительные аргументы текущей функции. Аналогично, следующая команда создаст две локальные переменные со значениями первых двух необязательных аргументов (или nil, если таких аргументов нет).</p>
<pre><code>local a, b = ...</code></pre>
<p>На самом деле мы можем имитировать стандартный механизм передачи параметров в Lua, переводя</p>
<pre><code>function foo (a, b, c)</code></pre>
<p>в</p>
<pre><code>function foo (...)
local a, b, c = ...</code></pre>
<p>Тем, кому нравится изящный механизм передачи параметров в Perl, может понравиться эта вторая форма.</p>
<p>Функция, наподобие следующей, просто возвращает все свои аргументы при вызове:</p>
<pre><code>function id (...) return ... end</code></pre>
<p>Это многозначная функция тождества. Следующая функция ведет себя так же, как и другая функция <code>foo</code>, за исключением того, что перед вызовом она печатает сообщение со своими аргументами:</p>
<pre><code>function foo1 (...)
  print(&quot;calling foo:&quot;, ...)
  return foo(...)
end</code></pre>
<p>Это полезный трюк для отслеживания вызовов конкретной функции.</p>
<p>Давайте рассмотрим еще один полезный пример. Lua предоставляет отдельные функции для форматирования текста (<code>string.format</code>) и его записи (<code>io.write</code>). Несложно объединить обе функции в одну вариадическую:</p>
<pre><code>function fwrite (fmt, ...)
  return io.write(string.format(fmt, ...))
end</code></pre>
<p>Обратите внимание на присутствие фиксированного параметра <code>fmt</code> перед точками. Вариадические функции могут иметь любое количество фиксированных параметров перед своей вариадической частью. Lua присваивает этим параметрам первые аргументы; остальные (если есть) идут как дополнительные параметры. Ниже мы покажем несколько примеров вызовов и значения соответствующих параметров:</p>
<pre><code>ВЫЗОВ                   ПАРАМЕТРЫ

fwrite()                fmt = nil, без дополнительных аргументов
fwrite(&quot;a&quot;)             fmt = &quot;a&quot;, без дополнительных аргументов
fwrite(&quot;%d%d&quot;, 4, 5)    fmt = &quot;%d%d&quot;, доп. аргументы = 4 и 5</code></pre>
<p>(Обратите внимание, что вызов <code>fwrite()</code> приведет к ошибке, поскольку <code>string.format</code> требует строку в качестве своего первого аргумента.)</p>
<p>Для обхода своих дополнительных аргументов функция может использовать выражение <code>{...}</code>, чтобы собрать их всех в таблицу, как мы это сделали в нашем определении <code>add</code>.</p>
<p>Однако, в тех редких случаях, когда дополнительные аргументы могут быть допустимыми nil, таблица, созданная при помощи <code>{...}</code>, может не быть правильной последовательностью. Например, для такой таблицы не существует способа узнать, были ли конечные nil в исходных аргументах. Для этих случаев Lua предлагает функцию <code>table.pack</code> (<span class="underline">Примечание</span>: Эта функция появилась только в Lua 5.2). Эта функция получает произвольное число аргументов и возвращает новую таблицу со всеми своими аргументами, как и <code>{...}</code>, но в этой таблице будет дополнительное поле '<code>n</code>', содержащее полное число ее аргументов. Следующая функция использует <code>table.pack</code>, чтобы проверить, что среди ее аргументов нет nil:</p>
<pre><code>function nonils (...)
  local arg = table.pack(...)
  for i = 1, arg.n do
    if arg[i] == nil then return false end
  end
  return true
end

print(nonils(2,3,nil))     --&gt; false
print(nonils(2,3))         --&gt; true
print(nonils())            --&gt; true
print(nonils(nil))         --&gt; false</code></pre>
<p>Однако, не забывайте, что <code>{...}</code> быстрее и понятнее, чем <code>table.pack(...)</code>, когда среди дополнительных аргументов не может быть nil.</p>
<h3 id="Chapter05.xhtml#sigil_toc_id_50">5.3. Именованные аргументы</h3>
<p>Механизм передачи параметров в Lua является <em>позиционным</em>: при вызове функции аргументы сопоставляются с параметрами соответственно их позициям. Первый аргумент дает значение первому параметру и т. д. Тем не менее, иногда удобно задавать аргументы по имени. Чтобы проиллюстрировать данный момент, давайте рассмотрим функцию <code>os.rename</code> (из библиотеки <code>os</code>), которая переименовывает файл. Довольно часто мы забываем, какое имя идет первым, новое или старое; поэтому мы можем захотеть переопределить эту функцию так, чтобы она получала два именованных аргумента:</p>
<pre><code>-- недопустимый код
rename(old=&quot;temp.lua&quot;, new=&quot;temp1.lua&quot;)</code></pre>
<p>В Lua нет непосредственной поддержки этого синтаксиса, но мы можем добиться такого же итогового эффекта путем небольшого синтаксического изменения. Идея заключается в упаковке всех аргументов в таблицу и использовании этой таблицы в качестве единственного аргумента функции. Специальный синтаксис, который Lua предоставляет для вызовов функций, с единственным конструктором таблицы в качестве аргумента, поможет нам с этим приемом:</p>
<pre><code>rename{old=&quot;temp.lua&quot;, new=&quot;temp1.lua&quot;}</code></pre>
<p>Соответственно, мы переопределяем функцию <code>rename</code> только с одним параметром и получаем действительные аргументы из этого параметра:</p>
<pre><code>function rename (arg)
  return os.rename(arg.old, arg.new)
end</code></pre>
<p>Этот способ передачи параметров особенно удобен, когда у функции много аргументов и большинство из них необязательные. Например, функция, которая создает новое окно в библиотеке GUI, может иметь десятки аргументов, по большей части необязательных, которые лучше задавать при помощи имен:</p>
<pre><code>w = Window{ x=0, y=0, width=300, height=200,
            title = &quot;Lua&quot;, background=&quot;blue&quot;,
            border = true
          }</code></pre>
<p>Функция <code>Window</code> затем вольна проверять обязательные аргументы, добавлять значения по умолчанию и т.п. Предположив, что у нас есть примитивная функция <code>_Window</code>, которая на самом деле создает новое окно (и которой все аргументы требуются в определенном порядке), мы могли бы определить <code>Window</code> как показано в листинге 5.1.</p>
<p><strong>Листинг 5.1.</strong> Функция с именованными необязательными параметрами</p>
<pre><code>function Window (options)
  -- проверка обязательных опций
  if type(options.title) ~= &quot;string&quot; then
    error(&quot;no title&quot;)
  elseif type(options.width) ~= &quot;number&quot; then
    error(&quot;no width&quot;)
  elseif type(options.height) ~= &quot;number&quot; then
    error(&quot;no height&quot;)
  end

  -- everything else is optional
  _Window(options.title,
          options.x or 0,      -- значение по умолчанию
          options.y or 0,      -- значение по умолчанию
          options.width, options.height,
          options.background or &quot;white&quot;,    -- по умолчанию
          options.border       -- по умолчанию false (nil)
         )
end</code></pre>
<h3 id="Chapter05.xhtml#sigil_toc_id_51">Упражнения</h3>
<p><strong>Упражнение 5.1.</strong> Напишите функцию, которая получает произвольное число строк и возвращает их соединенными вместе.</p>
<p><strong>Упражнение 5.2.</strong> Напишите функцию, которая получает массив и печатает все элементы этого массива. Рассмотрите преимущества и недостатки использования <code>table.unpack</code> в этой функции.</p>
<p><strong>Упражнение 5.3.</strong> Напишите функцию, которая получает произвольное число значений и возвращает их все, кроме первого.</p>
<p><strong>Упражнение 5.4.</strong> Напишите функцию, которая получает массив и печатает все комбинации элементов этого массива. (Подсказка: вы можете использовать рекурсивную формулу для получения комбинаций: <em>C (n, m) = C (n−1, m−1) + C (n−1, m)</em>. Для получения всех <em>C(n, m)</em> комбинаций из <em>n</em> элементов в группах размера <em>m</em> вы сперва добавляете первый элемент к результату и затем генерируете все комбинации <em>C(n−1, m−1)</em> из оставшихся элементов на оставшихся позициях. Когда <em>n</em> меньше, чем <em>m</em>, комбинаций больше нет. Когда <em>m</em> равно нулю, существует только одна комбинация, и она не использует никаких элементов.)</p>
<p><span id="Chapter06.xhtml"></span></p>
<h2>ГЛАВА 6</h2>
<h2 id="Chapter06.xhtml#sigil_toc_id_52">Еще раз о функциях</h2>
<p>Функции в Lua являются значениями первого класса с соответствующей лексической областью видимости.</p>
<p>Что для функций означает быть «значениями первого класса»? Это значит, что в Lua функция — это значение, обладающее теми же правами, что и традиционные значения вроде чисел и строк. Мы можем хранить функции в переменных (локальных и глобальных) и таблицах, мы можем передавать функции как аргументы и возвращать их из других функций.</p>
<p>Что для функций означает иметь «лексическую область видимости»? Это значит, что функции могут обращаться к переменным окружающих их функций (<span class="underline">Примечание</span>: Это также значит, что Lua содержит в себе полноценное лямбда-исчисление). Как мы увидим в этой главе, это на первый взгляд безобидное свойство дает огромную мощь языку, поскольку позволяет нам применять в Lua многие эффективные приемы из мира функционального программирования. Даже если вы совсем не интересуетесь функциональным программированием, все равно стоит немного узнать об этих приемах, так как они могут сделать ваши программы меньше и проще.</p>
<p>Несколько запутанным понятием в Lua является то, что функции, как и другие значения, являются анонимными; у них нет имен. Когда мы говорим об имени функции, такой как <code>print</code>, на самом деле мы имеем в виду переменную, которая хранит данную функцию. Как и с любой другой переменной, хранящей любое другое значение, мы можем манипулировать этими переменными множеством способов. Следующий пример, хоть и немного нелепый, показывает этот момент:</p>
<pre><code>a = {p = print}
a.p(&quot;Hello World&quot;)    --&gt; Hello World
print = math.sin      -- &#39;print&#39; теперь ссылается на функцию sin
a.p(print(1))         --&gt; 0.841470
sin = a.p             -- &#39;sin&#39; теперь ссылается на функцию print
sin(10, 20)           --&gt; 10 20</code></pre>
<p>(Позже мы увидим полезные применения этой возможности.)</p>
<p>Если функции являются значениями, то существуют ли выражения, которые создают функции? Да. По сути, стандартный способ написать функцию в Lua, такой как</p>
<pre><code>function foo (x) return 2*x end</code></pre>
<p>является всего лишь образцом того, что мы называем <em>синтаксическим сахаром</em>; это просто более красивый способ написать следующий код:</p>
<pre><code>foo = function (x) return 2*x end</code></pre>
<p>Таким образом, определение функции — это по сути оператор (присваивание, если более точно), который создает значение типа &quot;<code>function</code>&quot; и присваивает его переменной. Мы можем рассматривать выражение <code>function (х)</code> <em>тело</em> <code>end</code> как конструктор функции, точно так же, как <code>{}</code> является конструктором таблицы. Мы называем результат подобных конструкторов функций <em>анонимной функцией</em>. Хотя мы часто присваиваем функции глобальным переменным, задавая им что-то вроде имени, бывают случаи, когда функции остаются анонимными. Давайте рассмотрим несколько примеров.</p>
<p>Табличная библиотека предоставляет функцию <code>table.sort</code>, которая получает таблицу и сортирует ее элементы. Подобная функция должна позволять бесконечные вариации порядка сортировки: по возрастанию или по убыванию, числовой или алфавитный, таблицы с сортировкой по ключу и т. д. Вместо попытки предоставить все виды опций, <code>sort</code> предоставляет единственный необязательный параметр, который является <em>порядковой функцией</em>: функция, которая принимает два элемента и определяет, должен ли первый элемент идти перед вторым в отсортированном списке. Например, допустим, что у нас есть такая таблица записей:</p>
<pre><code>network = {
  {name = &quot;grauna&quot;,  IP = &quot;210.26.30.34&quot;},
  {name = &quot;arraial&quot;, IP = &quot;210.26.30.23&quot;},
  {name = &quot;lua&quot;,     IP = &quot;210.26.23.12&quot;},
  {name = &quot;derain&quot;,  IP = &quot;210.26.23.20&quot;},
}</code></pre>
<p>Если нам нужно отсортировать таблицу по полю <code>name</code> в обратном алфавитном порядке, то достаточно написать так:</p>
<pre><code>table.sort(network, function (a,b) return (a.name &gt; b.name) end)</code></pre>
<p>Посмотрите, насколько удобна анонимная функция в этом операторе.</p>
<p>Функция, которая получает другую функцию как аргумент, такая как <code>sort</code>, является тем, что мы называем <em>функцией высшего порядка</em>. Функции высшего порядка являются эффективным механизмом программирования, а использование анонимных функций в качестве их аргументов служит колоссальным источником гибкости. Однако, запомните, что функции высших порядков не являются чем-то особенным; они — прямое следствие способности Lua работать с функциями как со значениями первого класса.</p>
<p>Чтобы проиллюстрировать применение функций высших порядков, мы напишем упрощенное определение распространенной функции высшего порядка — производной. Следуя неформальному определению, производная функции <em>f</em> в точке <em>х</em> — это значение <em>(f (x + d) − f (x))/d</em>, где <em>d</em> стремится к бесконечно малой величине. В соответствии с этим определением мы можем вычислить приближенное значение производной следующим образом:</p>
<pre><code>function derivative (f, delta)
  delta = delta or 1e-4
  return function (x)
    return (f(x + delta) - f(x))/delta
  end
end</code></pre>
<p>Если задать функцию <code>f</code>, вызов <code>derivative(f)</code> вернет ее производную (как приближенное значение), которая является еще одной функцией:</p>
<pre><code>c = derivative(math.sin)
&gt; print(math.cos(5.2), c(5.2))
  --&gt;  0.46851667130038     0.46856084325086
print(math.cos(10), c(10))
  --&gt; -0.83907152907645    -0.83904432662041</code></pre>
<p>Поскольку функции в Lua являются значениями первого класса, мы можем хранить их не только в глобальных переменных, но и в локальных переменных и полях таблиц. Как мы увидим в дальнейшем, использование функций в полях таблицы является ключевым компонентом для некоторых продвинутых областей применения Lua, таких как модули и объектно-ориентированное программирование.</p>
<h3 id="Chapter06.xhtml#sigil_toc_id_53">6.1. Замыкания</h3>
<p>Когда мы определяем одну функцию внутри другой, она получает полный доступ к локальным переменным окружающей ее функции; мы называем это свойство <em>лексической областью видимости</em> <strong>(lexical scoping)</strong>. Хотя это правило видимости может показаться очевидным, на самом деле это не так. Лексическая область видимости вместе с функциями первого класса является высокоэффективной концепцией в языках программирования, но многие языки ее не поддерживают.</p>
<p>Давайте начнем с простого примера. Пусть у вас есть список имен студентов и таблица, которая ассоциирует имена с оценками; вам требуется отсортировать список имен по их оценкам, начиная с более высоких. Вы можете добиться этого следующим образом:</p>
<pre><code>names = {&quot;Peter&quot;, &quot;Paul&quot;, &quot;Mary&quot;}
grades = {Mary = 10, Paul = 7, Peter = 8}
table.sort(names, function (n1, n2)
  return grades[n1] &gt; grades[n2]           -- сравнивает оценки
end)</code></pre>
<p>Теперь допустим, что вам нужно создать функцию для решения данной задачи:</p>
<pre><code>function sortbygrade (names, grades)
  table.sort(names, function (n1, n2)
    return grades[n1] &gt; grades[n2]         -- сравнивает оценки
  end)
end</code></pre>
<p>Интересным моментом в этом примере является то, что анонимная функция, переданная функции <code>sort</code>, обращается к параметру <code>grades</code>, который является локальным для окружающей его функции <code>sortbygrade</code>. Внутри этой анонимной функции <code>grades</code> не является ни глобальной переменной, ни локальной переменной, а является тем, что мы называем <em>нелокальной переменной</em>. (По историческим причинам нелокальные переменные в Lua также называются <em>верхними значениями</em> <strong>(upvalue)</strong>.)</p>
<p>Почему данный момент так интересен? Потому что функции являются значениями первого класса, и вследствие этого они могут <em>выйти</em> из начальной области видимости своих переменных. Рассмотрим следующий пример:</p>
<pre><code>function newCounter ()
  local i = 0
  return function ()    -- анонимная функция
    i = i + 1
    return i
  end
end

c1 = newCounter()
print(c1())    --&gt; 1
print(c1())    --&gt; 2</code></pre>
<p>В этом коде анонимная функция ссылается на нелокальную переменную <code>i</code> для хранения своего счетчика. Однако, к тому времени, как мы вызовем анонимную функцию, переменная <code>i</code> уже выйдет из своей области видимости, поскольку функция, которая создала эту переменную (<code>newCounter</code>), уже будет возвращена. Тем не менее, Lua правильно обрабатывает эту ситуацию, используя концепцию <em>замыкания</em> <strong>(closure)</strong>. Проще говоря, замыкание — это функция вместе со всем, что ей нужно для правильного доступа к нелокальным переменным. Если мы снова вызовем <code>newCounter</code>, то она создаст новую локальную переменную <code>i</code>, поэтому мы получим новое замыкание, действующее поверх новой переменной:</p>
<pre><code>c2 = newCounter()
print(c2()) --&gt; 1
print(c1()) --&gt; 3
print(c2()) --&gt; 2</code></pre>
<p>Таким образом, <code>c1</code> и <code>с2</code> — это разные замыкания поверх одной и той же функции, и каждое замыкание воздействует на независимый экземпляр локальной переменной <code>i</code>.</p>
<p>С технической точки зрения, значением в Lua является замыкание, а не функция. Сама по себе функция — это лишь прототип для замыканий. Тем не менее, мы продолжим использовать термин «функция» для обозначения замыкания везде, где это не приведет к путанице.</p>
<p>Во многих случаях замыкания оказываются ценным инструментом. Как мы уже видели, они удобны в качестве аргументов функций высших порядков, таких как <code>sort</code>. Замыкания также ценны для функций, которые строят другие функции, как в нашем примере с <code>newCounter</code> или с производной; этот механизм позволяет программам Lua внедрять современные методы из мира функционального программирования. Замыкания также удобны для функций <em>обратного вызова</em> <strong>(callback)</strong>. Здесь подходит типичный пример про создание кнопок в традиционном инструментарии GUI. У каждой кнопки есть функция обратного вызова, которая должна быть вызвана, когда пользователь нажимает эту кнопку; вам требуется, чтобы разные кнопки совершали немного разные действия при нажатии. Например, цифровому калькулятору нужно десять похожих кнопок, по одной на каждую цифру. Вы можете создать каждую кнопку с помощью функции наподобие этой:</p>
<pre><code>function digitButton (digit)
  return Button{ label = tostring(digit),
                 action = function ()
                   add_to_display(digit)
                 end
               }
end</code></pre>
<p>В данном примере мы предполагаем, что <code>Button</code> — это функция из инструментария, которая создает новые кнопки; <code>label</code> — это метка кнопки; <code>action</code> — это замыкание обратного вызова, которое нужно вызвать при нажатии кнопки. Обратный вызов может быть произведен спустя длительное время после того, как <code>digitButton</code> выполнила свою задачу, и после того, как локальная переменная <code>digit</code> вышла из области видимости, так как он по-прежнему может обращаться к этой переменной.</p>
<p>Замыкания также ценны в совсем другом случае. Поскольку функции Lua хранятся в обычных переменных, мы можем их легко переопределять, даже если они встроенные. Эта возможность является одной из причин, почему Lua столь гибок. Часто, когда вы переопределяете функцию, в новой реализации вам все равно нужна изначальная функция. Например, предположим, что вы хотите переопределить функцию <code>sin</code>, чтобы она работала с градусами вместо радиан. Эта новая функция конвертирует свой аргумент и затем вызывает исходную функцию <code>sin</code> для выполнения настоящей работы. Ваш код при этом может выглядеть следующим образом:</p>
<pre><code>oldSin = math.sin
math.sin = function (x)
  return oldSin(x*math.pi/180)
end</code></pre>
<p>Далее приведен немного более аккуратный способ выполнить это переопределение:</p>
<pre><code>do
  local oldSin = math.sin
  local k = math.pi/180
  math.sin = function (x)
    return oldSin(x*k)
  end
end</code></pre>
<p>Теперь мы сохраняем старую версию в локальной переменной; единственный способ обратиться к ней — через новую функцию.</p>
<p>Вы можете воспользоваться этим подходом и для создания безопасных окружений, также называемых <em>песочницами</em> <strong>(sandbox)</strong>. Безопасные окружения крайне важны при выполнении ненадежного кода, например, полученного сервером через Интернет. Скажем, чтобы ограничить файлы, к которым программа может обратиться, мы можем переопределить функцию <code>io.open</code>, используя замыкания:</p>
<pre><code>do
  local oldOpen = io.open
  local access_OK = function (filename, mode)
    &lt;проверка доступа&gt;
  end
  io.open = function (filename, mode)
    if access_OK(filename, mode) then
      return oldOpen(filename, mode)
    else
      return nil, &quot;access denied&quot;
   end
  end
end</code></pre>
<p>Что делает этот пример особенно удачным, так это то, что после данного переопределения для программы нет иного способа вызвать неограниченную функцию <code>open</code>, кроме как через новую версию с ограничениями. При этом небезопасная версия хранится внутри замыкания как закрытая переменная без внешнего доступа. С этим подходом вы можете строить песочницы Lua на самом Lua с его обычными преимуществами: простотой и гибкостью. Вместо какого-то универсального решения Lua предлагает мета-механизм, чтобы вы могли подогнать ваше окружение под ваши конкретные требования к безопасности.</p>
<h3 id="Chapter06.xhtml#sigil_toc_id_54">6.2. Неглобальные функции</h3>
<p>Очевидным следствием того, что функции являются значениями первого класса, является то, что мы можем хранить функции не только в глобальных переменных, но и в локальных переменных и полях таблицы.</p>
<p>Мы уже видели некоторые примеры функций внутри полей таблиц: большинство библиотек Lua использует этот механизм (например, <code>io.read</code>, <code>math.sin</code>). Для создания подобных функций в Lua нам нужно просто соединить стандартный синтаксис для функций с синтаксисом для таблиц:</p>
<pre><code>Lib = {}
Lib.foo = function (x,y) return x + y end
Lib.goo = function (x,y) return x - y end

print(Lib.foo(2, 3), Lib.goo(2, 3)) --&gt; 5 -1</code></pre>
<p>Разумеется, мы также можем использовать конструкторы:</p>
<pre><code>Lib = {
  foo = function (x,y) return x + y end,
  goo = function (x,y) return x - y end
}</code></pre>
<p>Кроме того, Lua предлагает еще один синтаксис для определения подобных функций:</p>
<pre><code>Lib = {}
function Lib.foo (x,y) return x + y end
function Lib.goo (x,y) return x - y end</code></pre>
<p>Когда мы сохраняем функцию в локальной переменной, мы получаем <em>локальную функцию</em>, то есть функцию с ограниченной областью видимости. Подобные определения особенно удобны для пакетов: поскольку Lua рассматривает каждый кусок как функцию, кусок может объявлять локальные функции, которые видны только внутри него. Лексическая область видимости позволяет другим функциям из пакета использовать эти локальные функции:</p>
<pre><code>local f = function (&lt;параметры&gt;)
  &lt;тело&gt;
end
local g = function (&lt;параметры&gt;)
  &lt;какой-нибудь код&gt;
  f()           -- &#39;f&#39; здесь видима
  &lt;какой-нибудь код&gt;
end</code></pre>
<p>Lua поощряет подобное применение локальных функций посредством синтаксическего сахара:</p>
<pre><code>local function f (&lt;params&gt;)
  &lt;тело&gt;
end</code></pre>
<p>При определении рекурсивных локальных функций возникает требующий уточнения момент. Дело в том, что обычный подход здесь не работает. Рассмотрим следующее определение:</p>
<pre><code>local fact = function (n)
  if n == 0 then return 1
  else return n*fact(n-1)    -- глюк
  end
end</code></pre>
<p>Когда Lua компилирует вызов <code>fact(n—1)</code> в теле функции, локальная функция <code>fact</code> еще не определена. Поэтому данное выражение попытается вызвать глобальную функцию <code>fact</code>, а не локальную. Мы можем решить эту проблему, сперва определив локальную переменную, а затем уже саму функцию:</p>
<pre><code>local fact
fact = function (n)
  if n == 0 then return 1
  else return n*fact(n-1)
  end
end</code></pre>
<p>Теперь <code>fact</code> внутри функции ссылается на локальную переменную. Ее значение при определении функции не важно; к моменту выполнения функции, <code>fact</code> уже получит правильное значение.</p>
<p>Когда Lua предлагает свой синтаксический сахар для локальных функций, он не использует простое определение. Вместо этого определение наподобие</p>
<pre><code>local function foo (&lt;параметры&gt;) &lt;тело&gt; end</code></pre>
<p>расширяется до</p>
<pre><code>local foo; foo = function (&lt;параметры&gt;) &lt;тело&gt; end</code></pre>
<p>Поэтому мы можем спокойно использовать этот синтаксис для рекурсивных функций.</p>
<p>Конечно, этот прием не сработает, если у вас косвенно рекурсивные функции <strong>(поочередно вызывающие друг друга)</strong>. В таких случаях вы должны использовать эквивалент явного предварительного объявления:</p>
<pre><code>local f, g    -- предварительные объявления

function g ()
  &lt;какой-нибудь код&gt; f() &lt;какой-нибудь код&gt;
end

function f ()
  &lt;какой-нибудь код&gt; g() &lt;какой-нибудь код&gt;
end</code></pre>
<p>Остерегайтесь писать <code>local function f</code> в последнем определении. Иначе Lua создаст новую локальную переменную <code>f</code>, оставив изначальную <code>f</code> (к которой привязана <code>g</code>) неопределенной.</p>
<h3 id="Chapter06.xhtml#sigil_toc_id_55">6.3. Корректные хвостовые вызовы</h3>
<p>Другой интересной особенностью функций в Lua является то, что Lua выполняет устранение хвостовых вызовов. (Это значит, что Lua поддерживает <em>корректную хвостовую рекурсию</em>, хотя данное понятие не связано непосредственно с рекурсией; см. упражнение 6.3.)</p>
<p><em>Хвостовой вызов</em> <strong>(tail call)</strong> — это фактически <strong>goto</strong>, выглядящий как вызов функции. Хвостовой вызов происходит, когда одна функция вызывает другую в качестве своего последнего действия, и потому ей больше нечего делать. Например, в следующем коде вызов функции <code>g</code> является хвостовым:</p>
<pre><code>function f (x) return g(x) end</code></pre>
<p>После того, как <code>f</code> вызовет <code>g</code>, ей больше нечего делать. В подобных ситуациях программе не требуется возвращаться в вызывающую функцию по завершении вызванной функции. Поэтому после хвостового вызова программе не нужно хранить какую-либо информацию о вызывающей функции в стеке. Когда <code>g</code> возвращает управление, оно может непосредственно перейти к моменту вызова <code>f</code>. Некоторые реализации языков, например, интерпретатор Lua, извлекают из данного факта выгоду и на самом деле не используют какое-либо дополнительное место в стеке при совершении хвостового вызова. Мы говорим, что эти реализации поддерживают <em>устранение хвостовых вызовов</em> <strong>(tail-call elimination)</strong>.</p>
<p>Поскольку хвостовые вызовы не используют место в стеке, количество вложенных хвостовых вызовов, которое программа может выполнить, не ограничено. Скажем, мы можем вызвать следующую функцию, передав любое число в качестве аргумента:</p>
<pre><code>function foo (n)
  if n &gt; 0 then return foo(n - 1) end
end</code></pre>
<p>Этот вызов никогда не приведет к переполнению стека.</p>
<p>Когда мы прибегаем к устранению хвостовых вызовов, возникает тонкий вопрос: какой именно вызов считать хвостовым? Некоторые вполне очевидные кандидаты не соответствуют требованию о том, что вызывающей функции больше нечего делать после вызова. Например, в следующем коде вызов <code>g</code> не является хвостовым:</p>
<pre><code>function f (x) g(x) end</code></pre>
<p>Проблема в этом примере состоит в том, что после вызова <code>g</code> функция <code>f</code> должна отбросить результаты <code>g</code> перед возвратом. Все следующие вызовы также не удовлетворяют данному требованию:</p>
<pre><code>return g(x) + 1     -- необходимо выполнить сложение
return x or g(x)    -- необходимо привести к одному значению
return (g(x))       -- необходимо привести к одному значению</code></pre>
<p>В Lua хвостовым считается лишь вызов вида <code>return</code> <em>функция(аргументы)</em>. Однако, и <em>функция</em>, и ее <em>аргументы</em> могут быть сложными выражениями, поскольку Lua вычислит их перед вызовом. Например, следующий вызов является хвостовым:</p>
<pre><code>return x[i].foo(x[j] + a*b, i + j)</code></pre>
<h3 id="Chapter06.xhtml#sigil_toc_id_56">Упражнения</h3>
<p><strong>Упражнение 6.1.</strong> Напишите функцию <code>integral</code>, которая принимает функцию <code>f</code> и возвращает приближенное значение ее интеграла.</p>
<p><strong>Упражнение 6.2.</strong> В упражнении 3.3 вам надо было написать функцию, которая получает многочлен (представленный в виде таблицы) и значение его переменной, а затем возвращает значение этого многочлена. Напишите <em>каррированную</em> <strong>(принимающая свои аргументы по одному за раз)</strong> версию данной функции. Ваша функция должна принимать многочлен и возвращать функцию, которая, будучи вызвана для какого-либо значения <code>х</code>, вернет значение многочлена для этого <code>х</code>. Например:</p>
<pre><code>f = newpoly({3, 0, 1})
print(f(0))    --&gt; 1
print(f(5))    --&gt; 76
print(f(10))   --&gt; 301</code></pre>
<p><strong>Упражнение 6.3.</strong> Иногда язык с корректными хвостовыми вызовами называют языком с поддержкой корректной хвостовой рекурсии, аргументируя это тем, что данное качество имеет значение только тогда, когда у нас есть рекурсивные вызовы (Без рекурсивных вызовов максимальная глубина вызовов была бы статически фиксированной.)</p>
<p>Покажите, что это утверждение не верно для динамически типизированных языков вроде Lua: напишите программу, которая совершает неограниченную цепочку вызовов без рекурсии. (Подсказка: см. раздел 8.1.)</p>
<p><strong>Упражнение 6.4.</strong> Как мы видели, хвостовой вызов — это замаскированный <strong>goto</strong>. Придерживаясь этой идеи, перепишите код простой игры в лабиринт из раздела 4.4 с применением хвостовых вызовов. Каждый блок должен стать новой функцией, а каждый <strong>goto</strong> должен стать хвостовым вызовом.</p>
<p><span id="Chapter07.xhtml"></span></p>
<h2>ГЛАВА 7</h2>
<h2 id="Chapter07.xhtml#sigil_toc_id_57">Итераторы и общий for</h2>
<p>В этой главе мы рассмотрим, как писать итераторы для общего <strong>for</strong>. Начав с простых итераторов, мы узнаем, как использовать всю силу общего <strong>for</strong> для написания более простых и эффективных итераторов.</p>
<h3 id="Chapter07.xhtml#sigil_toc_id_58">7.1. Итераторы и замыкания</h3>
<p><em>Итератор</em> <strong>(iterator)</strong> — это любая конструкция, которая позволяет вам перебирать элементы коллекции. В Lua мы обычно представляем итераторы при помощи функций: каждый раз, когда мы вызываем функцию, она возвращает «следующий» элемент из коллекции.</p>
<p>Любой итератор должен где-то хранить свое состояние между последовательными вызовами, чтобы знать, где он находится и как себя вести с этого места. Замыкания предоставляют великолепный механизм для этой задачи. Вспомним, что замыкание — это функция, которая обращается к одной или нескольким локальным переменным из охватывающего ее окружения. Эти переменные хранят свои значения между последовательными вызовами замыкания, позволяя тем самым замыканию помнить, где оно находится при переборе элементов. Разумеется, для создания нового замыкания мы также должны создать его нелокальные переменные. Поэтому конструкция замыкания обычно включает в себя две функции: само замыкание и <em>фабрику</em> — функцию, которая создает замыкание вместе с окружающими ее переменными.</p>
<p>В качестве примера давайте напишем простой итератор для списка. В отличие от <code>ipairs</code>, этот итератор возвращает не индекс каждого элемента, а лишь его значение:</p>
<pre><code>function values (t)
  local i = 0
  return function () i = i + 1; return t[i] end
end</code></pre>
<p>В этом примере <code>values</code> — это фабрика. Каждый раз, когда мы вызываем эту фабрику, она создает новое замыкание (сам итератор). Это замыкание хранит свое состояние в своих внешних переменных <code>t</code> и <code>i</code>. Каждый раз, когда мы вызываем этот итератор, он возвращает следующее значение из списка <code>t</code>. После последнего элемента итератор вернет nil, что означает конец итерации.</p>
<p>Мы можем использовать этот итератор в цикле <strong>while</strong>:</p>
<pre><code>t = {10, 20, 30}
iter = values(t)            -- создает итератор
while true do
  local element = iter()    -- вызывает итератор
  if element == nil then break end
  print(element)
end</code></pre>
<p>Тем не менее, гораздо легче использовать общий <strong>for</strong>. В конце концов, он был разработан для данного вида итераций:</p>
<pre><code>t = {10, 20, 30}
for element in values(t) do
  print(element)
end</code></pre>
<p>Общий <strong>for</strong> ведет для итерирующего цикла всю бухгалтерию: он хранит внутри итерирующую функцию, поэтому нам не нужна переменная <code>iter</code>; он вызывает итератор для каждой новой итерации; и он останавливает цикл, когда итератор возвращает nil. (В следующем разделе мы <span>увидим, что это далеко не все, что делает общий</span> <strong>for</strong><span>.)</span></p>
<p>Как более продвинутый пример, листинг 7.1 показывает итератор для перебора всех слов из текущего входного файла. Для такого перебора нам нужно два значения: содержимое текущей строки (переменная <code>line</code>) и где мы находимся внутри этой строки (переменная <code>pos</code>). С этими данными мы можем всегда сгенерировать следующее слово. Основная часть итерирующей функции — это вызов <code>string.find</code>. Этот вызов ищет слово в текущей строке, начиная с текущей позиции. Он описывает «слово», используя образец '<code>%w+</code>', которому удовлетворяет один или более буквенно-цифровых символов. Если этот вызов находит слово, то функция обновляет текущую позицию на первый символ после слова и возвращает это слово (<span class="underline">Примечание</span>: Функция <code>string.sub</code> извлекает подстроку из <code>line</code> между заданными позициями; мы подробно рассмотрим ее в разделе 21.2). Иначе итератор читает следующую строку и повторяет поиск. Если строк больше нет, он возвращает nil, чтобы сообщить об окончании итерации.</p>
<p>Несмотря на его сложность, использование <code>allwords</code> крайне просто:</p>
<pre><code>for word in allwords() do
  print(word)
end</code></pre>
<p>Это типичная ситуация с итераторами: их может быть не так легко написать, зато их легко использовать. Серьезной проблемы в этом нет; гораздо чаще конечные пользователи, программирующие на Lua, не определяют итераторы, а лишь используют те, что предоставлены приложением.</p>
<p><strong>Листинг 7.1.</strong> Итератор для обхода всех слов из входного файла</p>
<pre><code>function allwords ()
  local line = io.read()    -- текущая строка
  local pos = 1             -- текущая позиция в строке
  return function ()        -- итерирующая функция
    while line do           -- повторяет, пока есть строки
      local s, e = string.find(line, &quot;%w+&quot;, pos)
      if s then             -- слово найдено?
        pos = e + 1         -- следующая позиция после этого слова
        return string.sub(line, s, e)    -- возвращает это слово
      else
        line = io.read()    -- слово не найдено; пробует следующую строку
        pos = 1             -- перезапуск с первой позиции
      end
    end
    return nil              -- строк больше нет; конец обхода
  end
end</code></pre>
<h3 id="Chapter07.xhtml#sigil_toc_id_59">7.2. Семантика общего for</h3>
<p>Единственным недостатком ранее рассмотренных итераторов является то, что нам необходимо создавать новое замыкание для инициализации каждого нового цикла. Для большинства случаев это не является проблемой. Например, в случае итератора <code>allwords</code> цена создания одного единственного замыкания несравнима с ценой чтения целого файла. Однако, в некоторых ситуациях эта лишняя нагрузка может быть неприемлемой. В таких случаях мы можем использовать сам общий <strong>for</strong> для хранения состояния итерации. В данном разделе мы увидим, какие возможности по хранению состояния предлагает общий <strong>for</strong>.</p>
<p>Мы видели, что общий <strong>for</strong> во время выполнения цикла хранит итерирующую функцию внутри себя. На самом деле он хранит три значения: <em>итерирующую функцию</em>, <em>инвариантное состояние</em> <strong>(неизменяющееся)</strong> и <em>управляющую переменную</em>. Теперь давайте обратимся к деталям.</p>
<p>Синтаксис общего <strong>for</strong> следующий:</p>
<pre><code>for &lt;список_переменных&gt; in &lt;список_выражений&gt; do
  &lt;тело&gt;
end</code></pre>
<p>Здесь <em>список_переменных</em> — это список из одного или нескольких имен переменных, разделенных запятыми, a <em>список_выражений</em> — это список из одного или нескольких выражений, также разделенных запятыми. Часто список выражений состоит из единственного элемента — вызова фабрики итераторов. В следующем коде, например, список переменных — это <code>k</code>, <code>v</code>, а список выражений состоит из единственного элемента <code>pairs(t)</code>:</p>
<pre><code>for k, v in pairs(t) do print(k, v) end</code></pre>
<p>Часто список переменных тоже состоит всего из одной переменной, как в следующем цикле:</p>
<pre><code>for line in io.lines() do
  io.write(line, &quot;\n&quot;)
end</code></pre>
<p>Мы называем первую переменную в списке <em>управляющей переменной</em>. В течение всего цикла ее значение никогда не равно nil, поскольку когда она становится равной nil, цикл завершается.</p>
<p>Первое, что делает цикл <strong>for</strong>, — вычисляет выражения после <strong>in</strong>. Эти выражения должны дать три значения, которые хранит <strong>for</strong>: итерирующая функция, инвариантное состояние и начальное значение управляющей переменной. Как и во множественном присваивании, только последний (или единственный) элемент списка может дать более одного значения; число этих значений приводится к трем, лишние значения отбрасываются, вместо недостающих добавляются nil. (Когда мы используем простые итераторы, фабрика возвращает только итерирующую функцию, поэтому инвариантное состояние и управляющая переменная получают значение nil.)</p>
<p>После этого шага инициализации <strong>for</strong> вызывает итерирующую функцию с двумя аргументами: инвариантным состоянием и управляющей переменной. (С точки зрения конструкции <strong>for</strong>, это инвариантное состояние вообще не имеет никакого смысла. Оператор <strong>for</strong> лишь передает значение состояния из шага инициализации в вызовы итерирующей функции.) Затем <strong>for</strong> присваивает значения, возвращенные итерирующей функцией, переменным, объявленным в его списке переменных. Если первое возвращенное значение (присваиваемое управляющей переменной) равно nil, то цикл завершается. Иначе <strong>for</strong> выполняет свое тело и вновь вызывает итерирующую функцию, повторяя процесс.</p>
<p>Точнее говоря, конструкция вида</p>
<pre><code>for var_1, ..., var_n in &lt;список_выражений&gt; do &lt;блок&gt; end</code></pre>
<p>эквивалента следующему коду:</p>
<pre><code>do
  local _f, _s, _var = &lt;список_выражений&gt;
  while true do
    local var_1, ... , var_n = _f(_s, _var)
    _var = var_1
    if _var == nil then break end
    &lt;блок&gt;
  end
end</code></pre>
<p>Поэтому если наша итерирующая функция — <em>f</em>, неизменяемое состояние — <em>s</em>, а начальное состояние для управляющей переменной — <em>a<sub>0</sub></em>, то управляющая переменная будет пробегать следующие значения <em>a<sub>1</sub> = f (s, a<sub>0</sub>), a<sub>2</sub> = f (s, a<sub>1</sub>)</em> и т. д., до тех пор, пока <em>а<sub>i</sub></em> не станет равной nil. Если у <strong>for</strong> есть другие переменные, то они просто получат дополнительные значения, возвращаемые при каждом вызове <em>f</em>.</p>
<h3 id="Chapter07.xhtml#sigil_toc_id_60">7.3. Итераторы без состояния</h3>
<p>Как следует из названия, итератор без состояния — это итератор, который не хранит в себе какое-либо состояние. Поэтому мы можем использовать один и тот же итератор без состояния во многих циклах, избегая тем самым платы за создание новых замыканий.</p>
<p>Как мы только что видели, оператор <strong>for</strong> вызывает свою итерирующую функцию с двумя аргументами: инвариантное остояние и управляющая переменная. Итератор без состояния генерирует следующий элемент цикла, используя только эти два значения. Типичным примером этого вида итератора является <code>ipairs</code>, который перебирает все элементы массива:</p>
<pre><code>a = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}
for i, v in ipairs(a) do
  print(i, v)
end</code></pre>
<p>Состояние этой итерации — это таблица, которую мы перебираем (т.е. инвариантное состояние, которое не меняется на протяжении цикла), и текущий индекс (управляющая переменная). И <code>ipairs</code> (фабрика), и итератор очень просты; мы могли бы написать их на Lua следующим образом:</p>
<pre><code>local function iter (a, i)
  i = i + 1
  local v = a[i]
  if v then
    return i, v
  end
end

function ipairs (a)
  return iter, a, 0
end</code></pre>
<p>Когда Lua вызывает <code>ipairs(а)</code> в цикле <strong>for</strong>, она получает три значения: функцию <strong>iter</strong> как итератор, <code>а</code> как инвариантное состояние и ноль как начальное значение для управляющей переменной. Затем Lua вызывает <code>iter(а,0)</code>, что дает <code>1,а[1]</code> (если только <code>а[1]</code> уже не nil). На второй итерации вызывается <code>iter(а,1)</code>, что дает <code>2,а[2]</code>, и т. д., до первого элемента, равного nil.</p>
<p>Функция <code>pairs</code>, которая перебирает все элементы таблицы, аналогична, за исключением того, что итерирующая функция — это функция <code>next</code>, которая в Lua является примитивной:</p>
<pre><code>function pairs (t)
  return next, t, nil
end</code></pre>
<p>Вызов <code>next(t,k)</code>, где <code>k</code> — это ключ таблицы <code>t</code>, возвращает следующий ключ в таблице в произвольном порядке, а также связанное с этим ключом значение как второе возвращаемое значение. Вызов <code>next(t,nil)</code> возвращает первую пару. Когда пар больше нет, <code>next</code> возвращает nil.</p>
<p>Некоторые предпочитают использовать <code>next</code> напрямую, избегая вызова <code>pairs</code>:</p>
<pre><code>for k, v in next, t do
  &lt;тело цикла&gt;
end</code></pre>
<p>Вспомним, что <strong>for</strong> приводит свой список выражений к трем результатам, чтобы получить <code>next</code>, <code>t</code> и nil; это именно то, что получается при вызове <code>pairs</code>.</p>
<p>Итератор для обхода связанного списка является еще одним интересным примером итератора без состояния. (Как мы уже упомянули, связанные списки нечасто встречаются в Lua, но иногда они нам нужны.)</p>
<pre><code>local function getnext (list, node)
  if not node then
    return list
  else
    return node.next
  end
end

function traverse (list)
  return getnext, list, nil
end</code></pre>
<p>Суть этого приема состоит в использовании основного узла списка в качестве инвариантного состояния (второе значение, возвращаемое <code>traverse</code>) и текущего узла в качестве управляющей переменной. При первом вызове итерирующей функции <code>getnext</code> переменная <code>node</code> будет равна nil, и поэтому функция вернет <code>list</code> как первый узел. В последующий вызовах <code>node</code> не будет равна nil, и поэтому итератор, как и ожидалось, вернет <code>node.next</code>. Как обычно, использование этого итератора крайне просто:</p>
<pre><code>list = nil
for line in io.lines() do
  list = {val = line, next = list}
end

for node in traverse(list) do
  print(node.val)
end</code></pre>
<h3 id="Chapter07.xhtml#sigil_toc_id_61">7.4. Итераторы со сложным состоянием</h3>
<p>Часто итератору требуется хранить больший объем состояния, чем помещается в единственное инвариантное состояние и управляющую переменную. Простейшим решением является использование замыканий. Альтернативным решением будет запаковать все, что нужно итератору, в таблицу и использовать эту таблицу как инвариантное состояние для итерации. С помощью таблицы итератор можем хранить столько данных, сколько ему потребуется на протяжении цикла. Кроме того, во время итерации он может менять эти данные. Хотя состояние — это все время одна и та же таблица (поэтому оно инвариантное), содержимое таблицы может меняться на протяжении цикла. Поскольку такие итераторы хранят все свои данные в состоянии, обычно они игнорируют второй аргумент, предоставляемый общим циклом <strong>for</strong> (итерационная переменная).</p>
<p>В качестве примера такого подхода мы перепишем итератор <code>allwords</code>, который обходит все слова текущего входного файла. На этот раз мы будем хранить его состояние в таблице с двумя полями: <code>line</code> и <code>pos</code>.</p>
<p>Функция, которая начинает итерацию, довольно проста. Она должна вернуть итерирующую функцию и начальное состояние:</p>
<pre><code>local iterator    -- будет определена позже

function allwords ()
  local state = {line = io.read(), pos = 1}
  return iterator, state
end</code></pre>
<p>Основную работу выполняет функция <code>iterator</code>:</p>
<pre><code>function iterator (state)
  while state.line do               -- повторяет, пока есть строки
    -- ищет следующее слово
    local s, e = string.find(state.line, &quot;%w+&quot;, state.pos)
    if s then                       -- слово найдено?
      -- обновляет следующую позицию (после этого слова)
      state.pos = e + 1
      return string.sub(state.line, s, e)
    else                            -- слово не найдено
      state.line = io.read()        -- пробует следующую строку...
      state.pos = 1                 -- ... начиная с первой позиции
    end
  end
  return nil                        -- строк больше нет: конец цикла
end</code></pre>
<p>При любой возможности вам следует пытаться написать итераторы без состояния, такие, что хранят все свое состояние в переменных цикла <strong>for</strong>. С ними вы не создаете новых объектов, когда начинаете цикл. Если для вашей итерации эта модель не подходит, то вам следует попробовать замыкания. Помимо большей изящности, замыкание обычно более эффективно, чем итератор с применением таблиц: во-первых, дешевле создать замыкание, чем таблицу; во-вторых, доступ к нелокальным переменным быстрее, чем доступ к полям таблицы. Позже мы увидим еще один способ писать итераторы, основанный на сопрограммах. Это самое эффективное решение, хотя и более затратное.</p>
<h3 id="Chapter07.xhtml#sigil_toc_id_62">7.5. Подлинные итераторы</h3>
<p>Термин «итератор» несколько неточен, поскольку итерацию выполняют не наши итераторы, а цикл <strong>for</strong>. Итераторы лишь предоставляют последовательные значения для итерации. Пожалуй, более удачным термином был бы «генератор», но термин «итератор» уже получил широкое распространение в других языках, таких как Java.</p>
<p>Тем не менее, существует другой способ построения итераторов, при котором итераторы действительно выполняют итерацию. Когда мы используем такие итераторы, мы не пишем цикл; вместо этого мы просто вызываем итератор с аргументом, описывающим, что итератор должен делать на каждой итерации. Точнее итератор получает в качестве аргумента функцию, которую он вызывает внутри своего цикла.</p>
<p>В качестве конкретного примера давайте еще раз перепишем итератор <code>allwords</code>, придерживаясь этого стиля:</p>
<pre><code>function allwords (f)
  for line in io.lines() do
    for word in string.gmatch(line, &quot;%w+&quot;) do
      f(word)    -- вызывает функцию
    end
  end
end</code></pre>
<p>Для использования этого итератора мы просто должны предоставить тело цикла как функцию. Если нам нужно всего лишь напечатать каждое слово, то мы просто используем <code>print</code>:</p>
<pre><code>allwords(print)</code></pre>
<p>Зачастую в качестве тела цикла используется анонимная функция. Например, следующий фрагмент кода считает, сколько раз слово «hello» встречается во входном файле:</p>
<pre><code>local count = 0
allwords(function (w)
  if w == &quot;hello&quot; then count = count + 1 end
end)
print(count)</code></pre>
<p>Та же самая задача, записанная в стиле предыдущего итератора, не сильно отличается:</p>
<pre><code>local count = 0
for w in allwords() do
  if w == &quot;hello&quot; then count = count + 1 end
end
print(count)</code></pre>
<p>Подобные итераторы были популярны в более старых версиях Lua, когда в языке не было оператора <strong>for</strong>. Какое отношение они имеют к итераторам в стиле генераторов? У обоих стилей примерно одинаковые затраты: один вызов функции на итерацию. С одной стороны, легче писать итератор с использованием подлинных итераторов (хотя мы можем получить эту же легкость при помощи сопрограмм). С другой стороны, стиль генераторов более гибкий. Во-первых, он позволяет две и более параллельных итерации. (Например, рассмотрим случай перебора сразу двух файлов, сравнивая их пословно.) Во-вторых, он позволяет использование <strong>break</strong> и <strong>return</strong> внутри тела итератора. С подлинными итераторами <strong>return</strong> возвращает из анонимной функции, но не из функции, совершающей итерацию. В основном, я обычно предпочитаю генераторы.</p>
<h3 id="Chapter07.xhtml#sigil_toc_id_63">Упражнения</h3>
<p><strong>Упражнение 7.1.</strong> Напишите итератор <code>fromto</code> так, чтобы следующие два цикла оказались эквивалентными:</p>
<pre><code>for i in fromto(n, m)
  &lt;тело&gt;
end</code></pre>
<pre><code>for i = n, m
  &lt;тело&gt;
end</code></pre>
<p>Можете ли вы реализовать его при помощи итератора без состояния?</p>
<p><strong>Упражнение 7.2.</strong> Добавьте параметр, отвечающий за шаг, к итератору из предыдущего упражнения. Можете ли вы по-прежнему реализовать его как итератор без состояния?</p>
<p><strong>Упражнение 7.3.</strong> Напишите итератор <code>uniquewords</code>, который возвращает все слова из заданного файла без повторений. (Подсказка: начните с кода <code>allwords</code> из листинга 7.1; используйте таблицу, чтобы хранить все слова, которые вы уже вернули.)</p>
<p><strong>Упражнение 7.4.</strong> Напишите итератор, который возвращает все непустые подстроки заданной строки. (Вам понадобится функция <code>string.sub</code>.)</p>
<p><span id="Chapter08.xhtml"></span></p>
<h2>ГЛАВА 8</h2>
<h2 id="Chapter08.xhtml#sigil_toc_id_64">Компиляция, выполнение и ошибки</h2>
<p>Хотя мы называем Lua интерпретируемым языком, Lua всегда предкомпилирует исходный код в промежуточную форму перед его выполнением. (В этом нет ничего страшного: многие интерпретируемые языки делают то же самое.) Наличие этапа компиляции может казаться неуместным в интерпретируемом языке вроде Lua. Однако, отличительным признаком интерпретируемых языков является не то, что они не компилируются, а то, что в них возможно (и легко) выполнять код, генерируемый на лету. Можно сказать, что наличие функции вроде <code>dofile</code> — это то, что позволяет Lua называться интерпретируемым языком.</p>
<h3 id="Chapter08.xhtml#sigil_toc_id_65">8.1. Компиляция</h3>
<p>Ранее мы ввели <code>dofile</code> как своего рода примитивную операцию для выполнения кусков кода Lua, но <code>dofile</code> на самом деле является вспомогательной функцией: всю тяжелую работу выполняет <code>loadfile</code>. Как и <code>dofile</code>, <code>loadfile</code> загружает кусок кода Lua из файла, но при этом не выполняет его. Вместо этого он только компилирует этот кусок и возвращает скомпилированный кусок как функцию. Более того, в отличие от <code>dofile</code>, <code>loadfile</code> не вызывает ошибки, а наоборот возвращает их коды, чтобы мы могли разобраться с ошибкой. Мы могли бы определить <code>dofile</code> следующим образом:</p>
<pre><code>function dofile (filename)
  local f = assert(loadfile(filename))
  return f()
end</code></pre>
<p>Обратите внимание на использование <code>assert</code> для вызова ошибки, если <code>loadfile</code> даст сбой.</p>
<p>Для простых задач <code>dofile</code> удобна, поскольку выполняет всю работу за один вызов. Однако <code>loadfile</code> более гибкая. В случае ошибки <code>loadfile</code> возвращает nil и сообщение об ошибке, что позволяет нам обработать ошибку более подходящими для нас способами. Более того, если нам нужно выполнить файл несколько раз, то мы можем один раз вызвать <code>loadfile</code> и несколько раз вызвать возвращенную им функцию. Этот подход гораздо дешевле, чем несколько раз вызывать <code>dofile</code>, поскольку файл компилируется лишь один раз.</p>
<p>Функция <code>load</code> похожа на <code>loadfile</code>, за исключением того, что она берет кусок кода не из файла, а из строки (<span class="underline">Примечание</span>: В Lua 5.1 функция <code>loadstring</code> выполняет роль <code>load</code>). Например, рассмотрим следующую строку:</p>
<pre><code>f = load(&quot;i = i + 1&quot;)</code></pre>
<p>После этого кода <code>f</code> станет функцией, которая при вызове выполняет <code>i = i + 1</code>:</p>
<pre><code>i = 0
f(); print(i)    --&gt; 1
f(); print(i)    --&gt; 2</code></pre>
<p>Функция <code>load</code> довольно мощная, и мы должны использовать ее с осторожностью. Это также затратная функция (по сравнению с некоторыми альтернативами), которая может привести к непонятному коду. Перед ее использованием, убедитесь, что в вашем распоряжении нет более простого способа решить задачу.</p>
<p>Если хотите по-быстрому воспользоваться <code>dostring</code> (т.е. загрузить и выполнить кусок), можете непосредственно использовать результат <code>load</code>:</p>
<pre><code>load(s)()</code></pre>
<p>Однако, если есть хотя бы одна синтаксическая ошибка, то <code>load</code> вернет nil и окончательным сообщением об ошибке будет что-то вроде <em>&quot;attempt to call a nil value&quot;</em>. Для более понятных сообщений об ошибках используйте <code>assert</code>:</p>
<pre><code>assert(load(s))()</code></pre>
<p>Обычно нет никакого смысла применять функцию <code>load</code> на строковом литерале. Например, следующие две строки примерно эквиваленты:</p>
<pre><code>f = load(&quot;i = i + 1&quot;)

f = function () i = i + 1 end</code></pre>
<p>Тем не менее, вторая строка кода гораздо быстрее, поскольку Lua скомпилирует функцию вместе с окружающим ее куском. В первой строке вызов <code>load</code> включает отдельную компиляцию.</p>
<p>Поскольку <code>load</code> не компилирует с учетом лексической области действия, то те две строки из предыдущего примера могут быть не совсем эквивалентны. Чтобы увидеть разницу, давайте слегка изменим пример:</p>
<pre><code>i = 32
local i = 0
f = load(&quot;i = i + 1; print(i)&quot;)
g = function () i = i + 1; print(i) end
f()    --&gt; 33
g()    --&gt; 1</code></pre>
<p>Функция <code>g</code> работает с локальной <code>i</code>, как и ожидалось, но <code>f</code> работает с глобальной <code>i</code>, поскольку <code>load</code> всегда компилирует свои куски в глобальном окружении.</p>
<p>Наиболее типичным использованием <code>load</code> является выполнение внешнего кода, то есть фрагментов кода, поступающих извне вашей программы. Например, вам может потребоваться построить график функции, заданной пользователем; пользователь вводит код функции, а вы затем используете <code>load</code>, чтобы выполнить его. Обратите внимание, что <code>load</code> ожидает получить кусок, то есть операторы. Если вы хотите вычислить выражение, то вы можете поставить перед выражением <strong>return</strong>, что даст вам оператор, возвращающий значение заданного выражения. Посмотрите на пример:</p>
<pre><code>print &quot;enter your expression:&quot;
local l = io.read()
local func = assert(load(&quot;return &quot; .. l))
print(&quot;the value of your expression is &quot; .. func())</code></pre>
<p>Поскольку функция, возвращенная <code>load</code>, является обычной, вы можете вызвать ее несколько раз:</p>
<pre><code>print &quot;enter function to be plotted (with variable &#39;x&#39;):&quot;
local l = io.read()
local f = assert(load(&quot;return &quot; .. l))
for i = 1, 20 do
  x = i -- глобальная &#39;x&#39; (чтобы быть видимой из этого куска кода)
  print(string.rep(&quot;*&quot;, f()))
end</code></pre>
<p>(Функция <code>string.rep</code> повторяет строку заданное число раз.)</p>
<p>Мы также можем вызвать функцию <code>load</code>, передав ей в качестве аргумента <em>считывающую функцию</em> <strong>(reader function)</strong>. Считывающая функция может возвращать кусок кода частями; <code>load</code> последовательно вызывает ее до тех, пока она не вернет nil, обозначающий конец куска. В качестве примера следующий вызов эквивалентен <code>loadfile</code>:</p>
<pre><code>f = load(io.lines(filename, &quot;*L&quot;))</code></pre>
<p>Как мы подробно рассмотрим в главе 22, вызов <code>io.lines(filename,&quot;*L&quot;)</code> возвращает функцию, которая при каждом своем вызове возвращает следующую строку из заданного файла (<span class="underline">Примечание</span>: Опции для <code>io.lines</code> появились только в Lua 5.2). Таким образом, <code>load</code> будет читать кусок из файла строка за строкой. Следующий вариант похож, но более эффективен:</p>
<pre><code>f = load(io.lines(filename, 1024))</code></pre>
<p>Здесь итератор, возвращенный <code>io.lines</code>, читает файл блоками по 1024 байта.</p>
<p>Lua рассматривает каждый независимый кусок как тело анонимной функции с переменным числом аргументов. Например, <code>load(&quot;а = 1&quot;)</code> возвращает аналог следующего выражения:</p>
<pre><code>function (...) a = 1 end</code></pre>
<p>Как и любые другие функции, куски могут объявлять локальные переменные:</p>
<pre><code>f = load(&quot;local a = 10; print(a + 20)&quot;)
f() --&gt; 30</code></pre>
<p>Используя эти возможности, мы можем переписать наш пример с построением графика так, чтобы избежать применения глобальной переменной <code>х</code>:</p>
<pre><code>print &quot;enter function to be plotted (with variable &#39;x&#39;):&quot;
local l = io.read()
local f = assert(load(&quot;local x = ...; return &quot; .. l))
for i = 1, 20 do
  print(string.rep(&quot;*&quot;, f(i)))
end</code></pre>
<p>Мы ставим объявление &quot;<code>local x = ...</code>&quot; в начало куска, чтобы определить <code>х</code> как локальную переменную. Затем мы вызываем <code>f</code> с аргументом <code>i</code>, который становится значением выражения с переменным числом аргументов <code>(...)</code>.</p>
<p>Функции загрузки кусков никогда не вызывают ошибки. В случае ошибки любого рода они возвращают nil и сообщение об ошибке:</p>
<pre><code>print(load(&quot;i i&quot;))
  --&gt; nil    [string &quot;i i&quot;]:1: &#39;=&#39; expected near &#39;i&#39;</code></pre>
<p>Более того, у этих функций нет никакого побочного эффекта. Они только компилируют кусок во внутреннее представление и возвращают результат как анонимную функцию. Распространенная ошибка — полагать, что загрузка куска определяет функции. В Lua определения функций являются присваиваниями; поэтому они происходят во время выполнения, а не во время компиляции. Например, допустим, что у нас есть файл <code>fоо.lua</code> наподобие следующего:</p>
<pre><code>-- файл &#39;foo.lua&#39;
function foo (x)
  print(x)
end</code></pre>
<p>Затем мы выполняем команду</p>
<pre><code>f = loadfile(&quot;foo.lua&quot;)</code></pre>
<p>После этой команды <code>foo</code> скомпилирована, но еще не определена. Чтобы определить ее, мы должны выполнить этот кусок:</p>
<pre><code>print(foo)    --&gt; nil
f()           -- определяет &#39;foo&#39;
foo(&quot;ok&quot;)     --&gt; ok</code></pre>
<p>В готовой к распространению программе, которой требуется выполнять внешний код, вы должны обрабатывать любые ошибки, возникающие при загрузке куска. Более того, вам может понадобится запустить новый кусок в защищенном окружении, чтобы избежать неприятных побочных эффектов. Мы подробно обсудим окружения в главе 14.</p>
<h3 id="Chapter08.xhtml#sigil_toc_id_66">8.2. Предкомпилированный код</h3>
<p>Как я отметил в начале этой главы, Lua предкомпилирует исходный код перед его выполнением. Lua также позволяет распространять код в предкомпилированной форме.</p>
<p>Простейшим способом получения предкомпилированного файла (<em>бинарного куска</em> на жаргоне Lua) является использование программы <code>luac</code>, которая входит в стандартную поставку. Например, следующий вызов создает новый файл <code>prog.1с</code> с предкомпилированной версией файла <code>prog.lua</code>:</p>
<pre><code>$ luac -o prog.lc prog.lua</code></pre>
<p>Интерпретатор может выполнить этот новый файл прямо как обычный код Lua, работая с ним точно так же, как и с исходным файлом:</p>
<pre><code>$ lua prog.lc</code></pre>
<p>Lua принимает предкомпилированный код практически везде, где он допускает исходный код. В частности, <code>loadfile</code> и <code>load</code> принимают предкомпилированный код.</p>
<p>Мы можем написать упрощенную версию <code>luac</code> непосредственно на Lua:</p>
<pre><code>p = loadfile(arg[1])
f = io.open(arg[2], &quot;wb&quot;)
f:write(string.dump(p))
f:close()</code></pre>
<p>Основная функция здесь — это <code>string.dump</code>: она получает функцию Lua и возвращает ее предкомпилированный код как строку, правильно оформленную для ее обратной загрузки в Lua.</p>
<p>Программа <code>luac</code> предлагает некоторые другие интересные опции. В частности, опция <code>-l</code> печатает список кодов операций, которые компилятор генерирует для данного куска. В качестве примера листинг 8.1 содержит вывод программы <code>luac</code> с опцией <code>-l</code> для следующего однострочного файла:</p>
<pre><code>a = x + y - z</code></pre>
<p>(Мы не будем обсуждать внутреннее устройство Lua в этой книге; если вас интересуют подробности об этих кодах операций, то поиск в Интернете по фразе ''<code>lua opcode</code>&quot; должен дать вам подходящий материал.)</p>
<p><strong>Листинг 8.1.</strong> Пример вывода <span class="code">luac -l</span></p>
<pre><code>main stdin:0,0 (7 instructions, 28 bytes at 0x988cb30)
0+ params, 2 slots, 0 upvalues, 0 locals, 4 constants, 0 functions
 1 [1] GETGLOBAL 0 -2 ; x
 2 [1] GETGLOBAL 1 -3 ; y
 3 [1] ADD 0 0 1
 4 [1] GETGLOBAL 1 -4 ; z
 5 [1] SUB 0 0 1
 6 [1] SETGLOBAL 0 -1 ; a
 7 [1] RETURN 0 1</code></pre>
<p>Код в предкомпилированной форме не всегда меньше исходного кода, но он загружается быстрее. Еще одним преимуществом является то, что это дает вам защиту от случайных изменений в исходниках. Однако, в отличие от исходного кода, поврежденный злоумышленником бинарный код может привести к падению интерпретатора Lua или даже выполнить предоставленный пользователем машинный код. При выполнении обычного кода вам не о чем беспокоиться. Однако, вам следует избегать выполнения ненадежного кода в предкомпилированной форме. У функции <code>load</code> есть опция как раз для этой задачи.</p>
<p>Кроме обязательного первого аргумента, у <code>load</code> есть еще три необязательных. Вторым аргументом является имя куска, которое используется только в сообщениях об ошибках. Четвертый аргумент — это окружение, которое мы обсудим в главе 14. Третий аргумент — это именно то, что нас здесь интересует; он управляет тем, какие виды кусков могут быть загружены. При наличии этот аргумент должен быть строкой: строка &quot;<code>t</code>&quot; позволяет загружать лишь текстовые (обычные) куски, &quot;<code>b</code>&quot; позволяет загружать лишь бинарные (предкомпилированные) куски, а &quot;<code>bt</code>&quot;, значение по умолчанию, разрешает оба формата.</p>
<h3 id="Chapter08.xhtml#sigil_toc_id_67">8.3. Код С</h3>
<p>В отличие от кода, написанного на Lua, код С должен быть скомпонован <strong>(связан)</strong> с приложением перед его использованием. В некоторых популярных операционных системах наиболее лекий способ создания этой связи заключается в применении средства динамической компоновки. Однако, данное средство не является частью спецификации ANSI С; поэтому переносимого способа его реализации не существует.</p>
<p>Обычно Lua не содержит средства, которые не могут быть реализованы в ANSI С. Однако, с динамической компоновкой иная ситуация. Мы можем рассматривать ее как основу всех других средств: имея ее, мы способны динамически подгружать любое другое средство, которого нет в Lua. Поэтому в данном особом случае Lua отказывается от правил переносимости и реализует средство динамической компоновки для ряда платформ. Стандартная реализация предлагает его поддержку для Windows, Mac OS X, Linux, FreeBSD, Solaris и большинства других реализаций UNIX. Перенос данного средства на другие платформы должен быть не сложным; проверьте ваш дистрибутив. (Для этого выполните <code>print(package.loadlib(&quot;a&quot;,&quot;b&quot;))</code> из приглашения ввода Lua и посмотрите на результат. Если он жалуется на несуществующий файл, то у вас есть средство динамической компоновки. В противном случае сообщение об ошибке должно указать, что данное средство не поддерживается или не установлено.)</p>
<p>Lua предоставляет все возможности динамической компоновки посредством единственной функцию под названием <code>package.lodlib</code>. У нее есть два строковых аргумента: полный путь к библиотеке и имя функции из этой библиотеки. Поэтому ее типичный вызов выглядит как следующий фрагмент кода:</p>
<pre><code>local path = &quot;/usr/local/lib/lua/5.1/socket.so&quot;
local f = package.loadlib(path, &quot;luaopen_socket&quot;)</code></pre>
<p>Функция <code>loadlib</code> загружает заданную библиотеку и связывает ее с Lua. Однако, она не вызывает заданную функцию. Вместо этого она возвращает функцию С как функцию Lua. В случае ошибки при загрузке библиотеки или нахождении инициализирующей функции <code>loadlib</code> возвращает nil и сообщение об ошибке.</p>
<p>Функция <code>loadlib</code> является очень низкоуровневой. Мы должны предоставить полный путь к библиотеке и правильное имя функции (включая символы подчеркивания в начале, время от времени добавляемые компилятором). Чаще всего мы загружаем библиотеки С посредством <code>require</code>. Эта функция ищет библиотеку и использует <code>loadlib</code>, чтобы загрузить для нее инициализирующую функцию. При вызове эта инициализирующая функция строит и возвращает таблицу с функциями из этой библиотеки подобно тому, как это делает обычная библиотека Lua. Мы обсудим <code>require</code> в разделе 15.1 и подробнее рассмотрим библиотеки С в разделе 27.3.</p>
<h3 id="Chapter08.xhtml#sigil_toc_id_68">8.4. Ошибки</h3>
<p><em>Errare humanum est</em> <strong>(Человеку свойственно ошибаться)</strong>. Поэтому мы должны обрабатывать ошибки лучшим из доступных нам способов. Поскольку Lua является расширяющим языком, часто встраиваемым в приложение, он не может просто упасть или завершить работу в случае возникновения ошибки. Вместо этого, каждый раз, когда возникает ошибка, Lua завершает текущий кусок и возвращает управление в приложение.</p>
<p>Любая неожиданная ситуация, с которой сталкивается Lua, вызывает ошибку. Ошибки возникают, когда вы (то есть ваша программа) пытаетесь сложить значения, которые не являются числами, индексировать не таблицу и т. п. (Вы можете изменить это поведение при помощи <em>метатаблиц</em>, как мы увидим позже.) Вы также можете напрямую вызвать ошибку при помощи вызова функции <code>error</code> с сообщением об ошибке в качестве аргумента. Обычно эта функция является подходящим способом для оповещения об ошибках в вашем коде:</p>
<pre><code>print &quot;enter a number:&quot;
n = io.read(&quot;*n&quot;)
if not n then error(&quot;invalid input&quot;) end</code></pre>
<p>Данная конструкция вызова <code>error</code> для некоторых условий настолько распространена, что для нее в Lua есть встроенная функция <code>assert</code>:</p>
<pre><code>print &quot;enter a number:&quot;
n = assert(io.read(&quot;*n&quot;), &quot;invalid input&quot;)</code></pre>
<p>Функция <code>assert</code> проверяет, действительно ли ее первый аргумент не ложен, и просто возвращает этот аргумент; если аргумент ложен, то <code>assert</code> вызывает ошибку. Ее второй аргумент (сообщение) не обязателен. Однако, имейте в виду, что <code>assert</code> — это обычная функция. В связи с этим Lua всегда вычисляет ее аргументы перед вызовом. Поэтому если вы напишите что-то вроде</p>
<pre><code>n = io.read()
assert(tonumber(n), &quot;invalid input: &quot; .. n .. &quot; is not a number&quot;)</code></pre>
<p>то Lua всегда выполнит конкатенацию, даже когда <code>n</code> является числом. В таких случаях разумнее бывает использовать явную проверку.</p>
<p>Когда функция обнаруживает непредвиденную ситуацию (<em>исключение</em>), ей доступны две основные линии поведения: вернуть код ошибки (обычно nil) или вызвать ошибку посредством вызова функции <code>error</code>. Не существует жестких правил для выбора между этими двумя вариантами, но мы можем дать общую рекомендацию: исключение, которое легко обходится, должно вызывать ошибку; иначе оно должно вернуть код ошибки.</p>
<p>Например, давайте рассмотрим функцию <code>sin</code>. Как она должна себя вести при вызове на таблице? Предположим, она возвращает код ошибки. Если бы нам понадобилась проверка на ошибки, мы бы написали что-то вроде</p>
<pre><code>local res = math.sin(x)
if not res then    -- ошибка?
  &lt;код обработки ошибки&gt;</code></pre>
<p>Однако, мы могли бы легко проверить это исключение <em>перед</em> вызовом функции:</p>
<pre><code>if not tonumber(x) then    -- x не является числом?
  &lt;код обработки ошибки&gt;</code></pre>
<p>Часто мы не проверяем ни аргумент, ни результат вызова <code>sin</code>; если аргумент не является числом, значит, вероятно, с нашей программой творится нечто неладное. В подобной ситуации прекратить вычисления и вызвать ошибку — это простейший и наиболее практичный способ обработки данного исключения.</p>
<p>С другой стороны, давайте рассмотрим функцию <code>io.open</code>, которая открывает файл. Как она должна себя вести, если попросить ее прочитать несуществующий файл? В этом случае не существует простого способа проверки на исключение перед вызовом этой функции. Во многих системах единственным способом узнать, что файл существует, является попытка его открыть. Поэтому если <code>io.open</code> не может открыть файл по какой-то внешней причине (например, «файл не существует» или «недостаточно прав»), то она возвращает nil и строку с сообщением об ошибке. Таким образом, у вас есть шанс обработать ситуацию подходящим образом, например, попросив у пользователя другое имя файла:</p>
<pre><code>local file, msg
repeat
  print &quot;enter a file name:&quot;
  local name = io.read()
  if not name then return end    -- ввода данных не было
  file, msg = io.open(name, &quot;r&quot;)
  if not file then print(msg) end
until file</code></pre>
<p>Если вы не хотите обрабатывать подобные ситуации, но по-прежнему хотите перестраховаться, то для защиты данной операции вы можете просто использовать <code>assert</code>:</p>
<pre><code>file = assert(io.open(name, &quot;r&quot;))</code></pre>
<p>Это типичная для Lua идиома: если <code>io.open</code> даст сбой, то <code>assert</code> вызовет ошибку.</p>
<pre><code>file = assert(io.open(&quot;no-file&quot;, &quot;r&quot;))
--&gt; stdin:1: no-file: No such file or directory</code></pre>
<p>Обратите внимание, как сообщение об ошибке, которое является вторым результатом <code>io.open</code>, оказывается вторым аргументом для <code>assert</code>.</p>
<h3 id="Chapter08.xhtml#sigil_toc_id_69">8.5. Обработка ошибок и исключений</h3>
<p>Для многих приложений вам не нужно выполнять никакой обработки ошибок в Lua; этим занимается прикладная программа. Вся работа Lua начинается с вызова от приложения, которое обычно просит выполнить кусок. При любой ошибке этот вызов возвращает код ошибки, чтобы приложение могло предпринять соответствующие действия. В случае автономного интерпретатора его главный цикл лишь печатает сообщение об ошибке, а затем продолжает показывать приглашение ввода и выполнять команды.</p>
<p>Однако, если вам надо обрабатывать ошибки в Lua, вы должны использовать <code>pcall</code> (<em>«protected call» — защищенный вызов</em>) для инкапсуляции вашего кода.</p>
<p>Допустим, вы хотите выполнить фрагмент кода Lua и поймать любую ошибку, вызванную при его выполнении. Вашим первым шагом будет инкапсулировать этот фрагмент кода в функцию; в большинстве случаев для этого используются анонимные функции. Затем вы вызываете эту функцию посредством <code>pcall</code>:</p>
<pre><code>local ok, msg = pcall(function ()
  &lt;какой-нибудь код&gt;
  if unexpected_condition then error() end
  &lt;какой-нибудь код&gt;
  print(a[i])    -- потенциальная ошибка: &#39;a&#39; может не быть таблицей
  &lt;какой-нибудь код&gt;
end)</code></pre>
<pre><code>if ok then    -- при выполнении защищенного кода ошибок нет
&lt;обычный код&gt;
else    -- защищенный код вызвал ошибку: примите соответственные меры
  &lt;код обработки ошибки&gt;
end</code></pre>
<p>Функция <code>pcall</code> вызывает свой первый аргумент в <em>защищенном режиме</em>, чтобы перехватывать любые ошибки во время выполнения функции. Если ошибок нет, то <code>pcall</code> возвращает true и все значения, возвращенные тем вызовом. Иначе она возвращает false и сообщение об ошибке.</p>
<p>Несмотря на свое название, сообщение об ошибке не обязано быть строкой: <code>pcall</code> вернет любое значение Lua, которое вы передали <code>error</code>.</p>
<pre><code>local status, err = pcall(function () error({code=121}) end)
print(err.code)    --&gt; 121</code></pre>
<p>Эти механизмы предоставляют все, что вам необходимо для обработки исключений в Lua. Мы выбрасываем исключение при помощи <code>error</code> и перехватываем его при помощи <code>pcall</code>. Сообщение об ошибке идентифицирует вид ошибки.</p>
<h3 id="Chapter08.xhtml#sigil_toc_id_70">8.6. Сообщения об ошибках и обратные трассировки</h3>
<p>Хотя в качестве сообщения об ошибке мы можем использовать значение любого типа, обычно сообщения об ошибках — это строки, описывающие, что пошло не так. В случае возникновения внутренней ошибки (например, при попытке индексировать нетабличное значение) Lua генерирует сообщение об ошибке; иначе сообщением об ошибке становится значение, переданное функции <code>error</code>. В тех случаях, когда сообщение об ошибке является строкой, Lua пытается добавить некоторую информацию о том месте, где произошла ошибка:</p>
<pre><code>local status, err = pcall(function () a = &quot;a&quot;+1 end)
print(err)
  --&gt; stdin:1: attempt to perform arithmetic on a string value

local status, err = pcall(function () error(&quot;my error&quot;) end)
print(err)
  --&gt; stdin:1: my error</code></pre>
<p>Эта информация о месте ошибки содержит имя файла (в примере это <code>stdin</code>) и номер его строки кода (в примере это 1).</p>
<p>У функции <code>error</code> есть второй дополнительный параметр, который задает <em>уровень</em>, на котором она должна докладывать об ошибке; вы используете этот параметр, чтобы обвинить кого-то другого в случае ошибки. Скажем, вы написали функцию, чьей первой задачей является проверка, что она была правильно вызвана:</p>
<pre><code>function foo (str)
  if type(str) ~= &quot;string&quot; then
    error(&quot;string expected&quot;)
  end
  &lt;обычный код&gt;
end</code></pre>
<p>Затем кто-то вызывает вашу функцию с неправильным аргументом:</p>
<pre><code>foo({x=1})</code></pre>
<p>Если оставить все как есть, Lua покажет на вашу функцию — ведь это же <code>foo</code> вызвала <code>error</code>, — а не на настоящего виновника, который вызвал ее с неправильным аргументом. Для исправления данной проблемы вы информируете <code>error</code>, что ошибка, о которой вы докладываете, возникла на уровне 2 в иерархии вызовов (уровень 1 — это ваша собственная функция):</p>
<pre><code>function foo (str)
  if type(str) ~= &quot;string&quot; then
    error(&quot;string expected&quot;, 2)
  end
  &lt;обычный код&gt;
end</code></pre>
<p>Часто при возникновении ошибки мы хотим получить больше отладочной информации, а не только место возникновения. Как минимум нам нужна обратная трассировка, показывающая полный стек вызовов, приведших к ошибке. Когда <code>pcall</code> возвращает свое сообщение об ошибке, она уничтожает часть стека (часть от нее до момента возникновения ошибки). Следовательно, если нам требуется обратная трассировка, мы должны построить ее до возврата из <code>pcall</code>. Для этого Lua предоставляет функцию <code>xpcall</code>. Кроме функции, которую нужно вызвать, она получает второй аргумент — <em>функцию обработки сообщений</em>. В случае ошибки Lua вызывает этот обработчик сообщений перед раскруткой стека, поэтому он может использовать отладочную библиотеку для получения любой дополнительной информации об ошибке, которая ему потребуется. Двумя наиболее распространенными обработчиками ошибок являются <code>debug.debug</code>, предоставляющий вам приглашение ввода Lua, чтобы вы могли сами посмотреть, что происходило в момент возникновения ошибки; и <code>debug.traceback</code>, который строит расширенное сообщение об ошибке с обратной трассировкой (<span class="underline">Примечание</span>: В главе 24 мы больше узнаем об этих функциях, когда обсудим отладочную библиотеку). Именно последнюю функцию использует автономный интерпретатор для построения своих сообщений об ошибках.</p>
<h3 id="Chapter08.xhtml#sigil_toc_id_71">Упражнения</h3>
<p><strong>Упражнение 8.1.</strong> Часто бывает удобно добавить какой-нибудь префикс к куску кода при его загрузке. (Ранее мы рассматривали пример в данной главе, где мы ставили <strong>return</strong> перед загружаемым выражением.) Напишите функцию <code>loadwithprefix</code>, которая работает как <code>load</code>, за исключением того, что она добавляет свой первый дополнительный аргумент (строку) в качестве префикса для загружаемого куска.</p>
<p>Как и оригинальная <code>load</code>, функция <code>loadwithprefix</code> должна принимать куски, представленные как строками, так и считывающими функциями. Даже в случае, когда изначальный кусок является строкой, <code>loadwithprefix</code> в действительности не должна конкатенировать префикс с куском. Вместо этого она должна вызвать <code>load</code> с соответствующей считывающей функцией, которая сперва возвратит префикс, и лишь затем исходный кусок.</p>
<p><strong>Упражнение 8.2.</strong> Напишите функцию <code>multiload</code>, которая обобщает <code>loadwithprefix</code>, получая список считывающих функций, как в следующем примере:</p>
<pre><code>f = multiload(&quot;local x = 10;&quot;,
              io.lines(&quot;temp&quot;, &quot;*L&quot;),
              &quot; print(x)&quot;)</code></pre>
<p>Для приведенного выше примера <code>multiload</code> должна загрузить кусок, эквивалентный конкатенации строки &quot;<code>local...</code>&quot; с содержимым файла <code>temp</code> и строки &quot;<code>print(х)</code>&quot;. Как и функция <code>loadwithprefix</code> из предыдущего упражнения, данная функция в действительности не должна ничего конкатенировать.</p>
<p><strong>Упражнение 8.3.</strong> Функция <code>string.rep</code> в листинге 8.2 использует алгоритм двоичного умножения для конкатенации <code>n</code> копий заданной строки <code>s</code>. Для любого фиксированного <code>n</code> мы можем создать специализированную версию <code>string.rep</code>, развертывая цикл в последовательность команд <code>r=r..s</code> и <code>s=s..s</code>. В качестве примера для <code>n=5</code> развертка даст нам следующую функцию:</p>
<pre><code>function stringrep_5 (s)
  local r = &quot;&quot;
  r = r .. s
  s = s .. s
  s = s .. s
  r = r .. s
  return r
end</code></pre>
<p>Напишите функцию, которая для заданного <code>n</code> возвращает функцию <code>stringrep_</code><em>n</em>. Вместо использования замыкания ваша функция должна построить текст функции Lua с соответствующей последовательностью команд (<code>r=r..s</code> и <code>s=s..s</code>) и затем использовать <code>load</code> для получения итоговой функции. Сравните быстродействие общей функции <code>string.rep</code> (или замыкания с ее использованием) и вашими заказными функциями.</p>
<p><strong>Листинг 8.2.</strong> Повторение строк</p>
<pre><code>function stringrep (s, n)
  local r = &quot;&quot;
  if n &gt; 0 then
    while n &gt; 1 do
      if n % 2 ~= 0 then r = r .. s end
      s = s .. s
      n = math.floor(n / 2)
    end
    r = r .. s
  end
  return r
end</code></pre>
<p><strong>Упражнение 8.4.</strong> Можете ли вы найти такое значение для <code>f</code>, что выражение <code>pcall(pcall,f)</code> вернет false в качестве своего первого результата?</p>
<p><span id="Chapter09.xhtml"></span></p>
<h2>ГЛАВА 9</h2>
<h2 id="Chapter09.xhtml#sigil_toc_id_72">Сопрограммы</h2>
<p><em>Сопрограмма</em> <strong>(coroutine)</strong> похожа на нить (в смысле многонитевости): это поток выполнения со своим стеком, своими локальными переменными и своим указателем команд; но он разделяет глобальные переменные и почти все остальное с другими сопрограммами. Основное отличие между нитями и сопрограммами — это то, что концептуально (или буквально, в случае многопроцессорной машины) программа с нитями выполняет несколько нитей параллельно. Сопрограммы, с другой стороны, работают совместно: в любой момент времени программа с сопрограммами выполняет только одну из своих сопрограмм, и эта выполняемая сопрограмма приостанавливает свое выполнение, только когда ее явно попросят приостановиться.</p>
<p>Сопрограмма — это очень мощная концепция. И поэтому иногда ее трудно применять. Не волнуйтесь, если вы не поймете некоторые примеры из этой главы при первом чтении. Вы можете дочитать до конца книги и вернуться сюда позже. Но, пожалуйста, вернитесь; ваше время будет потрачено не напрасно.</p>
<h3 id="Chapter09.xhtml#sigil_toc_id_73">9.1. Основы сопрограмм</h3>
<p>Lua пакует все связанные с сопрограммами функции в таблицу <code>coroutine</code>. Функция <code>create</code> создает новые сопрограммы. У нее есть единственный аргумент — функция с кодом, которую сопрограмма будет выполнять. Она возвращает значение типа <code>thread</code>, которое представляет из себя новую сопрограмму. Часто аргументом <code>create</code> является анонимная функция, как показано ниже:</p>
<pre><code>co = coroutine.create(function () print(&quot;hi&quot;) end)

print(co)    --&gt; thread: 0x8071d98</code></pre>
<p>Сопрограмма может быть в одном из четырех состояний: приостановленное — <strong>suspended</strong>, выполняемое — <strong>running</strong>, завершенное — <strong>dead</strong>, обычное — <strong>normal</strong>. Мы можем проверить состояние сопрограммы при помощи функции <code>status</code>:</p>
<pre><code>print(coroutine.status(co))    --&gt; suspended</code></pre>
<p>Когда мы создаем сопрограмму, она запускается в приостановленном состоянии; сопрограмма не начинает автоматически выполнять свое тело при создании. Функция <code>coroutine.resume</code> (пере)запускает выполнение сопрограммы, меняя ее состояние из приостановленного в выполняемое:</p>
<pre><code>coroutine.resume(co)    --&gt; hi</code></pre>
<p>В этом первом примере тело сопрограммы просто печатает &quot;<code>hi</code>&quot; и прекращает выполнение, оставляя сопрограмму в завершенном состоянии, из которого ей уже не вернуться:</p>
<pre><code>print(coroutine.status(co))    --&gt; dead</code></pre>
<p>До сих пор сопрограммы выглядели не более чем усложненным способ вызова функций. Настоящая сила сопрограмм идет от функции <code>yield</code>, которая позволяет выполняемой сопрограмме приостановить свое выполнение (иными словами, <em>уступить управление</em>), чтобы она могла быть возобновлена позже. Давайте рассмотрим простой пример:</p>
<pre><code>co = coroutine.create(function ()
  for i = 1, 10 do
    print(&quot;co&quot;, i)
    coroutine.yield()
  end
end)</code></pre>
<p>Теперь, когда мы возобновляем эту сопрограмму, она начинает свое выполнение и выполняется до первого <code>yield</code>:</p>
<pre><code>coroutine.resume(co)    --&gt; co    1</code></pre>
<p>Если мы проверим ее состояние, то увидим, что данная сопрограмма приостановлена и, следовательно, может быть снова возобновлена:</p>
<pre><code>print(coroutine.status(co))    --&gt; suspended</code></pre>
<p>С точки зрения сопрограммы, вся деятельность, которая происходит, пока сопрограмма приостановлена, происходит внутри вызова <code>yield</code>. Когда мы возобновляем эту сопрограмму, из вызова <code>yield</code> возвращается управление, и сопрограмма продолжает свое выполнение до следующего <code>yield</code> или до своего окончания:</p>
<pre><code>coroutine.resume(co) --&gt; co    2
coroutine.resume(co) --&gt; co    3
  ...
coroutine.resume(co) --&gt; co    10
coroutine.resume(co) -- ничего не печатает</code></pre>
<p>Во время последнего вызова <code>resume</code> тело сопрограммы завершает цикл, а затем возвращает управление без печати чего-либо. Если мы попытаемся возобновить ее снова, то <code>resume</code> вернет false и сообщение об ошибке:</p>
<pre><code>print(coroutine.resume(co))
--&gt; false    cannot resume dead coroutine</code></pre>
<p>Обратите внимание, что <code>resume</code> выполняется в защищенном режиме. Поэтому, если внутри сопрограммы есть какие-либо ошибки, Lua не будет показывать сообщение об ошибке, а просто вернет управление вызову <code>resume</code>.</p>
<p>Когда одна сопрограмма возобновляет другую, она не приостанавливается; в конце концов, мы не можем ее возобновить. Однако, она и не выполняется, так как выполняемой является другая сопрограмма. Поэтому ее собственное состояние мы называем <em>обычным</em>.</p>
<p>Полезным средством в Lua является то, что пара <code>resume</code>—<code>yield</code> может обмениваться данными. Первая <code>resume</code>, у которой нет соответственной ожидающей ее <code>yield</code>, передает свои дополнительные аргументы главной функции сопрограммы:</p>
<pre><code>co = coroutine.create(function (a, b, c)
    print(&quot;co&quot;, a, b, c + 2)
  end)
coroutine.resume(co, 1, 2, 3) --&gt; co    1    2    5</code></pre>
<p>Вызов <code>resume</code> возвращает после true, сообщающего, что нет ошибок, все аргументы, переданные соответственной <code>yield</code>:</p>
<pre><code>co = coroutine.create(function (a,b)
    coroutine.yield(a + b, a - b)
  end)
print(coroutine.resume(co, 20, 10))    --&gt; true    30    10</code></pre>
<p>Аналогично <code>yield</code> возвращает все дополнительные аргументы, переданные в соответственной <code>resume</code>:</p>
<pre><code>co = coroutine.create (function (x)
    print(&quot;co1&quot;, x)
    print(&quot;co2&quot;, coroutine.yield())
  end)
coroutine.resume(co, &quot;hi&quot;)    --&gt; co1    hi
coroutine.resume(co, 4, 5)    --&gt; co2    4    5</code></pre>
<p>Наконец, когда сопрограмма завершается, любые значения, возвращенные ее главной функцией, передаются соответственной <code>resume</code>:</p>
<pre><code>co = coroutine.create(function ()
    return 6, 7
  end)
print(coroutine.resume(co))    --&gt; true    6    7</code></pre>
<p>Обычно мы редко используем все эти средства в одной и той же сопрограмме, но у всех из них есть свое применение.</p>
<p>Для тех, кто уже знает что-то о сопрограммах, важно прояснить некоторые понятия перед тем, как продолжить. Lua предлагает то, что называется <em>асимметричными сопрограммами</em>. Это значит, что у нее есть одна функция для приостановки выполнения сопрограммы и другая функция для возобновления приостановленной сопрограммы. Некоторые другие языки предлагают <em>симметричные сопрограммы</em>, когда есть лишь одна функция для передачи управления от одной сопрограммы к другой.</p>
<p>Некоторые называют асимметричные сопрограммы <em>полусопрограммами</em> (не будучи симметричными, они не являются полноценными <em>со-</em>). Однако, другие используют этот же термин для обозначения ограниченной реализации сопрограмм, где сопрограмма может приостановить свое выполнение, только когда она не вызывает никакую другую функцию, то есть когда у нее нет ожидающих вызовов в ее управляющем стеке. Другими словами, уступить управление может только главное тело такой полусопрограммы. Примером полусопрограмм в этом понимании являются <em>генераторы</em> в Python.</p>
<p>В отличие от разницы между симметричными и асимметричными сопрограммами, разница между сопрограммами и генераторами (в представлении Python) очень глубока; генераторы просто не достаточно мощные, чтобы реализовать некоторые интересные конструкции, которые мы можем писать с полноценными сопрограммами. Lua предлагает полноценные асимметричные сопрограммы. Те, кто предпочитают симметричные сопрограммы, могут реализовать их на основе асимметричных средств Lua. Это не сложная задача. (Фактически каждая передача управления выполняет <code>yield</code>, за которым следует <code>resume</code>.)</p>
<h3 id="Chapter09.xhtml#sigil_toc_id_74">9.2. Каналы и фильтры</h3>
<p>Одним из наиболее хрестоматийных примеров сопрограмм является проблема потребителя <strong>(producer)</strong> и производителя <strong>(consumer)</strong>. <span>Давайте представим, что у нас есть функция, которая постоянно производит значения (например, читает их из файла), и другая функция, которая постоянно потребляет эти значения (например, пишет в другой файл). Обычно эти две функции выглядят следующим образом:</span></p>
<pre><code>function producer ()
  while true do
    local x = io.read()    -- производит новое значение
    send(x)                -- отправляет его потребителю
  end
end

function consumer ()
  while true do
    local x = receive()    -- получает значение от производителя
    io.write(x, &quot;\n&quot;)      -- потребляет его
  end
end</code></pre>
<p>(В этой реализации и производитель, и потребитель выполняются вечно. Но их легко изменить, чтобы они останавливались, когда больше нет данных для обработки.) Задача здесь заключается в том, чтобы сопоставить <code>send</code> с <code>receive</code>. Это типичный образец проблемы «у кого главный цикл». И производитель, и потребитель активны, у обоих есть свои главные циклы, и каждый из них полагает, что другой является вызываемым сервисом. Для этого конкретного примера можно легко изменить структуру одной из функций, развернув ее цикл и сделав ее пассивным агентом. Однако, в других реальных случаях подобное изменение структуры может быть далеко не таким легким.</p>
<p>Сопрограммы предоставляют идеальный механизм для сопоставления производителя с потребителем, поскольку пара <code>resume</code>—<code>yield</code> переворачивает типичное отношение между вызывающим и вызываемым. Когда сопрограмма вызывает <code>yield</code>, она не входит в новую функцию; вместо этого она возвращает управление ожидающему вызову (<code>resume</code>). Аналогично вызов <code>resume</code> не начинает новую функцию, а возвращает вызов <code>yield</code>. Это именно то, что нам нужно для сопоставления <code>send</code> с <code>receive</code> таким образом, чтобы каждый из них действовал так, будто главным является именно он, а второй является подчиненным. Поэтому <code>receive</code> возобновляет производителя, чтобы он мог произвести новое значение, а <code>send</code> посредством <code>yield</code> возвращает это значение обратно потребителю:</p>
<pre><code>function receive ()
  local status, value = coroutine.resume(producer)
  return value
end

function send (x)
coroutine.yield(x)
end</code></pre>
<p>Разумеется, теперь производитель должен быть сопрограммой:</p>
<pre><code>producer = coroutine.create(
  function ()
    while true do
    local x = io.read()    -- производит новое значение
      send(x)
  end
end)</code></pre>
<p>При такой схеме программа начинает с вызова потребителя. Когда потребителю нужен какой-то элемент, он возобновляет работу производителя, который выполняется до тех пор, пока у него не будет элемента для передачи потребителю, а затем останавливается, пока потребитель снова его не возобновит. Таким образом, мы получаем то, что называется схемой, <em>ориентированной на потребителя</em> (<strong>consumer-driven)</strong>. Другим вариантом было бы написать программу с применением схемы, <em>ориентированной на производителя</em> <strong>(producer-driven)</strong>, где потребитель является сопрограммой.</p>
<p>Мы можем расширить эту схему при помощи фильтров, которые являются заданиями, находящимися между производителем и потребителем и выполняющими своего рода преобразование данных. <em>Фильтр</em> — это производитель и потребитель в одно и то же время, поэтому он возобновляет производителя для получения новых значений и посредством <code>yield</code> передает эти преобразованные значения потребителю, В качестве простого примера мы можем добавить к нашему предыдущему коду фильтр, который в начало каждой строки вставляет ее номер. Код приведен в листинге 9.1. Этот последний кусочек просто создает нужные ему компоненты, соединяет их и начинает выполнение итогового потребителя:</p>
<pre><code>p = producer()
f = filter(p)
consumer(f)</code></pre>
<p>Или еще лучше:</p>
<pre><code>consumer(filter(producer()))</code></pre>
<p><strong>Листинг 9.1.</strong> Потребитель и производитель с фильтрами</p>
<pre><code>function receive (prod)
  local status, value = coroutine.resume(prod)
  return value
end

function send (x)
  coroutine.yield(x)
end

function producer ()
  return coroutine.create(function ()
    while true do
      local x = io.read()       -- производит новое значение
      send(x)
    end
  end)
end

function filter (prod)
  return coroutine.create(function ()
    for line = 1, math.huge do
      local x = receive(prod)    -- получает новое значение
      x = string.format(&quot;%5d %s&quot;, line, x)
      send(x)                    -- отправляет его потребителю
    end
  end)
end

function consumer (prod)
  while true do
    local x = receive(prod)      -- получает новое значение
    io.write(x, &quot;\n&quot;)            -- потребляет новое значение
  end
end</code></pre>
<p>Если после прочтения предыдущего примера вы подумали о каналах <strong>(pipe)</strong> в UNIX, то вы не одиноки. В конце концов, сопрограммы — это разновидность (невытесняющей) многонитевости. С каналами каждая задача выполняется в отдельном процессе; с сопрограммами каждая задача <span>выполняется в отдельной сопрограмме. Каналы предоставляют буфер между пишущим (производителем) и читающим (потребителем), поэтому возможна некоторая свобода в их относительных скоростях. Применительно к каналам это важно, поскольку цена переключения между процессами высока. С сопрограммами цена переключения между задачами намного меньше (примерно равна вызову функции), поэтому пишущий и читающий могут идти нога в ногу.</span></p>
<h3 id="Chapter09.xhtml#sigil_toc_id_75">9.3. Сопрограммы как итераторы</h3>
<p>Мы можем рассматривать итераторы на основе цикла в качестве конкретного примера схемы производитель-потребитель: итератор производит элементы, потребляемые телом цикла. Поэтому вполне естественным будет использовать сопрограммы для написания итераторов. Действительно, сопрограммы являются эффективным инструментом для решения этой задачи. Опять же, ключевой особенностью является их способность вывернуть наизнанку отношение между вызывающим и вызываемым. С этой особенностью мы можем писать итераторы, не волнуясь о хранении состояния между последовательными вызовами итератора.</p>
<p>Чтобы проиллюстрировать этот вариант использования, давайте напишем итератор для перебора всех перестановок заданного массива. Написание подобного итератора напрямую не так легко, но несложно будет написать рекурсивную функцию, которая генерирует все эти перестановки. Идея проста: по очереди помещать каждый элемент массива на последнюю позицию и рекурсивно генерировать все перестановки оставшихся элементов. Код приведен в листинге 9.2. Чтобы он сработал, мы должны определить соответствующую функцию <code>printResult</code> и вызвать <code>permgen</code> с подходящими аргументами:</p>
<pre><code>function printResult (a)
  for i = 1, #a do
    io.write(a[i], &quot; &quot;)
  end
  io.write(&quot;\n&quot;)
end

permgen ({1,2,3,4})
--&gt; 2 3 4 1
--&gt; 3 2 4 1
--&gt; 3 4 2 1
  ...
--&gt; 2 1 3 4
--&gt; 1 2 3 4</code></pre>
<p><strong>Листинг 9.2.</strong> Функция для получения всех перестановок из первых <span class="code">n</span> элементов <span class="code">a</span></p>
<pre><code>function permgen (a, n)
  n = n or #a       -- значение &#39;n&#39; по умолчанию — размер &#39;a&#39;
  if n &lt;= 1 then    -- ничего не изменилось?
    printResult(a)
  else
    for i = 1, n do
      -- помещает i-ый элемент как последний
      a[n], a[i] = a[i], a[n]
      -- генерирует все преобразования прочих элементов
      permgen(a, n - 1)
      -- восстанавливает i-ый элемент
      a[n], a[i] = a[i], a[n]
    end
  end
end</code></pre>
<p>Как только генератор готов, преобразовать его в итератор — простая задача. Во-первых, заменим <code>printResult</code> на <code>yield</code>:</p>
<pre><code>function permgen (a, n)
  n = n or #a
  if n &lt;= 1 then
    coroutine.yield(a)
  else
  &lt;как прежде&gt;</code></pre>
<p>Затем мы определяем фабрику, которая делает так, чтобы генератор выполнялся внутри сопрограммы, а затем создаем итерирующую функцию. Для получения следующей перестановки итератор просто возобновляет сопрограмму:</p>
<pre><code>function permutations (a)
  local co = coroutine.create(function () permgen(a) end)
  return function ()    -- итератор
    local code, res = coroutine.resume(co)
    return res
  end
end</code></pre>
<p>Имея в распоряжении такой механизм, перебрать все перестановки массива при помощи оператора <strong>for</strong> не составит труда:</p>
<pre><code>for p in permutations{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;} do
  printResult(p)
end
--&gt; b c a
--&gt; c b a
--&gt; c a b
--&gt; a c b
--&gt; b a c
--&gt; a b c</code></pre>
<p>Функция <code>permutations</code> использует типичную для Lua схему, которая пакует вызов <code>resume</code> с соответственной сопрограммой внутри функции. Эта схема настолько распространена, что Lua предоставляет для нее особую функцию: <code>coroutine.wrap</code>. Как и <code>create</code>, <code>wrap</code> создает новую сопрограмму. В отличие от <code>create</code>, <code>wrap</code> не возвращает саму сопрограмму; вместо этого она возвращает функцию, которая при вызове возобновляет эту сопрограмму. В отличие от исходной <code>resume</code>, она не возвращает код ошибки как свой первый результат; вместо этого при необходимости она вызывает ошибку. Используя <code>wrap</code>, мы можем написать <code>permutations</code> следующим образом:</p>
<pre><code>function permutations (a)
  return coroutine.wrap(function () permgen(a) end)
end</code></pre>
<p>Обычно использовать <code>coroutine.wrap</code> проще, чем <code>coroutine.create</code>. Она дает нам именно то, что нам нужно от сопрограммы: функцию для ее возобновления. Однако, она менее гибкая. Не существует способа проверить состояние сопрограммы, созданной при помощи <code>wrap</code>. Более того, мы не можем проверять на ошибки во время выполнения.</p>
<h3 id="Chapter09.xhtml#sigil_toc_id_76">9.4. Невытесняющая многонитевость</h3>
<p>Как мы видели ранее, сопрограммы обеспечивают разновидность совместной многонитевости. Каждая сопрограмма эквивалентна нити. Пара <code>yield</code>—<code>resume</code> переключает управление с одной нити на другую. Однако, в отличие от обычной многонитевости, сопрограммы не являются вытесняющими. Пока сопрограмма выполняется, она не может быть остановлена извне. Она прерывает свое выполнение, только когда явно запрашивает это (через вызов <code>yield</code>). Для ряда приложений это не является проблемой, скорее наоборот. Программирование гораздо проще в отсутствие вытеснения. Вам не нужно беспокоиться об ошибках синхронизации, поскольку вся синхронизация среди нитей в вашей программе явная. Вам лишь нужно убедиться в том, что сопрограмма вызывает <code>yield</code> вне критической области кода.</p>
<p>Однако, при невытесняющей многонитевости, как только какая-то нить вызывает блокирующую операцию, вся программа блокируется до тех пор, пока эта операция не завершится. Для большинства приложений это недопустимое поведение, которое привело к тому, что многие программисты не рассматривают сопрограммы как альтернативу традиционной многонитевости. Как мы здесь увидим, у этой проблемы есть интересное (и очевидное, если заглянуть в прошлое) решение.</p>
<p>Давайте рассмотрим типичную многонитевую задачу: мы хотим скачать несколько удаленных файлов по HTTP. Для скачивания нескольких удаленных файлов сначала мы должны разобраться, как скачать один удаленный файл. В этом примере мы используем разработанную Диего Нехабом библиотеку <em>LuaSocket</em>. Для скачивания файла сперва нужно установить соединение с его сайтом, отправить запрос на файл, получить этот файл (блоками) и закрыть соединение. На Lua мы можем написать это следующим образом. Для начала мы загружаем библиотеку LuaSocket:</p>
<pre><code>local socket = require &quot;socket&quot;</code></pre>
<p>Затем мы определяем хост и файл, который хотим скачать. В этом примере мы скачаем справочное руководство по HTML 3.2 с сайта консорциума World Wide Web:</p>
<pre><code>host = &quot;www.w3.org&quot;
file = &quot;/TR/REC-html32.html&quot;</code></pre>
<p>Затем мы открываем TCP-соединение с портом 80 (стандартный порт для HTTP-соединений) данного сайта:</p>
<pre><code>c = assert(socket.connect(host, 80))</code></pre>
<p>Эта операция возвращает объект соединения, который мы используем для отправки запроса на получение файла:</p>
<pre><code>c:send(&quot;GET &quot; .. file .. &quot; HTTP/1.0\r\n\r\n&quot;)</code></pre>
<p>Затем мы читаем файл блоками по 1 Кб, записывая каждый блок в стандартный вывод:</p>
<pre><code>while true do
  local s, status, partial = c:receive(2^10)
  io.write(s or partial)
  if status == &quot;closed&quot; then break end
end</code></pre>
<p>Функция <code>receive</code> возвращает или строку, которую прочла, или nil в случае ошибки; в последнем случае она также возвращает код ошибки (<code>status</code>) и что она прочла до ошибки (<code>partial</code>). Когда хост закрывает соединение, мы печатаем оставшиеся входные данные и прерываем цикла приема данных.</p>
<p>После скачивания файла мы закрываем соединение:</p>
<pre><code>c:close()</code></pre>
<p>Теперь, когда мы знаем, как скачать один файл, давайте вернемся к проблеме скачивания нескольких файлов. Простейшим подходом будет скачивать по одному файлу за раз. Однако, этот последовательный подход, когда мы начинаем читать файл только после того, как закончим с предыдущим, слишком медленный. При чтении удаленного файла программа проводит основную часть времени, ожидая прибытия данных. Более точно, она проводит большую часть времени блокированной в вызове <code>receive</code>. Поэтому программа может выполняться гораздо быстрее, если будет скачивать все файлы параллельно. Тогда, когда у соединения нет доступных данных, программа может читать их из другого соединения. Понятно, что сопрограммы предлагают удобный способ для организации этих одновременных скачиваний. Мы создаем новую нить для каждой задачи приема данных. Когда у нити нет доступных данных, она уступает управление простому диспетчеру, который вызывает другую нить.</p>
<p>Чтобы переписать программу с применением сопрограмм, для начала нужно переписать предыдущий код для скачивания как функцию. Результат приведен в листинге 9.3. Поскольку нам не интересно содержимое удаленного файла, функция подсчитывает и печатает размер файла вместо записи файла в стандартный вывод. (С несколькими нитями, читающими сразу несколько файлов, на выходе получилась бы полная мешанина).</p>
<p><strong>Листинг 9.3.</strong> Код для скачивания веб-страницы</p>
<pre><code>function download (host, file)
  local c = assert(socket.connect(host, 80))
  local count = 0 -- counts number of bytes read
  c:send(&quot;GET &quot; .. file .. &quot; HTTP/1.0\r\n\r\n&quot;)
  while true do
    local s, status = receive(c)
    count = count + #s
    if status == &quot;closed&quot; then break end
  end
  c:close()
  print(file, count)
end</code></pre>
<p>В этом новом коде мы используем вспомогательную функцию (<code>receive</code>) для получения данных из соединения. При последовательном подходе код выглядел бы следующим образом:</p>
<pre><code>function receive (connection)
  local s, status, partial = connection:receive(2^10)
  return s or partial, status
end</code></pre>
<p>Для параллельной реализации эта функция должна получать данные без блокирования. Вместо этого, если данных не достаточно, она уступает управление. Ее новый код выглядит следующим образом:</p>
<pre><code>function receive (connection)
  connection:settimeout(0)    -- не блокирует данные
  local s, status, partial = connection:receive(2^10)
  if status == &quot;timeout&quot; then
    coroutine.yield(connection)
  end
  return s or partial, status
end</code></pre>
<p>Вызов <code>settimeout(0)</code> делает любую операцию над соединением неблокирующей. Когда статус операции равен &quot;<code>timeout</code>&quot;, это значит, что операция вернула управление, не выполнив свою задачу. В этом случае нить уступает управление. Отличный от false аргумент, переданный <code>yield</code>, сообщает диспетчеру, что данная нить все еще выполняет свою задачу. Обратите внимание, что даже в случае статуса &quot;<code>timeout</code>&quot; в переменной <code>partial</code> все равно содержатся прочитанные ранее данные, которое возвратило соединение.</p>
<p>Листинг 9.4. содержит код диспетчера и некоторый дополнительный код. Таблица <code>threads</code> содержит список всех активных нитей для диспетчера. Функция <code>get</code> следит за тем, чтобы каждая загрузка выполнялась в отдельной нити. Сам диспетчер в основном является циклом, который перебирает все нити, возобновляя их одну за другой. Также он должен удалять из списка те нити, которые уже завершили свои задачи. Цикл останавливается, когда больше нет нитей для выполнения.</p>
<p><strong>Листинг 9.4.</strong> Диспетчер</p>
<pre><code>threads = {}    -- список всех живых нитей

function get (host, file)
  -- создает сопрограмму
  local co = coroutine.create(function ()
    download(host, file)
  end)
  -- вставляет ее в список
  table.insert(threads, co)
end

function dispatch ()
  local i = 1
  while true do
    if threads[i] == nil then    -- нитей больше нет?
      if threads[1] == nil then break end    -- список пуст?
      i = 1                      -- перезапускает цикл
    end
    local status, res = coroutine.resume(threads[i])
    if not res then              -- нить выполнила свою задачу?
      table.remove(threads, i)
    else
      i = i + 1                  -- перейти к следующей нити
    end
  end
end</code></pre>
<p>Наконец, главная программа создает требуемые нити и вызывает диспетчер. Например, чтобы загрузить четыре документа с сайта W3C, главная программа может выглядеть, как показано ниже:</p>
<pre><code>host = &quot;www.w3.org&quot;

get(host, &quot;/TR/html401/html40.txt&quot;)
get(host, &quot;/TR/2002/REC-xhtml1-20020801/xhtml1.pdf&quot;)
get(host, &quot;/TR/REC-html32.html&quot;)
get(host, &quot;/TR/2000/REC-DOM-Level-2-Core-20001113/DOM2-Core.txt&quot;)

dispatch()    -- главный цикл</code></pre>
<p>Ha моем компьютере скачивание этих четырех файлов с использованием сопрограмм занимает 6 секунд. С последовательным скачиванием это требует в два с половиной раза больше времени (15 секунд).</p>
<p>Несмотря на такой прирост скорости, эта последняя реализация далека от оптимальной. Все работает хорошо до тех пор, пока хотя бы у одной нити есть что читать. Однако, когда ни у одной нити нет данных для чтения, диспетчер находится в активном ожидании, постоянно переключаясь с нити на нить лишь, чтобы убедиться в том, данных у них по-прежнему нет. В результате эта реализация сопрограммы потребляет почти в 30 раз больше процессорного времени, чем последовательная версия.</p>
<p>Чтобы избежать подобного поведения, мы можем использовать функцию <code>select</code> из библиотеки LuaSocket: она позволяет заблокировать программу, находящуюся в ожидании, пока изменится статус в группе сокетов. Изменения в реализации незначительны: нам нужно изменить только диспетчер, как показано в листинге <span>9.5. В цикле новый диспетчер собирает в таблице</span> <code>timedout</code> <span>соединения, у которых превышено время ожидания. (Помните, что</span> <code>receive</code> <span>передает подобные соединения функции</span> <code>yield</code><span>, поэтому вызов</span> <code>resume</code> <span>их возвращает). Если у всех соединений превышено время ожидания, то диспетчер вызывает</span> <code>select</code><span>, чтобы ждать изменения статуса у одного из этих. Эта окончательная реализация работает так же быстро, как и предыдущая с сопрограммами. Более того, без активного ожидания она потребляет лишь немногим больше процессорного времени, чем последовательная реализация.</span></p>
<p><strong>Листинг 9.5.</strong> Диспетчер, использующий <span class="code">select</span></p>
<pre><code>function dispatch ()
  local i = 1
  local timedout = {}
  while true do
    if threads[i] == nil then          -- больше нет нитей?
      if threads[1] == nil then break end
      i = 1                            -- перезапускает цикл
      timedout = {}
    end
    local status, res = coroutine.resume(threads[i])
    if not res then                    -- нить выполнила свою задачу?
      table.remove(threads, i)
    else                               -- превышено время ожидания
      i = i + 1
      timedout[#timedout + 1] = res
      if #timedout == #threads then    -- все нити заблокированы?
        socket.select(timedout)
      end
    end
  end
end</code></pre>
<h3 id="Chapter09.xhtml#sigil_toc_id_77">Упражнения</h3>
<p><strong>Упражнение 9.1.</strong> Используйте сопрограммы для преобразования функции из упражнения 5.4 в генератор для комбинаций, который может быть использован следующим образом:</p>
<pre><code>for c in combinations({&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, 2) do
  printResult(c)
end</code></pre>
<p><strong>Упражнение 9.2.</strong> Реализуйте и запустите код из предыдущего раздела (невытесняющая многонитевость).</p>
<p><strong>Упражнение 9.3.</strong> Реализуйте функцию <code>transfer</code> на Lua. Если подумать о том, что вызовы <code>resume</code>—<code>yeild</code> аналогичны вызову функции и возврату из нее, то эта функция будет как <strong>goto</strong>: она приостанавливает выполняемую сопрограмму и возобновляет любую другую сопрограмму, заданную в качестве аргумента. <span>(Подсказка: используйте что-то вроде</span> <code>dispatch</code> <span>для управления вашими сопрограммами. Тогда</span> <code>transfer</code> <span>уступит управление</span> <code>dispatch</code><span>, сообщая о том, какую следующую сопрограмму нужно выполнять, и</span> <code>dispatch</code> <span>возобновит ее.</span><span>)</span></p>
<p><span id="Chapter10.xhtml"></span></p>
<h2>ГЛАВА 10</h2>
<h2 id="Chapter10.xhtml#sigil_toc_id_78">Законченные примеры</h2>
<p>Чтобы завершить введение в язык, мы покажем три хоть и простых, но законченных примера программ. Первый пример о проблеме восьми королев. Второй является программой частотности слов, которая печатает самые часто встречающиеся слова в тексте. Последний пример — это реализация алгоритма цепи Маркова, описанная Керниганом и Пайком <strong>(Kernighan &amp; Pike)</strong> в их книге <em>«The Practice of Programming»</em> (Addison-Wesley, 1999).</p>
<h3 id="Chapter10.xhtml#sigil_toc_id_79">10.1. Задача о восьми королевах</h3>
<p>Наш первый пример — это очень простая программа, которая решает <em>задачу о восьми королевах</em>: цель состоит в размещении восьми королев на шахматной доске таким образом, чтобы ни одна из королев не могла напасть на другую.</p>
<p>Первый шаг решения данной проблемы состоит в том, чтобы отметить, что у любого правильного решения должно быть ровно по одной королеве в каждой строке. Таким образом, мы можем представить решения при помощи простого массива из восьми чисел, по одному для каждой строки; каждое число сообщает нам, в каком столбце расположена королева из каждой строки. Например, массив <code>{3,7,2,1,8,6,5,4}</code> обозначает, что одна королева находится в строке 1 и столбце 3, другая — в строке 2 и столбце 7 и т. д. (Кстати, это не правильное решение; например, королева в строке 3 и столбце 2 нападает на королеву в строке 4 и столбце 1). Обратите внимание, что любое правильное решение должно быть перестановкой целых чисел от 1 до 8, так как правильное решение также должно содержать по одной королеве в каждом столбце.</p>
<p>Полная программа приведена в листинге 10.1. Первой функцией является <code>isplaceok</code>, которая проверяет, что заданная позиция на доске не может быть атакована ранее размещенными королевами. Зная о том, что по формулировке две королевы не могут находиться на одной строке, функция <code>isplaceok</code> проверяет, что нет других королев в том же столбце или той же диагонали, что у новой позиции.</p>
<p><strong>Листинг 10.1.</strong> Программа «восемь королев»</p>
<pre><code>local N = 8 -- board size

-- проверяет, что позиция (n,c) находится вне атак
local function isplaceok (a, n, c)
  for i = 1, n - 1 do    -- для каждой уже размещенной королевы
    if (a[i] == c) or              -- тот же столбец?
       (a[i] - i == c - n) or      -- та же диагональ?
       (a[i] + i == c + n) then    -- та же диагональ?
      return false       -- позиция может быть атакована
    end
  end
  return true            -- никаких атак; позиция в порядке
end

-- печатает доску
local function printsolution (a)
  for i = 1, N do
    for j = 1, N do
      io.write(a[i] == j and &quot;X&quot; or &quot;-&quot;, &quot; &quot;)
    end
    io.write(&quot;\n&quot;)
  end
  io.write(&quot;\n&quot;)
end

-- добавляет на доску &#39;a&#39; всех королев от &#39;n&#39; до &#39;N&#39;
local function addqueen (a, n)
  if n &gt; N then     -- были размещены все королевы?
    printsolution(a)
  else              -- пытается разместить n-ую королеву
    for c = 1, N do
      if isplaceok(a, n, c) then
        a[n] = c    -- помещает n-ую королеву в столбце &#39;c&#39;
        addqueen(a, n + 1)
      end
    end
  end
end

-- запускает программу
addqueen({}, 1)</code></pre>
<p><span>Далее у нас идет функция</span> <code>printsolution</code><span>, которая печатает доску. Она просто обходит всю доску, печатая '</span><code>X</code><span>' на позициях с королевой и '</span><code>-</code><span>' на других позициях. Каждый результат выглядит примерно так:</span></p>
<pre><code>X - - - - - - -
- - - - X - - -
- - - - - - - X
- - - - - X - -
- - X - - - - -
- - - - - - X -
- X - - - - - -
- - - X - - - -</code></pre>
<p>Последняя функция <code>addqueen</code> является ядром программы. Она применяет отслеживание в обратном порядке для поиска правильных решений. Сначала она проверяет, является ли решение законченным, и если да, то печатает это решение. В противном случае она перебирает все столбцы; для каждого столбца, свободного от атак, программа помещает туда королеву и рекурсивно пытается разместить оставшихся королев.</p>
<p>Наконец, главное тело программы просто вызывает <code>addqueen</code> для начала решения задачи.</p>
<h3 id="Chapter10.xhtml#sigil_toc_id_80">10.2. Самые часто встречающиеся слова</h3>
<p>Наш следующий пример — это простая программа, которая читает текст и печатает самые часто встречающиеся в этом тексте слова.</p>
<p>Главная структура данных этой программы является простой таблицей, которая связывает каждое слово в тексте с его счетчиком частотности. С этой структурой данных у программы есть три основные задачи:</p>
<ul>
<li><span>Прочесть текст, посчитав число вхождений каждого слова.</span></li>
<li><span>Отсортировать список слов в нисходящем порядке по их частотности.</span></li>
<li><span>Напечатать первые <em>n</em></span> <span>элементов отсортированного списка.</span></li>
</ul>
<p>Для чтения текста мы можем использовать итератор <code>allwords</code>, который мы разработали в разделе 7.1. Для каждого прочитанного слова мы увеличиваем его соответствующий счетчик:</p>
<pre><code>local counter = {}
for w in allwords do
  counter[w] = (counter[w] or 0) + 1
end</code></pre>
<p>Обратите внимание на трюк с <strong>or</strong> для обработки неинициализированных счетчиков.</p>
<p>Следующим шагом будет сортировка списка слов. Однако, как внимательный читатель мог заметить, у нас нет списка слов для сортировки! Несмотря на это, его легко создать, используя слова, которые представлены ключами в таблице <code>counter</code>:</p>
<pre><code>local words = {}
for w in pairs(counter) do
  words[#words + 1] = w
end</code></pre>
<p>Как только мы получим этот список, мы можем отсортировать его при помощи предопреленной функции <code>table.sort</code>, которую мы кратко обсуждали в главе 6:</p>
<pre><code>table.sort(words, function (w1, w2)
  return counter[w1] &gt; counter[w2] or
         counter[w1] == counter[w2] and w1 &lt; w2
end)</code></pre>
<p>Слова с наибольшими значениями счетчиков идут первыми; слова с равными значениями счетчиков идут в алфавитном порядке.</p>
<p>Законченная программа приведена в листинге 10.2. Обратите внимание на применение сопрограммы для выворачивания наизнанку итератора <code>auxwords</code>, который использован в следующем цикле. В последнем цикле, печатающем результат, программа считает, что ее первый аргумент — это число слов, которое нужно напечатать, и по умолчанию использует значение 10, если аргументов передано не было.</p>
<p><strong>Листинг 10.2.</strong> Программа «частотность слов»</p>
<pre><code>local function allwords ()
  local auxwords = function ()
    for line in io.lines() do
      for word in string.gmatch(line, &quot;%w+&quot;) do
        coroutine.yield(word)
      end
    end
  end
  return coroutine.wrap(auxwords)
end

local counter = {}
for w in allwords() do
  counter[w] = (counter[w] or 0) + 1
end

local words = {}
for w in pairs(counter) do
  words[#words + 1] = w
end

table.sort(words, function (w1, w2)
  return counter[w1] &gt; counter[w2] or
         counter[w1] == counter[w2] and w1 &lt; w2
end)

for i = 1, (tonumber(arg[1]) or 10) do
  print(words[i], counter[words[i]])
end</code></pre>
<h3 id="Chapter10.xhtml#sigil_toc_id_81">10.3. Алгоритм цепи Маркова</h3>
<p>Наш последний пример — это реализация <em>алгоритма цепи Маркова</em>. Программа генерирует псевдослучайный текст на основании того, какие слова могут следовать за последовательностью из <em>n</em> предыдущих слов в базовом тексте. Для этой реализации мы будем считать, что <em>n</em> равно 2.</p>
<p>Первая часть читает базовый текст и строит таблицу, которая для каждого префикса из двух слов дает список всех слов, которые в тексте следуют за этим префиксом. После построения таблицы программа использует ее для генерации случайного текста, где каждое слово следует за двумя предыдущими с той же вероятностью, что и в базовом тексте. В результате мы получаем случайный на вид текст. Например, применив эту программу к английскому тексту данной книги, мы получим фрагменты вроде <em>«Constructors can also traverse a table constructor, then the parentheses in the following line does the whole file in a field n to store the contents of each function, but to show its only argument. If you want to find the maximum element in an array can return both the maximum value and continues showing the prompt and running the code. The following words are reserved and cannot be used to convert between degrees and radians»</em>.</p>
<p>Мы будем кодировать каждый префикс при помощи его двух слов, соединенных посредством пробела:</p>
<pre><code>function prefix (w1, w2)
  return w1 .. &quot; &quot; .. w2
end</code></pre>
<p>Мы воспользуемся строкой <code>NOWORD</code> (перевод строки) для инициализации префиксных слов и обозначения конца текста. Например, для текста &quot;<code>the more we try the more we do</code>&quot; таблица последующих слов выглядела бы таким образом:</p>
<pre><code>{ [&quot;\n \n&quot;]    = {&quot;the&quot;},
  [&quot;\n the&quot;]   = {&quot;more&quot;},
  [&quot;the more&quot;] = {&quot;we&quot;, &quot;we&quot;},
  [&quot;more we&quot;]  = {&quot;try&quot;, &quot;do&quot;},
  [&quot;we try&quot;]   = {&quot;the&quot;},
  [&quot;try the&quot;]  = {&quot;more&quot;},
  [&quot;we do&quot;]    = {&quot;\n&quot;},
}</code></pre>
<p>Программа хранит свою таблицу в переменной <code>statetab</code>. Для вставки нового слова в список префиксов данной таблицы, мы используем следующую функцию:</p>
<pre><code>function insert (index, value)
  local list = statetab[index]
  if list == nil then
    statetab[index] = {value}
  else
    list[#list + 1] = value
  end
end</code></pre>
<p>Сначала она проверяет, есть ли уже у данного префикса список; если нет, то создает новый список с новым значением. В противном случае она вставляет новое значение в конец существующего списка.</p>
<p>Для построения таблицы <code>statetab</code> мы будем использовать две переменные <code>w1</code> и <code>w2</code>, содержащие два последних прочитанных слова. Для каждого нового прочитанного слова мы добавляем его к списку, связанному с <code>w1</code> и <code>w2</code>, а затем обновляем <code>w1</code> и <code>w2</code>.</p>
<p>После построения таблицы программа начинает генерировать текст, состоящий из <code>MAXGEN</code> слов. Для начала она заново инициализирует переменные <code>w1</code> и <code>w2</code>. Затем для каждого префикса она наугад выбирает следующее слово из списка допустимых последующих слов, печатает это слово и обновляет <code>w1</code> и <code>w2</code>. Листинги 10.3 и 10.4 содержат законченную программу. В отличие от нашего предыдущего примера с наиболее часто встречающимися словами, здесь мы используем реализацию <code>allwords</code>, основанную на замыканиях.</p>
<p><strong>Листинг 10.3.</strong> Вспомогательные определения для программы «цепь Маркова»</p>
<pre><code>function allwords ()
  local line = io.read()    -- текущая строка
  local pos = 1             -- текущая позиция в строке
  return function ()        -- итерирующая функция
    while line do           -- повторяет, пока есть строки
      local s, e = string.find(line, &quot;%w+&quot;, pos)
      if s then                          -- словой найдено?
        pos = e + 1                      -- обновляет следующую позицию
        return string.sub(line, s, e)    -- возвращает слово
      else
        line = io.read()    -- слово не найдено; пробует следующую строку
        pos = 1             -- перезапуск с первой позиции
      end
    end
    return nil              -- строк больше нет; конец обхода
  end
end

function prefix (w1, w2)
  return w1 .. &quot; &quot; .. w2
end

local statetab = {}

function insert (index, value)
  local list = statetab[index]
  if list == nil then
    statetab[index] = {value}
  else
    list[#list + 1] = value
  end
end</code></pre>
<p><strong>Листинг 10.4.</strong> Программа «цепь Маркова»</p>
<pre><code>local N = 2
local MAXGEN = 10000
local NOWORD = &quot;\n&quot;

-- строит таблицу
local w1, w2 = NOWORD, NOWORD
for w in allwords() do
  insert(prefix(w1, w2), w)
  w1 = w2; w2 = w;
end
insert(prefix(w1, w2), NOWORD)

-- генирирует текст
w1 = NOWORD; w2 = NOWORD     -- новая инициализация
for i = 1, MAXGEN do
  local list = statetab[prefix(w1, w2)]
  -- наугад выбирает элемент из списка
  local r = math.random(#list)
  local nextword = list[r]
  if nextword == NOWORD then return end
  io.write(nextword, &quot; &quot;)
  w1 = w2; w2 = nextword
end</code></pre>
<h3 id="Chapter10.xhtml#sigil_toc_id_82">Упражнения</h3>
<p><strong>Упражнение 10.1.</strong> Измените программу с восьмью королевами, чтобы она останавливалась после печати первого решения.</p>
<p><strong>Упражнение 10.2.</strong> Альтернативной реализацией задачи о восьми королевах было бы построение всех возможных перестановок чисел от 1 до 8 и проверка на правильность для каждой такой перестановки. Измените программу с применением этого подхода. Как отличается быстродействие новой программы по сравнению со старой? (Подсказка: сравните полное число перестановок с числом раз, когда исходная программа вызывает функцию <code>isplaceok</code>.)</p>
<p><strong>Упражнение 10.3.</strong> Когда мы применяем программу частотности слов к тексту, то обычно самыми часто встречаемыми словами оказываются короткие неинтересные слова вроде артиклей и предлогов. Измените программу так, чтобы она пропускала слова, состоящие менее чем из четырех букв.</p>
<p><strong>Упражнение 10.4.</strong> Обобщите алгоритм цепи Маркова так, чтобы он мог использовать любой размер для последовательности предыдущих слов, используемой при выборе следующего слова.</p>
<p><span id="Part2.xhtml"></span></p>
<div style="text-align: center; padding: 0pt; margin: 0pt;">
<h1>Часть II</h1>
<h1 id="Part2.xhtml#sigil_toc_id_83" class="part">Таблицы и объекты</h1>
<svg xmlns="http://www.w3.org/2000/svg" height="75%" preserveaspectratio="xMidYMid meet" version="1.1" viewbox="0 0 1400 1300" width="100%" xlink="http://www.w3.org/1999/xlink">

</svg>
</div>
<p><span id="Chapter11.xhtml"></span></p>
<h2>ГЛАВА 11</h2>
<h2 id="Chapter11.xhtml#sigil_toc_id_84">Структуры данных</h2>
<p>Таблицы в Lua — это не одна из структур данных, — это <em>единственная</em> структура данных. Все структуры, которые предлагают другие языки, — массивы, записи, списки, очереди, множества — могут быть представлены в Lua при помощи таблиц. Главное, таблицы Lua эффективно реализуют все эти структуры.</p>
<p>В традиционных языках, таких как С и Pascal, мы реализуем большинство структур данных при помощи массивов и списков (где списки = записи + указатели). Хотя мы можем реализовать массивы и списки при помощи таблиц Lua (и иногда мы это делаем), таблицы гораздо мощнее массивов и списков; многие алгоритмы с использованием таблиц становятся до банальности простыми. Например, мы редко пишем алгоритм поиска в Lua, поскольку таблицы предоставляют прямой доступ к любому типу.</p>
<p>Требуется некоторое время, чтобы понять, как эффективно использовать таблицы. В этой главе я покажу, как реализовать типичные структуры данных при помощи таблиц, и приведу некоторые примеры их использования. Мы начнем с массивов и списков не потому, что они понадобятся нам для других структур, а потому, что большинство программистов уже знакомы с ними. Мы уже знакомы с азами данного материала в главах о языке, но я также повторю их здесь для полноты.</p>
<h3 id="Chapter11.xhtml#sigil_toc_id_85">11.1. Массивы</h3>
<p>Мы реализуем массивы в Lua, просто индексируя таблицы целыми числами. Таким образом, массивы не имеют фиксированного размера и растут по мере необходимости. Обычно при инициализации массива мы неявно определяем его размер. Например, после выполнения следующего кода любая попытка обратиться к полю вне диапазона 1—1000 вернет nil вместо 0:</p>
<pre><code>a = {}     -- новый массив
for i = 1, 1000 do
  a[i] = 0
end</code></pre>
<p>Операция длины ('<code>#</code>') использует данный факт для нахождения размера массива:</p>
<pre><code>print(#a)    --&gt; 1000</code></pre>
<p>Вы можете начать массив с нуля, единицы или любого другого значения:</p>
<pre><code>-- создает массив с индексами от -5 до 5
a = {}
for i = -5, 5 do
  a[i] = 0
end</code></pre>
<p>Однако, в Lua принято начинать массивы с индекса 1. Библиотеки Lua придерживаются этой традиции, как и операция длины. Если ваши массивы не начинаются с 1, то вы не сможете использовать данные средства.</p>
<p>Мы можем использовать конструктор для создания и инициализации массивов в едином выражении:</p>
<pre><code>squares = {1, 4, 9, 16, 25, 36, 49, 64, 81}</code></pre>
<p>Подобные конструкторы могут быть настолько большими, насколько это нужно (по крайней мере, до нескольких миллионов элементов).</p>
<h3 id="Chapter11.xhtml#sigil_toc_id_86">11.2. Матрицы и многомерные массивы</h3>
<p>Есть два основных способа представления матриц в Lua. Первый — это использовать массив массивов, то есть таблицу, каждый элемент которой является другой.таблицей. Например, вы можете создать матрицу из нулей размером <code>N</code> на <code>M</code> при помощи следующего кода:</p>
<pre><code>mt = {}         -- создает матрицу
for i = 1, N do
  mt[i] = {}    -- создает новую строку
  for j = 1, M do
    mt[i][j] = 0
  end
end</code></pre>
<p>Поскольку таблицы являются объектами в Lua, для создания матрицы вы должны явно создавать каждую строку. С одной стороны, это определенно более громоздко, чем просто объявить матрицу, как это делается в языках С и Pascal. С другой стороны, это дает больше гибкости. Например, вы можете создать треугольную матрицу, изменив цикл <code>for j=1,M do ... end</code> в предыдущем примере на <code>for j=1,i do ... end</code>. С этим кодом треугольная матрица использует лишь половину памяти по сравнению с исходной.</p>
<p>Второй способ представления матриц в Lua заключается в объединении двух индексов в один. Если оба индекса являются целыми числами, то вы можете просто умножить первый на соответствующую константу и затем добавить второй индекс. С этим подходом следующий код создаст нашу матрицу из нулей размером <code>N</code> на <code>M</code>:</p>
<pre><code>mt = {}    -- создает матрицу
for i = 1, N do
  for j = 1, M do
    mt[(i - 1)*M + j] = 0
  end
end</code></pre>
<p>Если индексы являются строками, то вы можете создать один индекс, соединив эти строки с некоторым символом между ними. Например, вы можете индексировать матрицу <code>m</code> со строковыми индексами <code>s</code> и <code>t</code> при помощи кода <code>m[s..&quot;:&quot;..t]</code>, при условии, что и <code>s</code>, и <code>t</code> не содержат двоеточия; в противном случае пары вроде <code>(&quot;а:&quot;,&quot;b&quot;)</code> и <code>(&quot;а&quot;,&quot;:b&quot;)</code> сольются в один индекс &quot;<code>а::b</code>&quot;. Когда сомневаетесь, можете использовать управляющий символ вроде '<code>\0</code>' для разделения индексов.</p>
<p>Довольно часто приложения используют <em>разреженную матрицу</em>, то есть матрицу, где большинство элементов — ноль или nil. Например, вы можете представить граф при помощи его матрицы смежности, в которой значение на позиции <code>m,n</code></code> равно <code>х</code>, если между узлами <code>m</code> и <code>n</code> есть соединение ценой <code>х</code>. Когда эти узлы не соединены, то значение на позиции <code>m,n</code> равно nil. Чтобы представить граф с десятью тысячами узлов, где каждый узел имеет около пяти соседей, вам нужна матрица со ста миллионами элементов (квадратная матрица из 10 000 столбцов и 10 000 строк), но только примерно пятьдесят тысяч из них будут не равны nil (пять ненулевых столбцов для каждой строки, соответствующих пяти соседям каждого узла). Многие книги по структурам данных пространно обсуждают, как можно реализовать подобные разреженные матрицы, не тратя на них 400 Мб памяти, но вам редко понадобятся эти приемы при программировании на Lua. Так как массивы представлены таблицами, они могут быть разрежены естественным образом. С нашим первым представлением (таблица таблиц) вам понадобятся десять тысяч таблиц, каждая из которых содержит около пяти элементов, то есть всего около пятидесяти тысяч элементов. Со <span>вторым представлением у вас будет одна таблица с пятьюдесятью тысячами элементов. Независимо от представления, вам понадобится память только для элементов, отличных от nil.</span></p>
<p>При работе с разреженными матрицами мы не можем использовать операцию длины из-за дырок (значений nil) между активными элементами. Однако, это не большая потеря; даже если бы мы могли его использовать, то делать этого не стоило бы. Для большинства операций было бы крайне неэффективно перебирать все эти пустые элементы. Вместо этого мы можем использовать <code>pairs</code> для обхода только элементов, отличных от nil. Например, чтобы умножить строку на константу, мы можем использовать следующий код:</p>
<pre><code>function mult (a, rowindex, k)
  local row = a[rowindex]
  for i, v in pairs(row) do
    row[i] = v * k
  end
end</code></pre>
<p>Однако, примите к сведению, что у ключей нет внутреннего порядка в таблице, поэтому итерация при помощи <code>pairs</code> не гарантирует, что мы посетим все столбцы по возрастанию. Для некоторых задач (вроде нашего предыдущего примера) это не проблема. Для других задач вы можете использовать альтернативный подход, например, связанные списки.</p>
<h3 id="Chapter11.xhtml#sigil_toc_id_87">11.3. Связанные списки</h3>
<p>Поскольку таблицы являются динамическими сущностями, то реализовать связанные списки в Lua довольно легко. Каждый узел представлен таблицей, а ссылки являются просто полями таблицы, которые содержат ссылки на другие таблицы. Например, давайте реализуем базовый список, где каждый узел содержит два поля, <code>next</code> и <code>value</code>. Корнем списка является простая переменная:</p>
<pre><code>list = nil</code></pre>
<p>Для вставки элемента со значением <code>v</code> в начало списка, мы делаем:</p>
<pre><code>list = {next = list, value = v}</code></pre>
<p>Для перебора списка мы пишем:</p>
<pre><code>local l = list
while l do
  &lt;проверить l.value&gt;
  l = l.next
end</code></pre>
<p>Другие разновидности списков, например двунаправленные или кольцевые списки, также легко реализуются. Однако, подобные структуры вам редко понадобятся в Lua, поскольку обычно есть более простой способ представления ваших данных без использования связанных списков. Например, мы можем представить стек в виде (неограниченного) массива.</p>
<h3 id="Chapter11.xhtml#sigil_toc_id_88">11.4. Очереди и двойные очереди</h3>
<p>Простейшим способом реализации очередей в Lua является использование функций <code>insert</code> и <code>remove</code> из библиотеки <code>table</code>. Эти функции вставляют и удаляют элементы из произвольной позиции массива, сдвигая остальные элементы для согласования действий. Однако, подобные перемещения могут быть дорогими для больших структур. Более эффективная реализация использует две индекса, один для первого элемента и один для последнего:</p>
<pre><code>function ListNew ()
  return {first = 0, last = -1}
end</code></pre>
<p>Во избежание загрязнения глобального пространства имен мы определим все операции со списком внутри таблицы, которую мы соответственно назовем <code>List</code> (таким образом, мы создадим <em>модуль</em>). Тогда мы перепишем наш последний пример следующим образом:</p>
<pre><code>List = {}
function List.new ()
  return {first = 0, last = -1}
end</code></pre>
<p>Теперь мы можем вставлять и удалять элементы с обоих концов за постоянное время:</p>
<pre><code>function List.pushfirst (list, value)
  local first = list.first - 1
  list.first = first
  list[first] = value
end

function List.pushlast (list, value)
  local last = list.last + 1
  list.last = last
  list[last] = value
end

function List.popfirst (list)
  local first = list.first
  if first &gt; list.last then error(&quot;list is empty&quot;) end
  local value = list[first]
  list[first] = nil     -- чтобы разрешить сборку мусора
  list.first = first + 1
  return value
end

function List.poplast (list)
  local last = list.last
  if list.first &gt; last then error(&quot;list is empty&quot;) end
  local value = list[last]
  list[last] = nil     -- чтобы разрешить сборку мусора
  list.last = last - 1
  return value
end</code></pre>
<p>Если вы будете использовать эту структуру для обслуживания в порядке поступления, вызывая только <code>pushlast</code> и <code>popfirst</code>, то и <code>first</code>, и <code>last</code> будут постоянно расти. Однако, так как мы представляем массивы в Lua при помощи таблиц, вы можете индексировать их как с 1 до 20, так и с 16 777 216 до 16 777 236. Поскольку Lua использует для представления чисел двойную точность, ваша программа можем выполняться на протяжении двухсот лет, делая по миллиону вставок в секунду, прежде чем возникнет проблема с переполнением.</p>
<h3 id="Chapter11.xhtml#sigil_toc_id_89">11.5. Множества и мультимножества</h3>
<p>Предположим, вы хотите составить список всех идентификаторов, используемых в программе; каким-то образом вам нужно отфильтровывать зарезервированные слова при составлении вашего списка. Некоторые программисты на С могут поддаться искушению представить множество зарезервированных слов в виде массива строк и затем для проверки обыскивать этот массив, чтобы узнать, есть ли заданное слово в этом множестве. Чтобы ускорить поиск, для представления множества они даже могут воспользоваться бинарным деревом.</p>
<p>В Lua эффективным и простым способом представить такие множества будет поместить их элементы в таблицу в качестве <em>индексов</em>. Тогда вместо поиска заданного элемента в таблице вы всего лишь индексируете эту таблицу и проверяете, равен ли полученный результат nil. В нашем примере мы могли бы написать следующий код:</p>
<pre><code>reserved = {
  [&quot;while&quot;] = true,     [&quot;end&quot;] = true,
  [&quot;function&quot;] = true,  [&quot;local&quot;] = true,
}

for w in allwords() do
  if not reserved[w] then
    &lt;сделать что-нибудь с &#39;w&#39;&gt;    -- &#39;w&#39; — не зарезервированное слово
  end
end</code></pre>
<p>(Поскольку эти слова зарезервированы в Lua, мы не можем использовать их в качестве идентификаторов; например, мы не можем написать <code>while=true</code>. Вместо этого мы пишем <code>[&quot;while&quot;]=true</code>.)</p>
<p>Вы можете получить более понятную инициализацию при помощи дополнительной функции для построения множества:</p>
<pre><code>function Set (list)
  local set = {}
  for _, l in ipairs(list) do set[l] = true end
  return set
end

reserved = Set{&quot;while&quot;, &quot;end&quot;, &quot;function&quot;, &quot;local&quot;, }</code></pre>
<p><em>Мультимножество</em> <strong>(bag)</strong> отличается от обычных множеств тем, что каждый элемент может встречаться несколько раз. Простое представление мультимножеств в Lua похоже на предыдущее представление для множеств, но для каждого ключа есть связанный с ним счетчик. Чтобы вставить элемент, мы увеличиваем его счетчик на единицу:</p>
<pre><code>function insert (bag, element)
  bag[element] = (bag[element] or 0) + 1
end</code></pre>
<p>Для удаления элемента мы уменьшаем его счетчик на единицу:</p>
<pre><code>function remove (bag, element)
  local count = bag[element]
  bag[element] = (count and count &gt; 1) and count - 1 or nil
end</code></pre>
<p>Мы храним счетчик, только если он уже существует и по-прежнему больше нуля.</p>
<h3 id="Chapter11.xhtml#sigil_toc_id_90">11.6. Строковые буферы</h3>
<p>Допустим, вы строите строку по частям, например, построчно читая файл. Ваш код выглядел бы примерно следующим образом:</p>
<pre><code>local buff = &quot;&quot;
for line in io.lines() do
  buff = buff .. line .. &quot;\n&quot;
end</code></pre>
<p>Несмотря на его безобидный вид, этот код может сильно ударить по быстродействию для больших файлов: например, чтение файла размером 1 Мб занимает 1,5 минуты на моем старом Пентиуме (<span class="underline">Примечание</span>: «Мой старый Пентиум» — это компьютер с одноядерным 32-битовым Pentium частотой 3 ГГц. Все данные о быстродействии в этой книге получены на нем).</p>
<p>Почему так? Чтобы понять, что происходит, представим, что мы находимся в середине цикла чтения; каждая строка из файла состоит из 20 байтов, и мы уже прочли 2 500 этих строк, поэтому <code>buff</code> — это строка размером 50 Кб. Когда Lua соединяет <code>buff..line..&quot;\n</code>&quot;; она выделяет новую строку размером 50 020 байт и копирует 50 000 байт из <code>buff</code> в эту новую строку. Таким образом, для каждой новой строки из файла Lua перемещает в памяти примерно 50 Кб, и этот размер только растет. Более точно, этот алгоритм имеет квадратичную сложность. После прочтения 100 новых строк (всего 2 Кб) из файла Lua уже переместил более 2 Мб памяти. Когда Lua завершит чтение 350 Кб, он переместит более 50 Гб. (Эта проблема свойственна не только Lua: другие языки, где строки неизменяемы, также сталкиваются с подобной проблемой. Наиболее известным примером такого языка является Java).</p>
<p>Прежде чем мы продолжим, необходимо заметить, что, несмотря на все сказанное, данная ситуация не является распространенной проблемой. Для маленьких строк вышеприведенный цикл отлично работает. Для чтения всего файла Lua предоставляет опцию <code>io.read(&quot;*а&quot;)</code>, с которой файл читается за один раз. Однако, иногда от этой проблемы никуда не деться. Для борьбы с ней Java использует структуру <code>stringBuffer</code>. В Lua в качестве строкового буфера мы можем использовать таблицу. В основе этого подхода лежит функция <code>table.concat</code>, которая возвращает результат конкатенации всех строк из заданного списка. При помощи <code>concat</code> мы можем переписать наш предыдущий цикл следующим образом:</p>
<pre><code>local t = {}
for line in io.lines() do
  t[#t + 1] = line .. &quot;\n&quot;
end
local s = table.concat(t)</code></pre>
<p>Этот алгоритм требует менее 0,5 секунды для чтения того же самого файла, которому требовалась почти минута с первоначальным кодом. (Несмотря на это, для чтения всего файла по-прежнему лучше использовать <code>io.read</code> с опцией &quot;<code>*а</code>&quot;.)</p>
<p>Можно сделать еще лучше. Функция <code>concat</code> принимает второй необязательный аргумент, который является разделителем для вставки между строками. С этим разделителем нам не нужно вставлять перевод строки после каждой из них:</p>
<pre><code>local t = {}
for line in io.lines() do
  t[#t + 1] = line
end
s = table.concat(t, &quot;\n&quot;) .. &quot;\n&quot;</code></pre>
<p>Функция <code>concat</code> вставляет разделитель между строками, но нам все равно нужно добавить один последний перевод строки. Эта последняя конкатенация копирует итоговую строку, что может быть довольно долго. Не существует опции, чтобы добиться от <code>concat</code> вставки дополнительного разделителя, но мы можем обмануть ее, добавив в <code>t</code> лишнюю пустую строку:</p>
<pre><code>t[#t + 1] = &quot;&quot;
s = table.concat(t, &quot;\n&quot;)</code></pre>
<p>Дополнительный перевод строки, который <code>concat</code> добавит перед пустой строкой, будет находиться в конце итоговой строки, как мы и хотели.</p>
<h3 id="Chapter11.xhtml#sigil_toc_id_91">11.7. Графы</h3>
<p>Как и любой практичный язык, Lua предлагает ряд реализаций для графов, каждый из которых лучше приспособлен под какие-то специфические алгоритмы. Здесь мы рассмотрим простую объектно-ориентированную реализацию, в которой мы будем представлять узлы как объекты (ну разумеется, таблицы), а ребра как ссылки между узлами.</p>
<p>Мы будем представлять каждый узел как таблицу с двумя полями: <code>name</code> — имя узла, и <code>adj</code> — множество соседних с ним узлов. Поскольку мы будем читать граф из текстового файла, нам будет нужен способ найти узел по его имени. Для этого мы будем использовать дополнительную таблицу, отображающую имена на узлы. Функция <code>name2node</code> возвращает узел, получив его имя:</p>
<pre><code>local function name2node (graph, name)
  local node = graph[name]
  if not node then
    -- узел не существует; создадим новый узел
    node = {name = name, adj = {}}
    graph[name] = node
  end
  return node
end</code></pre>
<p>Листинг 11.1 содержит функцию, которая строит граф. Она читает файл, где каждая строка содержит имена двух узлов, тем самым обозначая ребро от первого узла ко второму. Для каждой строки она использует <code>string.match</code>, чтобы разбить строку на два имени, а затем находит соответствующие этим именам узлы (создавая эти узлы при необходимости) и соединяет их.</p>
<p><strong>Листинг 11.1.</strong> Чтение графа из файла</p>
<pre><code>function readgraph ()
  local graph = {}
  for line in io.lines() do
    -- делит строку на два имени
    local namefrom, nameto = string.match(line, &quot;(%S+)%s+(%S+)&quot;)
    -- находит соответственные узлы
    local from = name2node(graph, namefrom)
    local to = name2node(graph, nameto)
    -- добавляет &#39;to&#39; к смежному множеству &#39;from&#39;
    from.adj[to] = true
  end
  return graph
end</code></pre>
<p>Листинг 11.2 иллюстрирует алгоритм с применением подобных графов. Функция <code>findpath</code> ищет путь между двумя узлами при помощи обхода графов в глубину. Ее первый параметр — это текущий узел; второй задает целевой узел; третий параметр хранит путь от начала к текущему узлу; последний параметр — это множество всех уже посещенных узлов (чтобы избежать циклов). Обратите внимание, как алгоритм напрямую работает с узлами, избегая использования их имен. Например, <code>visited</code> — это множество узлов, а не имен узлов. Аналогично <code>path</code> — это список узлов.</p>
<p><strong>Листинг 11.2.</strong> Нахождение пути между двумя узлами</p>
<pre><code>function findpath (curr, to, path, visited)
  path = path or {}
  visited = visited or {}
  if visited[curr] then     -- узел уже посетили?
    return nil              -- пути здесь нет
  end
  visited[curr] = true      -- помечает узел как посещенный
  path[#path + 1] = curr    -- добавляет его к пути
  if curr == to then        -- конечный узел?
    return path
  end
  -- пробует все соседние узлы
  for node in pairs(curr.adj) do
    local p = findpath(node, to, path, visited)
    if p then return p end
  end
  path[#path] = nil         -- удаляет узел из пути
end</code></pre>
<p>Для проверки этого кода мы добавим функцию, которая печатает путь, и дополнительный код, чтобы это все заработало:</p>
<pre><code>function printpath (path)
  for i = 1, #path do
    print(path[i].name)
  end
end

g = readgraph()
a = name2node(g, &quot;a&quot;)
b = name2node(g, &quot;b&quot;)
p = findpath(a, b)
if p then printpath(p) end</code></pre>
<h3 id="Chapter11.xhtml#sigil_toc_id_92">Упражнения</h3>
<p><strong>Упражнение 11.1.</strong> Измените реализацию очереди так, чтобы оба индекса возвращались на ноль, когда очередь пуста.</p>
<p><strong>Упражнение 11.2.</strong> Повторите упражнение 10.3, но вместо использования длины в качестве критерия для отбрасывания слов данная программа должна прочесть из текстового файла список отбрасываемых слов.</p>
<p><strong>Упражнение 11.3.</strong> Измените структуру графа так, чтобы она хранила метку для каждого ребра. Данная структура также должна представлять каждое ребро при помощи объекта с двумя полями: его меткой и узлом, на который он указывает. Вместо множества соседних узлов каждый узел должен хранить множество соседних ребер, берущих начало из этого узла.</p>
<p>Адаптируйте функцию <code>readgraph</code> так, чтобы она из каждой строки входного файла читала два имени узлов и метку. (Допустим, что метка является числом).</p>
<p><strong>Упражнение 11.4.</strong> Предположим, представление графа из предыдущего упражнения устроено так, что метка каждого ребра представляет собой расстояние между его конечными узлами. Напишите функцию, которая находит кратчайший путь между двумя заданными узлами. (Подсказка: используйте алгоритм Дейкстры.)</p>
<p><span id="Chapter12.xhtml"></span></p>
<h2>ГЛАВА 12</h2>
<h2 id="Chapter12.xhtml#sigil_toc_id_93">Файлы с данными и сохраняемость</h2>
<p>При обработке файлов с данными обычно гораздо проще писать эти данные, чем их читать. Когда мы пишем в файл, мы полностью контролируем все, что происходит. С другой стороны, когда мы читаем из файла, то мы не знаем, чего ждать. Помимо обработки всех видов данных, которые могут содержаться в правильном файле, устойчивая программа также должна достойно справляться с дефектными файлами. Поэтому написание устойчивых к ошибкам программ для чтения данных всегда сложно.</p>
<p>В этой главе мы увидим, как можно использовать Lua, чтобы избавиться от лишнего кода для чтения данных в наших программах, просто записывая данные в подходящем формате.</p>
<h3 id="Chapter12.xhtml#sigil_toc_id_94">12.1. Файлы с данными</h3>
<p>Конструкторы таблиц представляют интересную альтернативу файловым форматам. С небольшой доработкой записи данных чтение становится пустяком. Подход заключается в том, чтобы писать наш файл в виде кода Lua, который при выполнении создает необходимые данные для нашей программы. С конструкторами таблиц эти куски кода могут выглядеть удивительно похожими на простые файлы с данными.</p>
<p>Как обычно, чтобы стало понятнее, давайте рассмотрим пример. Если у нашего файла с данными предопределенный формат, такой как CSV (Comma-Separated Values — значения, разделенные запятыми) или XML, то наш выбор крайне мал. Однако, если мы хотим создать файл для нашего собственного использования, то мы в качестве нашего формата можем использовать конструкторы Lua. В этом формате мы представляем каждый элемент данных в виде конструктора Lua. Вместо записи в наш файл чего-то вроде</p>
<pre><code>Donald E. Knuth,Literate Programming,CSLI,1992
Jon Bentley,More Programming Pearls,Addison-Wesley,1990</code></pre>
<p>мы пишем:</p>
<pre><code>Entry{&quot;Donald E. Knuth&quot;,
      &quot;Literate Programming&quot;,
      &quot;CSLI&quot;,
      1992}

Entry{&quot;Jon Bentley&quot;,
      &quot;More Programming Pearls&quot;,
      &quot;Addison-Wesley&quot;,
      1990}</code></pre>
<p>Вспомним, что <code>Entry{</code><em>код</em><code>}</code> — это то же самое, что и <code>Entry({</code><em>код</em><code>))</code>, то есть вызов функции <code>Entry</code> с таблицей в качестве единственного аргумента. Поэтому вышеприведенный фрагмент данных является программой Lua. Для чтения этого файла нам лишь нужно выполнить его, имея подходящее определение для <code>Entry</code>. Например, следующая программа считает число записей в файле с данными:</p>
<pre><code>local count = 0
function Entry () count = count + 1 end
dofile(&quot;data&quot;)
print(&quot;number of entries: &quot; .. count)</code></pre>
<p>Следующая программа создает множество из всех имен авторов, найденных в файле, и печатает их (не обязательно в том же порядке, что и в файле):</p>
<pre><code>local authors = {}    -- множество для хранения имен авторов
function Entry (b) authors[b[1]] = true end
dofile(&quot;data&quot;)
for name in pairs(authors) do print(name) end</code></pre>
<p>Обратите внимание на событийно-ориентированный подход в этих фрагментах кода: <code>Entry</code> выступает в роли функции обратного вызова, которая вызывается во время работы <code>dofile</code> для каждой записи в файле с данными.</p>
<p>Когда нас не волнует размер файла, мы можем в качестве нашего представления использовать пары имя-значение (<span class="underline">Примечание</span>: Если этот формат напоминает вам BibTeX, то это не случайность. Формат BibTeX послужил одним из прототипов для синтаксиса конструкторов в Lua):</p>
<pre><code>Entry{
  author = &quot;Donald E. Knuth&quot;,
  title = &quot;Literate Programming&quot;,
  publisher = &quot;CSLI&quot;,
  year = 1992
}

Entry{
  author = &quot;Jon Bentley&quot;,
  title = &quot;More Programming Pearls&quot;,
  year = 1990,
  publisher = &quot;Addison-Wesley&quot;,
}</code></pre>
<p>Этот формат мы называем <em>форматом самоописываемых данных</em>, поскольку каждый фрагмент данных содержит краткое описание своего значения. Самоописываемые данные более читаемы (по крайней мере, людьми), чем CSV или другие компактные форматы; при необходимости их легко отредактировать вручную; и они позволяют нам вносить небольшие изменения в базовый формат, не требуя изменять файлы с данными. Например, если мы добавим новое поле, то нам потребуется внести лишь небольшое изменение в читающую программу, чтобы она предоставляла значение по умолчанию, когда поле не указано.</p>
<p>При помощи формата имя-значение наша программа для составления списка авторов становится следующей:</p>
<pre><code>local authors = {}    -- множество для хранения имен авторов
function Entry (b) authors[b.author] = true end
dofile(&quot;data&quot;)
for name in pairs(authors) do print(name) end</code></pre>
<p>Теперь порядок полей не важен. Даже если у некоторых записей нет автора, то нам понадобится изменить лишь функцию <code>Entry</code>:</p>
<pre><code>function Entry (b)
  if b.author then authors[b.author] = true end
end</code></pre>
<p>Lua не только быстро выполняется, но и быстро компилируется. Например, вышеприведенная программа для составления списка авторов обрабатывает 1 Мб данных за одну десятую секунды. (<span class="underline">Примечание</span>: На моем старом Пентиуме.) И это не случайно. Описание данных было одной из главных областей применения Lua с момента его создания, и мы уделяем огромное внимание тому, чтобы его компилятор работал быстро для больших программ.</p>
<h3 id="Chapter12.xhtml#sigil_toc_id_95">12.2. Сериализация</h3>
<p>Часто нам нужно сериализовать какие-то данные, то есть перевести эти данные в поток байтов или символов, чтобы мы могли сохранить их в файл или послать по сети. Мы можем представлять сериализованные данные в виде кода Lua так, чтобы при выполнении этого кода он воссаздавал сохраненные значения для считывающей программы.</p>
<p>Обычно если мы хотим восстановить значение глобальной переменной, то наш кусок кода будет чем-то вроде <code>varname =</code> <em>выражение</em> , где <em>выражение</em> — это код на Lua для получения значения. С <code>varname</code> все просто, поэтому давайте посмотрим, как написать код, который создает значение. Для числового значения задача проста:</p>
<pre><code>function serialize (o)
  if type(o) == &quot;number&quot; then
    io.write(o)
  else &lt;прочие случаи&gt;
  end
end</code></pre>
<p>Тем не менее, при записи числа в десятичном виде есть риск потерять точность. В Lua 5.2 можно использовать шестнадцатеричный формат, чтобы избежать подобной проблемы:</p>
<pre><code>if type(o) == &quot;number&quot; then
  io.write(string.format(&quot;%a&quot;, o))</code></pre>
<p>С этим форматом (&quot;<code>%а</code>&quot;) прочитанное число будет состоять ровно из тех же битов, что и исходное.</p>
<p>Для строкового значения наивный подход выглядел бы примерно так:</p>
<pre><code>if type(o) == &quot;string&quot; then
  io.write(&quot;&#39;&quot;, o, &quot;&#39;&quot;)</code></pre>
<p>Однако, если строка содержит специальные символы (такие как кавычки или переводы строк), то итоговый код уже не будет допустимой программой Lua.</p>
<p>Может показаться заманчивым решить эту проблему путем изменения вида кавычек:</p>
<pre><code>if type(o) == &quot;string&quot; then
  io.write(&quot;[[&quot;, o, &quot;]]&quot;)</code></pre>
<p>Но так делать не стоит. Если какой-то пользователь со злым умыслом сумеет заставить вашу программу сохранить что-то вроде &quot; <code>]]..os.execute('rm *')..[[</code> &quot; (например, передав данную строку в качестве своего адреса), то в результате вашим куском кода будет</p>
<pre><code>varname = [[ ]]..os.execute(&#39;rm *&#39;)..[[ ]]</code></pre>
<p>При попытке загрузить эти «данные» вас ждет неприятный сюрприз.</p>
<p>Простым и безопасным способом заключить строку в кавычки будет использование опции &quot;<code>%q</code>&quot; из функции <code>string.format</code>. Она окружает строку двойными кавычками и корректно экранирует двойные кавычки, переводы строк и некоторые другие символы внутри этой строки:</p>
<pre><code>a = &#39;a &quot;problematic&quot; \\string&#39;
print(string.format(&quot;%q&quot;, a))    --&gt; &quot;a \&quot;problematic\&quot; \\string&quot;</code></pre>
<p>С данной возможностью наша функция <code>serialize</code> теперь выглядит следующим образом:</p>
<pre><code>function serialize (o)
  if type(o) == &quot;number&quot; then
    io.write(o)
  elseif type(o) == &quot;string&quot; then
    io.write(string.format(&quot;%q&quot;, o))
  else &lt;прочие случаи&gt;
  end
end</code></pre>
<p>Начиная с версии 5.1 Lua предлагает другой вариант для безопасного заключения произвольных строк в кавычки — при помощи записи <code>[=[...]=]</code> для длинных строк. Однако, эта новая запись в основном предназначена для собственноручно написанного кода, когда мы в любом случае не хотим изменять строковые литерала. В автоматически генерируемом коде легче экранировать проблематичные символы, как это делает опция &quot;<code>%q</code>&quot; из <code>string.format</code>.</p>
<p>Если же вы все равно хотите использовать длинностроковую запись для автоматически генерируемого кода, то вам нужно позаботиться о некоторых деталях. Первая деталь состоит в том, что вам нужно подобрать правильное число знаков равенства. Подходящее число — то, которое больше максимальной длины их последовательности в исходной строке. Поскольку строки, содержащие длинные цепочки из знаков равенства, не являются редкостью (например, комментарии, разделяющие фрагменты исходного кода), мы можем ограничиться рассмотрением последовательностей знаков равенства, заключенных между квадратными скобками; другие последовательности не могут привести к ошибочному маркеру конца строки. Второй деталью является то, что Lua всегда отбрасывает перевод строки в начале длинной строки; простым методом борьбы с этим является добавление перевода строки, который будет отброшен.</p>
<p><strong>Листинг 12.1.</strong> Заключение в кавычки произвольных строковых литералов</p>
<pre><code>function quote (s)
  -- находит максимальную длину последовательностей из знаков равенства
  local n = -1
  for w in string.gmatch(s, &quot;]=*]&quot;) do
    n = math.max(n, #w - 2)    -- -2 для удаления всех &#39;]&#39;
  end

  -- производит строку с &#39;n&#39; плюс один знаков равенства
  local eq = string.rep(&quot;=&quot;, n + 1)

  -- строит строку в кавычках
  return string.format(&quot; [%s[\n%s]%s] &quot;, eq, s, eq)
end</code></pre>
<p>Функция <code>quote</code> из листинга 12.1 является результатом наших предыдущих замечаний. Она принимает произвольную строку и возвращает ее отформатированной как длинную строку. Вызов <code>string.gmatch</code> создает итератор для перебора всех последовательностей образца '<code>]=*]'</code> (то есть закрывающей квадратной скобки, после которой стоит последовательность из ноля или больше знаков равенства, за которыми следует еще одна закрывающая квадратная скобка) в строке <code>s</code>. (<span class="underline">Примечание</span>: Мы обсудим сопоставление с образцом в главе 21.) Для каждого вхождения цикл обновляет <code>n</code> до максимального на данный момент числа знаков равенства. После этого цикла мы используем функцию <code>string.rep</code>, чтобы повторить знак равенства <code>n+1</code> раз, то есть на один знак больше, чем у максимальной последовательности, встреченной в этой строке. Наконец, <code>string.format</code> заключает <code>s</code> между парами квадратных скобок с надлежащим числом знаков равенства внутри и добавляет дополнительные пробелы вокруг помещаемой в кавычки строки и перевод строки в начале содержащей ее строки.</p>
<h4 id="Chapter12.xhtml#sigil_toc_id_96">Сохранение таблиц без циклов</h4>
<p>Нашей следующей (и более сложной) задачей является сохранение таблиц. Существует несколько способов сохранения их в соответствии с тем, какие ограничения мы накладываем на структуру таблицы. Не существует одного алгоритма, который бы подходил для всех случаев. Дело не только в том, что простым таблицам нужны более простые алгоритмы, но и в том, что получающиеся при этом файлы могут быть более наглядны.</p>
<p><span>Наша следующая попытка представлена в листинге 12.2. Несмотря на свою простоту, эта функция довольно практична. Она даже обрабатывает вложенные таблицы (то есть таблицы внутри других таблиц) до тех пор, пока структура таблицы является деревом (то есть не содержит общих подтаблиц и циклов). Небольшим визуальным улучшением будет добавление отступов к иногда встречающимся вложенным таблицам (см. упражнение 12.1).</span></p>
<p><strong>Листинг 12.2.</strong> Сериализация таблиц без циклов</p>
<pre><code>function serialize (o)
  if type(o) == &quot;number&quot; then
    io.write(o)
  elseif type(o) == &quot;string&quot; then
    io.write(string.format(&quot;%q&quot;, o))
  elseif type(o) == &quot;table&quot; then
    io.write(&quot;{\n&quot;)
    for k,v in pairs(o) do
      io.write(&quot; &quot;, k, &quot; = &quot;)
      serialize(v)
      io.write(&quot;,\n&quot;)
    end
    io.write(&quot;}\n&quot;)
  else
    error(&quot;cannot serialize a &quot; .. type(o))
  end
end</code></pre>
<p>Предыдущая функция предполагает, что все ключи в таблице являются допустимыми идентификаторами. Если в таблице есть числовые ключи или строковые ключи, которые не являются синтаксически допустимыми идентификаторами в Lua, то у нас проблема. Простым путем ее разрешения является использование следующего кода для записи каждого ключа:</p>
<pre><code>io.write(&quot; [&quot;); serialize(k); io.write(&quot;] = &quot;)</code></pre>
<p>С этим изменением мы увеличили надежность нашей функции за счет наглядности получающегося файла. Рассмотрим следующий вызов:</p>
<pre><code>serialize{a=12, b=&#39;Lua&#39;, key=&#39;another &quot;one&quot;&#39;}</code></pre>
<p>Результат этого вызова при использовании первой версии <code>serialize</code> будет следующим:</p>
<pre><code>{
  a = 12,
  b = &quot;Lua&quot;,
  key = &quot;another \&quot;one\&quot;&quot;,
}</code></pre>
<p>Сравните с результатом при использовании второй версии:</p>
<pre><code>{
  [&quot;a&quot;] = 12,
  [&quot;b&quot;] = &quot;Lua&quot;,
  [&quot;key&quot;] = &quot;another \&quot;one\&quot;&quot;,
}</code></pre>
<p>Мы можем получить и надежность, и наглядность, проверяя в каждом конкретном случае необходимость квадратных скобок; и вновь мы оставим это улучшение в качестве упражнения.</p>
<h4 id="Chapter12.xhtml#sigil_toc_id_97">Сохранение таблиц с циклами</h4>
<p>Для обработки таблиц с общей топологией (то есть с циклами и общими подтаблицами) нам потребуется другой подход. Конструкторы не могут представлять подобные таблицы, поэтому мы их и не будем <span>использовать. Для представления циклов нам нужны имена, поэтому наша следующая функция в качестве аргументов получит значение, которое следует сохранить, и имя. Более того, мы должны отслеживать имена уже сохраненных таблиц, чтобы переиспользовать их при обнаружении цикла. Для этого отслеживания мы воспользуемся дополнительной таблицей. Эта таблица будет содержать таблицы в качестве индексов и их имена в качестве связанных с ними значений.</span></p>
<p><strong>Листинг 12.3.</strong> Сохранение таблиц с циклами</p>
<pre><code>function basicSerialize (o)
  if type(o) == &quot;number&quot; then
    return tostring(o)
  else    -- предположим, что это строка
    return string.format(&quot;%q&quot;, o)
  end
end

function save (name, value, saved)
  saved = saved or {}                     -- начальное значение
  io.write(name, &quot; = &quot;)
  if type(value) == &quot;number&quot; or type(value) == &quot;string&quot; then
    io.write(basicSerialize(value), &quot;\n&quot;)
  elseif type(value) == &quot;table&quot; then
    if saved[value] then                  -- значение уже сохранено?
      io.write(saved[value], &quot;\n&quot;)        -- использует его прежнее имя
    else
      saved[value] = name                 -- сохраняет имя для другого раза
      io.write(&quot;{}\n&quot;)                    -- создает новую таблицу
      for k,v in pairs(value) do          -- сохраняет ее поля
        k = basicSerialize(k)
        local fname = string.format(&quot;%s[%s]&quot;, name, k)
        save(fname, v, saved)
      end
    end
  else
    error(&quot;cannot save a &quot; .. type(value))
  end
end</code></pre>
<p>Итоговый код показан в листинге 12.3 . Мы придерживаемся ограничения, что таблицы, которые мы хотим сохранить, содержат лишь числа и строки в качестве ключей. Функция <code>basicSerialize</code> сериализует эти базовые типы, возвращая результат. Следующая функция, <code>save</code>, выполняет всю тяжелую работу. Параметр <code>saved</code> — это таблица, которая отслеживает уже сохраненные таблицы. Например, если мы построим таблицу так</p>
<pre><code>a = {x=1, y=2; {3,4,5}}
a[2] = a      -- цикл
a.z = a[1]    -- общая подтаблица</code></pre>
<p>то вызов <code>save(&quot;а&quot;, а)</code> сохранит ее следующим образом:</p>
<pre><code>a = {}
a[1] = {}
a[1][1] = 3
a[1][2] = 4
a[1][3] = 5

a[2] = a
a[&quot;y&quot;] = 2
a[&quot;x&quot;] = 1
a[&quot;z&quot;] = a[1]</code></pre>
<p>Порядок этих присваиваний может меняться, так как он зависит от обхода таблицы. Тем не менее, алгоритм следит за тем, чтобы любой предыдущий узел, необходимый для нового определения, был определен заранее.</p>
<p>Если мы хотим сохранить несколько значений с общими частями, то мы можем сделать несколько вызовов <code>save</code> при помощи той же таблицы <code>saved</code>. Например, предположим, у нас есть следующие две таблицы:</p>
<pre><code>a = {{&quot;one&quot;, &quot;two&quot;}, 3}
b = {k = a[1]}</code></pre>
<p>Если мы сохраним их независимо друг от друга, то у результата не будет общих частей:</p>
<pre><code>save(&quot;a&quot;, a)
save(&quot;b&quot;, b)

  --&gt; a = {}
  --&gt; a[1] = {}
  --&gt; a[1][1] = &quot;one&quot;
  --&gt; a[1][2] = &quot;two&quot;
  --&gt; a[2] = 3
  --&gt; b = {}
  --&gt; b[&quot;k&quot;] = {}
  --&gt; b[&quot;k&quot;][1] = &quot;one&quot;
  --&gt; b[&quot;k&quot;][2] = &quot;two&quot;</code></pre>
<p>Однако, если мы используем ту же самую таблицу <code>saved</code> для обоих вызовов <code>save</code>, то у результата будут общие части:</p>
<pre><code>local t = {}
save(&quot;a&quot;, a, t)
save(&quot;b&quot;, b, t)

  --&gt; a = {}
  --&gt; a[1] = {}
  --&gt; a[1][1] = &quot;one&quot;
  --&gt; a[1][2] = &quot;two&quot;
  --&gt; a[2] = 3
  --&gt; b = {}
  --&gt; b[&quot;k&quot;] = a[1]</code></pre>
<p>Как принято в Lua, есть несколько других вариантов. Они позволяют сохранять значение без выдачи ему глобального имени (например, кусок строит локальное значение и возвращает его), обрабатывать функции (путем построения вспомогательной таблицы, связывающей каждую функцию с ее именем) и т. д. Lua дает вам силу; механизмы строите вы.</p>
<h3 id="Chapter12.xhtml#sigil_toc_id_98">Упражнения</h3>
<p><strong>Упражнение 12.1.</strong> Измените код из листинга 12.2, чтобы он добавлял отступы ко вложенным таблицам.</p>
<p>(Подсказка: добавьте дополнительный параметр к <code>serialize</code> в виде строки с отступом.)</p>
<p><strong>Упражнение 12.2.</strong> Измените код из листинга 12.2, чтобы он использовал синтаксис <code>[&quot;key&quot;] =</code><em>value</em> так, как предложено в разделе 12.1.</p>
<p><strong>Упражнение 12.3.</strong> Измените код предыдущего упражнения так, чтобы он использовал синтаксис <code>[&quot;key&quot;]=</code><em>value</em>, только при необходимости (то есть когда ключ в виде строки не является допустимым идентификатором).</p>
<p><strong>Упражнение 12.4.</strong> Измените код предыдущего упражнения, чтобы он использовал синтаксис конструкторов для списков везде, где это возможно. Например, он должен сериализовать таблицу <code>{14,15,19}</code> как <code>{14,15,19}</code>, а не как <code>{[1]=14,[2]=15,[3]=19}</code>. <span>(Подсказка: начните с сохранения значений ключей 1, 2,...,</span> <span>если только они не равны nil. Позаботьтесь о том, чтобы не сохранить их снова при переборе остальной части таблицы.)</span></p>
<p><strong>Упражнение 12.5.</strong> Подход с отказом от конструкторов при сохранении таблиц с циклами слишком радикальный. Можно сохранить таблицу в более приятном виде, применяя конструкторы в общем случае, а затем используя присваивания только для исправления общего доступа и циклов.</p>
<p>Заново реализуйте функцию <code>save</code> с использованием данного подхода. Добавьте к ней все вкусности, что вы уже реализовали в предыдущих упражнениях (оступы, синтаксис записей и синтаксис списков).</p>
<p><span id="Chapter13.xhtml"></span></p>
<h2>ГЛАВА 13</h2>
<h2 id="Chapter13.xhtml#sigil_toc_id_99">Метатаблицы и метаметоды</h2>
<p>Обычно для каждого значения в Lua есть вполне предсказуемый набор операций. Мы можем складывать числа, соединять строки, вставлять пары ключ-значение в таблицы и т. д. Однако, мы не можем складывать таблицы, сравнивать функции и вызывать строку. Если только мы не используем метатаблицы.</p>
<p>Метатаблицы позволяют изменить поведение значения при его встрече с неожиданной операцией. Например, при помощи метатаблиц мы можем определить то, как Lua вычисляет выражение <code>а+b</code>, где <code>а</code> и <code>b</code> — это таблицы. Когда Lua пытается сложить две таблицы, он проверяет, есть ли хотя бы в одной из них <em>метатаблица</em> и содержит ли эта метатаблица поле <code>__add</code>. Если Lua находит <span>это поле, он вызывает соответствующее значение — так называемый <em>метаметод</em>, который должен быть функцией, — для вычисления суммы.</span></p>
<p>Каждое значение в Lua может иметь связанную с ним метатаблицу. У таблиц и пользовательских данных отдельные метатаблицы; значения остальных типов совместно используют одну единственную метатаблицу для всех значений своего типа. Lua всегда создает новые таблицы без метатаблиц:</p>
<pre><code>t = {}
print(getmetatable(t))    --&gt; nil</code></pre>
<p>Мы можем использовать функцию <code>setmetatable</code>, чтобы задать или изменить метатаблицу для любой таблицы:</p>
<pre><code>t1 = {}
setmetatable(t, t1)
print(getmetatable(t) == t1)    --&gt; true</code></pre>
<p>Из Lua мы можем устанавливать метатаблицы только для таблиц; для работы с метатаблицами значений других типов мы должны использовать код С (<span class="underline">Примечание</span>: Главная причина этого ограничения состоит в том, чтобы помешать злоупотреблению метатаблиц для распространенных типов. Опыт предыдущих версий Lua показал, что подобные глобальные изменения часто ведут к одноразовому коду). Как мы позже увидим в главе 21, строковая библиотека устанавливает метатаблицу для строк. У всех прочих типов по умолчанию нет метатаблиц:</p>
<pre><code>print(getmetatable(&quot;hi&quot;))      --&gt; table: 0x80772e0
print(getmetatable(&quot;xuxu&quot;))    --&gt; table: 0x80772e0
print(getmetatable(10))        --&gt; nil
print(getmetatable(print))     --&gt; nil</code></pre>
<p>Любая таблица может быть метатаблицей для любого значения; группа связанных между собой таблиц может совместно использовать общую метатаблицу, которая описывает их общее поведение; таблица может быть метатаблицей для самой себя, таким образом описывая свое собственное индивидуальное поведение. Допустимо использовать любую схему.</p>
<h3 id="Chapter13.xhtml#sigil_toc_id_100">13.1. Арифметические метаметоды</h3>
<p>В этом разделе мы приведем простой пример, чтобы объяснить, как использовать метатаблицы. Пусть мы используем таблицы для представления множеств с функциями для вычисления их объединения, пересечения и т. п., как показано в листинге 13.1. Чтобы не засорять наше пространство имен, мы будем хранить эти функции в таблице <code>Set</code>.</p>
<p><strong>Листинг 13.1.</strong> Простая реализация множеств</p>
<pre><code>Set = {}

-- создает новое множество со значениями из заданного списка
function Set.new (l)
  local set = {}
  for _, v in ipairs(l) do set[v] = true end
  return set
end

function Set.union (a, b)
  local res = Set.new{}
  for k in pairs(a) do res[k] = true end
  for k in pairs(b) do res[k] = true end
  return res
end

function Set.intersection (a, b)
  local res = Set.new{}
  for k in pairs(a) do
  res[k] = b[k]
  end
  return res
end

-- представляет множество как строку
function Set.tostring (set)
  local l = {} -- list to put all elements from the set
  for e in pairs(set) do
    l[#l + 1] = e
  end
  return &quot;{&quot; .. table.concat(l, &quot;, &quot;) .. &quot;}&quot;
end

-- печатает множество
function Set.print (s)
  print(Set.tostring(s))
end</code></pre>
<p>Теперь нам нужно использовать операцию сложения ('<code>+</code>') для вычисления объединения двух множеств. Для этого мы дадим возможнось всем таблицам, представляющим множества, использовать одну общую метатаблицу. Эта метатаблица определит, как таблицы должны реагировать на операцию сложения. Нашим первым шагом будет создание обычной таблицы, которую мы будем использовать как метатаблицу для множеств:</p>
<pre><code>local mt = {}    -- метатаблица для множеств</code></pre>
<p>Следующим шагом будет изменение функции <code>Set.new</code>, создающей множества. В новой версии этой функции будет лишь одна дополнительная строка, которая для создаваемых таблиц устанавливает <code>mt</code> как метатаблицу:</p>
<pre><code>function Set.new (l)    -- вторая версия
  local set = {}
  setmetatable(set, mt)
  for _, v in ipairs(l) do set[v] = true end
  return set
end</code></pre>
<p>После этого каждое множество, которое мы создадим при помощи <code>Set.new</code>, будет иметь одну и ту же таблицу в качестве метатаблицы:</p>
<pre><code>s1 = Set.new{10, 20, 30, 50}
s2 = Set.new{30, 1}
print(getmetatable(s1)) --&gt; table: 00672B60
print(getmetatable(s2)) --&gt; table: 00672B60</code></pre>
<p>Наконец, мы добавим к метатаблице метаметод в виде поля <code>__add</code>, кото<span>рое определяет, как нужно выполнять сложение:</span></p>
<pre><code>mt.__add = Set.union</code></pre>
<p>После этого каждый раз, когда Lua попытается сложить два множества, он будет вызывать функцию <code>Set.union</code>, передавая оба операнда в качестве аргументов.</p>
<p>С метаметодом мы можем использовать операцию сложения для выполнения объединения множеств:</p>
<pre><code>s3 = s1 + s2
Set.print(s3)    --&gt; {1, 10, 20, 30, 50}</code></pre>
<p>Аналогично мы можем определить операцию умножения для выполнения пересечения множеств:</p>
<pre><code>mt.__mul = Set.intersection
Set.print((s1 + s2)*s1)    --&gt; {10, 20, 30, 50}</code></pre>
<p>Для каждой арифметической операции существует соответствующее имя поля в метатаблице. Кроме <code>__add</code> и <code>__mul</code> есть <code>__sub</code> <span>(для вычитания),</span> <code>__div</code> <span>(для деления),</span> <code>__unm</code> <span>(для отрицания),</span> <code>__mod</code> <span>(для взятия остатка от деления) и</span> <code>__pow</code> <span>(для возведения в степень). Мы также можем определить поле</span> <code>__concat</code> <span>для описания поведения опе</span><span>рации конкатенации.</span></p>
<p>Когда мы складываем два множества, то вопрос о том, какую метатаблицу использовать, не возникает. Однако, мы можем записать выражение, в котором участвуют два значения с разными метатаблицами, например такое, как ниже:</p>
<pre><code>s = Set.new{1,2,3}
s = s + 8</code></pre>
<p>При поиске метаметода Lua выполняет следующие шаги: если у первого значения есть метатаблица с полем <code>__add</code>, то Lua использует это поле в качестве метаметода независимо от второго значения; иначе, если у второго значения есть метатаблица с полем <code>__add</code>, Lua использует его поле в качестве метаметода; в противном случае Lua вызовет ошибку. Таким образом, в последнем примере будет вызвана <code>Set.union</code>, как и для выражений <code>10+s</code> и <code>&quot;hello&quot;+s</code>.</p>
<p>Lua не беспокоится об этих смешанных типах, но они важны для нашей реализации. Например, если мы выполним <code>s=s+8</code>, то получим ошибку внутри <code>Set.union</code>:</p>
<pre><code>bad argument #1 to &#39;pairs&#39; (table expected, got number)</code></pre>
<p>Если нам нужны более понятные сообщения об ошибках, то мы должны явно проверять типы операндов перед попыткой выполнения операции:</p>
<pre><code>function Set.union (a, b)
  if getmetatable(a) ~= mt or getmetatable(b) ~= mt then
    error(&quot;attempt to &#39;add&#39; a set with a non-set value&quot;, 2)
  end
  &lt;как прежде&gt;</code></pre>
<p>Помните, что второй аргумент функции <code>error</code> (2 в нашем случае) направляет сообщение об ошибке туда, где данная операция была вызвана.</p>
<h3 id="Chapter13.xhtml#sigil_toc_id_101">13.2. Метаметоды сравнения</h3>
<p>Метатаблицы также позволяют придать смысл операциям сравнения посредством метаметодов <code>__eq</code> (<em>равно</em>), <code>__lt</code> (<em>меньше, чем</em>) и <code>__lе</code> (<em>меньше или равно, чем</em>). Для трех оставшихся операций сравнения нет отдельных метаметодов: Lua переводит <code>а~=b</code> в <code>not(а==b)</code>, <code>а&gt;b</code> в <code>b&lt;а</code> и <code>а&gt;=b</code> в <code>b&lt;=а</code>.</p>
<p>До версии 4.0 Lua переводил все операции упорядочивания в одну, переводя <code>а&lt;=b</code> в <code>not(b&lt;а)</code>. Однако, такой перевод некорректен, когда мы имеем дело с <em>частичным порядком</em>, то есть когда не все элементы нашего типа надлежащим образом упорядочены. Например, числа с плавающей точкой не являются полностью упорядоченными на большинстве компьютеров из-за значения <em>NaN</em> (<em>Not a Number</em> — не число). В соответствии со стандартом IEEE 754 NaN представляет неопределенные значения, такие как результат <code>0/0</code>. Согласно стандарту, любое сравнение, включающее в себя NaN, должно быть ложным. Это значит, что <code>NaN&lt;=x</code> всегда ложно, но и <code>x&lt;=NaN</code> также ложно. Из этого также следует, что перевод <code>а&lt;=b</code> в <code>not(b&lt;a)</code> в данном случае неверен.</p>
<p>В нашем примере с множествами мы имеем дело с похожей проблемой. Очевидным (и полезным) значением <code>&lt;=</code> для множеств является вхождение множества: <code>а&lt;=b</code> означает, что <code>а</code> — это подмножество <code>b</code>. С этим значением все равно возможно, что <code>а&lt;=b</code> и <code>b&lt;а</code> ложны; таким образом, нам нужны отдельные реализации для <code>__lе</code> (<em>меньше или равно</em>) и <code>__lt</code> (<em>меньше, чем</em>):</p>
<pre><code>mt.__le = function (a, b)    -- вхождение множеств
  for k in pairs(a) do
    if not b[k] then return false end
  end
  return true
end

mt.__lt = function (a, b)
return a &lt;= b and not (b &lt;= a)
end</code></pre>
<p>Наконец, мы можем определить равенство множеств через их вхождение:</p>
<pre><code>mt.__eq = function (a, b)
  return a &lt;= b and b &lt;= a
end</code></pre>
<p>После этих определений мы готовы сравнивать множества:</p>
<pre><code>s1 = Set.new{2, 4}
s2 = Set.new{4, 10, 2}
print(s1 &lt;= s2)         --&gt; true
print(s1 &lt; s2)          --&gt; true
print(s1 &gt;= s1)         --&gt; true
print(s1 &gt; s1)          --&gt; false
print(s1 == s2 * s1)    --&gt; true</code></pre>
<p>Для типов с полным порядком мы можем не определять метаметод <code>__lе</code>. При его отсутствии Lua использует поле <code>__lt</code>.</p>
<p>У сравнения на равенство есть некоторые ограничения. Если у двух объектов разные базовые типы или метаметоды, то операция сравнения на равенство вернет false, даже не вызывая метаметоды. Таким образом множество всегда будет отличаться от числа, независимо от того, что говорит метаметод.</p>
<h3 id="Chapter13.xhtml#sigil_toc_id_102">13.3. Библиотечные метаметоды</h3>
<p>До сих пор все метаметоды, что мы видели, находились в ядре Lua. Виртуальная машина сама проверяет, содержат ли значения, участвующие в операции, метатаблицы с метаметодами для этой операции. Однако, поскольку метатаблицы являются обычными таблицами, их может использовать любой. Поэтому для библиотек в порядке вещей определять свои собственные поля в метатаблицах.</p>
<p>Функция <code>tostring</code> является типичным примером. Как мы видели ранее, <code>tostring</code> представляет таблицы довольно простым образом:</p>
<pre><code>print({}) --&gt; table: 0x8062ac0</code></pre>
<p>Функция <code>print</code> всегда вызывает <code>tostring</code> для форматирования своего вывода. Однако, при форматировании какого-либо значения <code>tostring</code> сначала проверяет, есть ли у значения метаметод <code>__tostring</code>. Если такой метаметод есть, то <code>tostring</code> вызывает его, передавая ему объект в качестве аргумента. То, что вернет этот метаметод, и будет результатом <code>tostring</code>.</p>
<p>В нашем примере с множествами мы уже определили функцию для представления множества в виде строки. Поэтому нам нужно лишь выставить поле <code>__tostring</code> в этой метатаблице:</p>
<pre><code>mt.__tostring = Set.tostring</code></pre>
<p>После этого, когда бы мы не вызвали <code>print</code> с множеством в качестве аргумента, <code>print</code> вызовет <code>tostring</code>, которая, в свою очередь, вызовет <code>Set.tostring</code>:</p>
<pre><code>s1 = Set.new{10, 4, 5}
print(s1)    --&gt; {4, 5, 10}</code></pre>
<p>Функции <code>setmetatable</code> и <code>getmetatable</code> также используют метаполе, в данном случае для защиты метатаблиц. Предположим, вы хотите защитить ваши множества так, что пользователи не смогут ни увидеть, ни изменить их метатаблицы. Если задать в метатаблице поле <code>__metatable</code>, то <code>getmetatable</code> вернет значение этого поля, в то время как <code>setmetatable</code> вызовет ошибку:</p>
<pre><code>mt.__metatable = &quot;not your business&quot;

s1 = Set.new{}
print(getmetatable(s1))     --&gt; not your business
setmetatable(s1, {})
  stdin:1: cannot change protected metatable</code></pre>
<p>В Lua 5.2 <code>pairs</code> и <code>ipairs</code> также обладают метатаблицами, поэтому таблица может изменить способ своего обхода (или можно добавить обход для объектов, не являющихся таблицами).</p>
<h3 id="Chapter13.xhtml#sigil_toc_id_103">13.4. Метаметоды доступа к таблице</h3>
<p>Метаметоды для арифметических операций и операций сравнения лишь определяют поведение для ситуаций, которые иначе приводили бы к возникновению ошибок. Они не влияют на обычное поведение языка. Но Lua также предлагает способ для изменения поведения таблиц в двух обычных случаях: запросе и изменении несуществующего поля в таблице.</p>
<h4 id="Chapter13.xhtml#sigil_toc_id_104">Метаметод <code>__index</code></h4>
<p>Ранее я уже говорил, что когда мы обращаемся к отсутствующему полю в таблице, результатом является nil. Это так, но это не вся правда. На самом деле при подобном обращении интерпретатор начинает искать метаметод <code>__index</code>: если такого метода нет, что обычно и бывает, то возвращается nil; иначе результат будет предоставлен этим метаметодом.</p>
<p>Типичным примером здесь является наследование. Пусть мы хотим создать несколько таблиц, описывающих окна. Каждая таблица должна описывать различные параметры окна, такие как положение, размер, цветовая схема и т. п. Для всех этих параметров есть значения по умолчанию и поэтому мы хотим строить объекты окон, задавая только те значения, которые отличаются от значений по умолчанию. Первый вариант — предоставить конструктор, заполняющий отсутствующие поля. Второй вариант — сделать так, чтобы новые окна <em>наследовали</em> любое отсутствующее поле от прототипа окон. Для начала мы объявим прототип и функцию-конструктор, которая создает новые окна, обладающие общей метатаблицей:</p>
<pre><code>-- создает прототип со значениями по умолчанию
prototype = {x = 0, y = 0, width = 100, height = 100}
mt = {}    -- создает метатаблицу
-- объявляет функцию-конструктор
function new (o)
  setmetatable(o, mt)
  return o
end</code></pre>
<p>Теперь мы определим метаметод <code>__index</code>:</p>
<pre><code>mt.__index = function (_, key)
  return prototype[key]
end</code></pre>
<p>После этого кода мы создадим новое окно и обратимся к отсутствующему полю:</p>
<pre><code>w = new{x=10, y=20}
print(w.width)    --&gt; 100</code></pre>
<p>Lua обнаружит, что у <code>w</code> нет требуемого поля, но есть метатаблица с полем <code>__index</code>. Поэтому Lua вызовет этот метаметод с аргу<span>ментами</span> <code>w</code> <span>(таблица) и</span> &quot;<code>width</code>&quot; <span>(отсутствующий ключ). Затем метаметод индексирует этот прототип заданным ключом и возвращает полученное значение.</span></p>
<p>Использование метаметода <code>__index</code> для наследования в Lua настолько распространено, что Lua предоставляет сокращенный вариант. Хотя его и зовут <em>методом</em>, метаметод <code>__index</code> не обязан быть функцией: например, он может быть таблицей. Когда он является функцией, Lua вызывает его, передавая таблицу и отсутствующий ключ в качестве аргументов, как мы только что видели. Когда он является таблицей, Lua перенаправляет к ней обращение. Поэтому в нашем предыдущем примере мы могли просто определить <code>__index</code> следующим образом:</p>
<pre><code>mt.__index = prototype</code></pre>
<p>Теперь, когда Lua будет искать метаметод <code>__index</code>, он найдет значение <code>prototype</code>, которое является таблицей. Соответственно, Lua повторит обращение к этой таблице, то есть выполнит аналог <code>prototype[&quot;width&quot;]</code>. Это обращение и приведет к нужному результату.</p>
<p>Использование таблицы в качестве метаметода <code>__index</code> дает простой и быстрый способ реализации одиночного наследования. Функция, хотя и более затратна, предоставляет больше гибкости: мы можем реализовать множественное наследование, кэширование и ряд других вариантов. Мы обсудим эти формы наследования в главе 16.</p>
<p>Когда мы хотим обратиться к таблице без вызова ее метаметода <code>__index</code>, мы используем функцию <code>rawget</code>. Вызов <code>rawget(t,i)</code> осуществляет <em>непосредственный</em> доступ к таблице <code>t</code>, то есть примитивное обращение без использования метатаблиц. Применение непосредственного доступа не ускорит ваш код (затраты на вызов функции уничтожат любую прибавку), но иногда, как мы увидим позже, он необходим.</p>
<h4 id="Chapter13.xhtml#sigil_toc_id_105">Метаметод <code>__newindex</code></h4>
<p>Метаметод <code>__newindex</code> делает то же, что и <code>__index</code>, но работает при обновлениях таблиц, а не при доступе к ним. <span>Когда вы присваиваете значение отсутствующему индексу в таблице, интерпретатор ищет метаметод</span> <code>__newindex</code><span>: если он есть, то интерпретатор вызывает его вместо выполнения присваивания. Подобно</span> <code>__index</code><span>, если метаметод является таблицей, то интерпретатор выполняет присваивание для этой таблицы вместо исходной. Более того, есть функция с прямым доступом, которая позволяет миновать метаметод:</span> <code>rawset (t, k, v)</code> <span>записывает значение</span> <code>v</code> <span>по ключу</span> <code>k</code> <span>в таблицу</span> <code>t</code><span>, не вызывая никаких метаметодов.</span></p>
<p>Совместное использование метаметодов <code>__index</code> и <code>__newindex</code> позволяет реализовать в Lua ряд довольно мощных конструкций, таких как таблицы, доступные только для чтения, таблицы со значениями по умолчанию и наследование для объектно-ориентированного программирования. В этой главе мы увидим некоторые области их применения. Объектно-ориентированному программированию посвящена его собственная глава.</p>
<h4 id="Chapter13.xhtml#sigil_toc_id_106">Таблицы со значениями по умолчанию</h4>
<p>Значение по умолчанию для любого поля в обычной таблице — это nil. Это легко изменить при помощи метатаблиц:</p>
<pre><code>function setDefault (t, d)
  local mt = {__index = function () return d end}
  setmetatable(t, mt)
end

tab = {x=10, y=20}
print(tab.x, tab.z)    --&gt; 10    nil
setDefault(tab, 0)
print(tab.x, tab.z)    --&gt; 10    0</code></pre>
<p>После вызова <code>setDefault</code> любой доступ к отсутствующему полю в <code>tab</code> вызовет его метаметод <code>__index</code>, который вернет ноль (значение <code>d</code> для этого метаметода).</p>
<p>Функция <code>setDeafult</code> создает новое замыкание и новую метатаблицу для каждой таблицы, которой нужно значение по умолчанию., Это может оказаться затратным, если у нас много таблиц, которым нужны значения по умолчанию. У метатаблицы значение по умолчанию <code>d</code> «зашито» в ее метаметод, поэтому мы не можем использовать одну и ту же метатаблицу для всех таблиц. Чтобы можно было использовать одну и ту же метатаблицу для таблиц с разными значениями по умолчанию, мы можем запоминать значение по умолчанию в самой таблице, используя для этого специальное поле. Если мы не беспокоимся о конфликтах имен, мы можем использовать для нашего особого поля ключ вроде &quot;<code>___</code>&quot;:</p>
<pre><code>local mt = {__index = function (t) return t.___ end}
function setDefault (t, d)
  t.___ = d
  setmetatable(t, mt)
end</code></pre>
<p>Обратите внимание, что теперь мы создаем таблицу <code>mt</code> лишь один раз, вне функции <code>setDefault</code>.</p>
<p>Если мы беспокоимся о конфликтах имен, то можно легко убедиться в уникальности особого ключа. Все, что нам нужно, — это создать новую таблицу и использовать ее в качестве ключа:</p>
<pre><code>local key = {}    -- уникальный ключ
local mt = {__index = function (t) return t[key] end}
function setDefault (t, d)
  t[key] = d
  setmetatable(t, mt)
end</code></pre>
<p>Другим способом связывания значения по умолчанию с каждой таблицей является использование отдельной таблицы, где индексы являются этими таблицами, а значения этих индексов являются значениями этих таблиц по умолчанию. Однако, для корректной реализации данного подхода нам нужна особая разновидность таблиц — так называемые <em>слабые таблицы</em> <strong>(weak tables)</strong>, поэтому здесь мы не будем его использовать; мы вернемся к данной теме в главе 17.</p>
<p>Иной подход состоит в том, чтобы <em>запоминать</em> <strong>(memorize)</strong> метатаблицы, чтобы затем многократно использовать одну и ту же метатаблицу для таблиц с одинаковыми значениями по умолчанию. Однако, для этого тоже нужны слабые таблицы, поэтому нам вновь придется подождать до главы 17.</p>
<h4 id="Chapter13.xhtml#sigil_toc_id_107">Отслеживание доступа к таблице</h4>
<p>И <code>__index</code>, и <code>__newindex</code> работают только при отсутствии в таблице соответствующего индекса. Поэтому единственный способ отслеживать весь доступ к таблице — это держать ее пустой. Таким образом, если мы хотим отслеживать весь доступ к таблице, нам нужно создать посредника (<strong>proxy)</strong> для настоящей таблицы. Данный посредник — это пустая таблица с соответствующими метаметодами <code>__index</code> и <code>__newindex</code> для отслеживания доступа к таблице, которые будут перенаправлять доступ к исходной таблице. Пусть <code>t</code> — это исходная таблица, доступ к которой мы хотим отслеживать. Тогда мы можем написать что-то вроде этого:</p>
<pre><code>t = {} -- исходная таблица (созданная где-то еще)

-- хранит закрытый доступ к первоначальной таблице
local _t = t

-- создает посредника
t = {}

-- создает метатаблицу
local mt = {
  __index = function (t, k)
    print(&quot;*access to element &quot; .. tostring(k))
    return _t[k]     -- доступ к исходной таблице
  end,
  __newindex = function (t, k, v)
    print(&quot;*update of element &quot; .. tostring(k) ..
          &quot; to &quot; .. tostring(v))
    _t[k] = v        -- обновляет исходную таблицу
  end
}
setmetatable(t, mt)</code></pre>
<p>Этот код отслеживает каждое обращение к <code>t</code>:</p>
<pre><code>&gt; t[2] = &quot;hello&quot;
*update of element 2 to hello
&gt; print(t[2])
*access to element 2
hello</code></pre>
<p>Если нам требуется обойти эту таблицу, мы должны определить в посреднике запись <code>__pairs</code>:</p>
<pre><code>mt.__pairs = function ()
  return function (_, k)
    return next(_t, k)
  end
end</code></pre>
<p>Нам может понадобиться нечто подобное для <code>__ipairs</code>.</p>
<p>Если мы хотим следить за несколькими таблицами, то нам не нужно для каждой из них создавать отдельную метатаблицу. Вместо этого мы можем как-нибудь связать каждого посредника с его исходной таблицей и разделить одну общую метатаблицу между всеми посредниками. Это похоже на задачу связывания таблицы с ее значениями по умолчанию, которую мы обсуждали в предыдущем разделе. Например, можно хранить исходную таблицу в поле посредника при помощи специального ключа. Результатом является следующий код:</p>
<pre><code>local index = {}           -- создает закрытый индекс
local mt = {               -- создает метатаблицу
  __index = function (t, k)
    print(&quot;*access to element &quot; .. tostring(k))
    return t[index][k]     -- доступ к исходной таблице
  end,
  __newindex = function (t, k, v)
  print(&quot;*update of element &quot; .. tostring(k) ..
        &quot; to &quot; .. tostring(v))
  t[index][k] = v          -- обновляет исходную таблицу
end,
__pairs = function (t)
  return function (t, k)
    return next(t[index], k)
  end, t
end
}

function track (t)
  local proxy = {}
  proxy[index] = t
  setmetatable(proxy, mt)
  return proxy
end</code></pre>
<p>Теперь, всякий раз, когда нам потребуется отслеживать таблицу <code>t</code>, все, что нам нужно будет сделать, — выполнить <code>t=track(t)</code>.</p>
<h4 id="Chapter13.xhtml#sigil_toc_id_108">Таблицы, доступные только для чтения</h4>
<p>Можно легко адаптировать идею посредников, чтобы реализовать таблицы, доступные только для чтения <strong>(read-only)</strong>. Все, что нам нужно, — это вызывать ошибку каждый раз, когда мы ловим попытку обновить таблицу. Для метаметода <code>__index</code> мы можем использовать саму исходную таблицу вместо функции, так как нам не нужно отслеживать запросы; проще и эффективнее перенаправлять такие запросы сразу к исходной таблице. Однако, это потребует новой метатаблицы для каждого доступного только для чтения посредника, с полем <code>__index</code>, указывающим на исходную таблицу:</p>
<pre><code>function readOnly (t)
  local proxy = {}
  local mt = {     -- создает метатаблицу
    __index = t,
    __newindex = function (t, k, v)
      error(&quot;attempt to update a read-only table&quot;, 2)
    end
  }
  setmetatable(proxy, mt)
  return proxy
end</code></pre>
<p>В качестве примера использования таких таблиц мы можем создать таблицу названий дней недели:</p>
<pre><code>days = readOnly{&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;,
                &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;}

print(days[1])    --&gt; Sunday
days[2] = &quot;Noday&quot;
stdin:1: attempt to update a read-only table</code></pre>
<h3 id="Chapter13.xhtml#sigil_toc_id_109">Упражнения</h3>
<p><strong>Упражнение 13.1.</strong> Определите метаметод <code>__sub</code>, который возвращает разницу двух множеств. (Множество <em>а — b</em> является множеством всех элементов из <em>а</em>, которые не содержатся в <em>b</em>.)</p>
<p><strong>Упражнение 13.2.</strong> Определите для множеств метаметод <code>__len</code> так, чтобы <code>#s</code> возвращал число элементов в множестве <code>s</code>.</p>
<p><strong>Упражнение 13.3.</strong> Дополните реализацию посредников в разделе 13.4 метаметодом <code>__ipairs</code>.</p>
<p><strong>Упражнение 13.4.</strong> Другим способом реализации таблиц, доступных только для чтения, является использование функции в качестве метаметода <code>__index</code>. Этот подход делает обращения к таблице более затратными, но создание таких таблиц обходится дешевле, так как все таблицы, доступные только для чтения, могут совместно использовать одну метатаблицу. Перепишите функцию <code>readOnly</code> с использованием данного подхода.</p>
<p><span id="Chapter14.xhtml"></span></p>
<h2>ГЛАВА 14</h2>
<h2 id="Chapter14.xhtml#sigil_toc_id_110">Окружение</h2>
<p>Lua хранит все свои глобальные переменные в обычной таблице, называемой <em>глобальным окружением</em> <strong>(global environment)</strong>. (Точнее, Lua хранит свои «глобальные» переменные в нескольких окружениях, но мы некоторое время не будем обращать внимание на данные сложности.) Одним из преимуществ этой структуры является то, что она упрощает внутреннюю реализацию Lua, поскольку нет необходимости в специальной структуре данных для глобальных переменных. Другое преимущество состоит в том, что мы можем работать с этой таблицей так же, как и с любой другой. Для упрощения такой работы Lua хранит само окружение в глобальной переменной <code>_G</code>. (Да, <code>_G._G</code> равно <code>_G</code>.) Например, следующий код печатает имена всех глобальных переменных, определенных в глобальном окружении:</p>
<pre><code>for n in pairs(_G) do print(n) end</code></pre>
<p>В этой главе мы увидим несколько полезных методов для работы с окружением.</p>
<h3 id="Chapter14.xhtml#sigil_toc_id_111">14.1. Глобальные переменные с динамическими именами</h3>
<p>Обычно для обращения к глобальным переменным и установки их значений достаточно присваивания. Однако, довольно часто нам требуется какая-либо форма метапрограммирования, например, когда мы хотим работать с глобальной переменной, чье имя содержится в другой переменной или каким-то образом вычисляется во время выполнения. Чтобы получить значение такой переменной, многие программисты пытаются писать нечто подобное:</p>
<pre><code>value = loadstring(&quot;return &quot; .. varname)()</code></pre>
<p>Если, скажем, <code>varname</code> равно <code>x</code>, то результатом конкатенации будет &quot;<code>return х</code>&quot;, что при выполнении даст нам желаемый результат. Однако, этот код включает в себя создание и компиляцию нового куска кода, что является довольно затратным. Вы можете добиться того же эффекта при помощи следующего кода, который в десятки раз эффективнее предыдущего:</p>
<pre><code>value = _G[varname]</code></pre>
<p>Поскольку окружение — это обычная таблица, то вы можете просто индексировать ее нужным ключом (именем переменной).</p>
<p>Похожим образом можно присвоить значение глобальной переменной, чье имя вычисляется динамически, если написать <code>_G[varname] = value</code>. Однако, будьте внимательны: некоторые программисты так радуются подобной возможности, что заканчивают написанием кода вроде <code>_G[&quot;a&quot;] = _G[&quot;var1&quot;]</code>, что является всего лишь усложненным вариантом написания <code>a=var1</code>.</p>
<p>Обобщением предыдущей задачи является разрешение использования полей в динамических именах, таких как &quot;<code>io.read</code>&quot; или &quot;<code>а.b.с.d</code>&quot;. Если написать <code>_G[&quot;io.read&quot;]</code>, то очевидно, что мы не получим поле <code>read</code> из таблицы <code>io</code>. Но мы можем написать функцию <code>getfield</code>, такую что <code>getfield (&quot;io.read&quot;)</code> вернет ожидаемое значение. Эта функция преимущественно является циклом, который начинает с <code>_G</code> и развивается поле за полем:</p>
<pre><code>function getfield (f)
  local v = _G    -- начинает с таблицы глобальных переменных
  for w in string.gmatch(f, &quot;[%w_]+&quot;) do
    v = v[w]
  end
  return v
end</code></pre>
<p>Мы полагаемся на <code>gmatch</code> из библиотеки <code>string</code> для перебора всех слов в <code>f</code> (где «слово» — это последовательность из одного или более буквенно-цифровых символов и знаков подчеркивания).</p>
<p>Соответствующая функция для задания полей немного сложнее. Присваивание вроде <code>a.b.c.d=v</code> эквивалентно следующему коду:</p>
<pre><code>local temp = a.b.c
temp.d = v</code></pre>
<p>To есть мы должны извлечь последнее имя и затем отдельно его обработать. Следующая функция <code>setfield</code> решает данную задачу и при этом создает промежуточные таблицы в пути, когда они не существуют:</p>
<pre><code>function setfield (f, v)
  local t = _G             -- начинает с таблицы глобальных переменных
  for w, d in string.gmatch(f, &quot;([%w_]+)(%.?)&quot;) do
    if d == &quot;.&quot; then       -- имя не последнее?
      t[w] = t[w] or {}    -- создает таблицу при ее отсутствии
      t = t[w]             -- получает таблицу
    else                   -- последнее имя
      t[w] = v             -- производит присваивание
    end
  end
end</code></pre>
<p>Этот новый образец захватывает имя поля в переменную <code>w</code> и следующую за ним необязательную точку в переменную <code>d</code>.(<span class="underline">Примечание</span>: Мы подробно обсудим сопоставление с образцом в главе 21). Если за именем не следует точка, то это последнее имя.</p>
<p>При наличии вышеприведенных функций следующий вызов создает глобальную таблицу <code>t</code> и таблицу <code>t.х</code> , после чего присваивает <code>t.х.у</code> значение 10:</p>
<pre><code>setfield(&quot;t.x.y&quot;, 10)

print(t.x.y)                --&gt; 10
print(getfield(&quot;t.x.y&quot;))    --&gt; 10</code></pre>
<h3 id="Chapter14.xhtml#sigil_toc_id_112">14.2. Объявления глобальных переменных</h3>
<p>В Lua глобальным переменным не нужны объявления. Хотя это и удобно для небольших программ, в больших программах простая опечатка может привести к трудно обнаруживаемым ошибкам. Однако, при желании мы можем изменить это поведение. Поскольку Lua хранит свои глобальные переменные в обычной таблице, мы можем использовать метатаблицы для изменения его поведения при обращении к глобальным переменным.</p>
<p>Первый подход состоит в простом отслеживании любых обращений к отсутствующим ключам в глобальной таблице:</p>
<pre><code>setmetatable(_G, {
  __newindex = function (_, n)
    error(&quot;attempt to write to undeclared variable &quot; .. n, 2)
  end,
  __index = function (_, n)
    error(&quot;attempt to read undeclared variable &quot; .. n, 2)
  end,
})</code></pre>
<p>После выполнения этого кода любая попытка обратиться к несуществующей глобальной переменной приведет к возникновению ошибки:</p>
<pre><code>&gt; print(a)
stdin:1: attempt to read undeclared variable a</code></pre>
<p>Но как же нам объявлять глобальные переменные? Одним из вариантов является использование <code>rawset</code>, которая минует метаметод:</p>
<pre><code>function declare (name, initval)
  rawset(_G, name, initval or false)
end</code></pre>
<p>(Конструкция <strong>or false</strong> следит за тем, чтобы глобальная переменная всегда получала значение, отличное от nil.)</p>
<p>Вариант попроще — разрешить присваивания новым глобальным переменным только внутри функций, при этом не ограничивая присваивания за пределами куска.</p>
<p>Для проверки того, что присваивание происходит в главном куске, нам нужно использовать отладочную библиотеку. Вызов <code>debug.getinfo(2, &quot;S&quot;)</code> возвращает таблицу, чье поле <code>what</code> сообщит о том, является ли функция, вызвавшая метаметод, главным куском, обычной функцией Lua или функцией C. (Мы обсудим <code>debug.getinfo</code> более подробно в главе 24.) Посредством этой функции мы можем переписать метаметод <code>__newindex</code> следующим образом:</p>
<pre><code>__newindex = function (t, n, v)
  local w = debug.getinfo(2, &quot;S&quot;).what
  if w ~= &quot;main&quot; and w ~= &quot;C&quot; then
    error(&quot;attempt to write to undeclared variable &quot; .. n, 2)
  end
  rawset(t, n, v)
end</code></pre>
<p>Эта новая версия также допускает присваивания из кода C, так как обычно его авторы знают, что они делают.</p>
<p>Для проверки существования переменной мы не можем просто сравнить ее с nil, поскольку если она nil, то обращение приведет к ошибке. Вместо этого мы используем <code>rawget</code>, которая избегает метаметод:</p>
<pre><code>if rawget(_G, var) == nil then
  -- &#39;var&#39; не объявлена
  ...
end</code></pre>
<p>Пока что наша схема не допускает использование глобальных переменных со значением nil, поскольку они автоматически будут считаться необъявленными. Но это не сложно исправить. Все, что нам нужно, — это вспомогательная таблица, которая хранит имена объявленных переменных. При вызове метаметода он по этой таблице проверяет — объявлена эта переменная, или нет. Ее код может быть похож на приведенный в листинге 14.1. Теперь даже присваивания вроде <code>x=nil</code> достаточно, чтобы объявить глобальную переменную.</p>
<p><strong>Листинг 14.1.</strong> Проверка описаний глобальных переменных</p>
<pre><code>local declaredNames = {}

setmetatable(_G, {
  __newindex = function (t, n, v)
    if not declaredNames[n] then
      local w = debug.getinfo(2, &quot;S&quot;).what
      if w ~= &quot;main&quot; and w ~= &quot;C&quot; then
        error(&quot;attempt to write to undeclared variable &quot;..n, 2)
      end
      declaredNames[n] = true
    end
    rawset(t, n, v)    -- производит настоящую установку значений
  end,

  __index = function (_, n)
    if not declaredNames[n] then
      error(&quot;attempt to read undeclared variable &quot;..n, 2)
    else
      return nil
    end
  end,
})</code></pre>
<p>Затраты на оба решения крайне малы. При первом решении в нормальном режиме работы метаметод вообще не вызывается. При втором решении метаметоды могут быть вызваны, но только когда программа обращается к переменной со значением nil.</p>
<p>В стандартную поставку Lua входит модуль <code>strict.lua</code>, который реализует проверку глобальных переменных, по сути состоящую из только что рассмотренного нами кода. Использовать его при разработке кода на Lua — хорошая привычка.</p>
<h3 id="Chapter14.xhtml#sigil_toc_id_113">14.3. Неглобальные окружения</h3>
<p>Одной из проблем окружения является то, что оно глобальное. Любое его изменение влияет на все части вашей программы. Например, когда вы устанавливаете метатаблицу для управления глобальным доступом, вся ваша программа должна ей руководствоваться. Если вы хотите воспользоваться библиотекой, которая использует глобальные переменные без их объявления, то вам не повезло.</p>
<p>В Lua глобальные переменные не обязаны быть действительно глобальными. Мы даже можем сказать, что в Lua нет глобальных переменных. Поначалу это может звучать странно, поскольку мы пользовались глобальными переменными все это время. Очевидно, Lua очень старается создать иллюзию наличия глобальных переменных. Давайте посмотрим, как Lua создает эту иллюзию. (<span class="underline">Примечание</span>: Обратите внимание, что этот механизм был одной из тех частей Lua, которые претерпели наибольшие изменения при переходе с версии 5.1 на 5.2. Следующее обсуждение относится только к Lua 5.2 и очень мало применимо к предыдущим версиям.)</p>
<p>Начнем с понятия свободных имен. <em>Свободное имя</em> <strong>(free name)</strong> — это имя, которое не привязано к явному объявлению, то есть не встречается внутри области видимости локальной переменной (или переменной цикла <strong>for</strong>, или параметра) с этим именем. Например, и <code>var1</code>, и <code>var2</code> — это свободные имена в следующем куске:</p>
<pre><code>var1 = var2 + 3</code></pre>
<p>В отличие от сказанного ранее, свободное имя не относится к глобальной переменной (по крайней мере, не прямым образом). Вместо этого компилятор Lua переводит любое свободное имя <code>var</code> в <code>_ENV.var</code>. Поэтому предыдущий кусок эквивалентен следующему:</p>
<pre><code>_ENV.var1 = _ENV.var2 + 3</code></pre>
<p>Но что такое эта новая переменная <code>_ENV</code>? Она не может быть глобальной переменной, иначе мы снова возвращаемся к исходной проблеме. И вновь это проделки компилятора. Я уже отметил, что Lua рассматривает каждый кусок как анонимную функцию. На самом деле Lua компилирует наш исходный кусок в следующий код:</p>
<pre><code>local _ENV = &lt;какое-нибудь значение&gt;
return function (...)
  _ENV.var1 = _ENV.var2 + 3
end</code></pre>
<p>To есть Lua компилирует любой кусок кода с участием предопределенного верхнего значения с именем <code>_ENV</code>.</p>
<p>Обычно когда мы загружаем кусок кода, функция <code>load</code> инициализирует это предопределенное верхнее значение посредством глобального окружения. Поэтому наш исходный кусок становится эквивалентным следующему:</p>
<pre><code>local _ENV = &lt;глобальное окружение&gt;
return function (...)
  _ENV.var1 = _ENV.var2 + 3
end</code></pre>
<p>Результатом всех этих присваиваний является то, что поле <code>var1</code> из глобального окружения получает значение поля <code>var2</code> плюс 3.</p>
<p>На первый взгляд это может показаться довольно запутанным способом работы с глобальными переменными. Я не буду утверждать, что это простейший способ, но он дает гибкость, которую трудно получить с более простой реализацией.</p>
<p>Прежде чем мы продолжим, давайте кратко сформулируем обработку глобальных переменных в Lua 5.2:</p>
<ul>
<li><span>Lua компилирует любой кусок внутри области видимости верхнего значения с именем <code>_ENV</code>.</span></li>
<li><span>Компилятор переводит любое свободное имя <code>var</code> в <code>_ENV.var</code>.</span></li>
<li><span>Функция <code>load</code> (или <code>loadfile</code>) инициализирует первое верхнее значение куска при помощи глобального окружения.</span></li>
</ul>
<p>В конце концов, все не так уж и сложно.</p>
<p>Некоторых это смущает, поскольку они пытаются выявить особые механизмы, лежащие в основе этих правил. Но никаких особых механизмов нет. В частности, за первые два правила полностью отвечает компилятор. За исключением того, что <code>_ENV</code> предопределена компилятором, она является обычной переменной. Вне компиляции у <code>_ENV</code> нет никакого особого назначения в Lua. (<span class="underline">Примечание</span>: Если быть честными до конца, то Lua использует это имя для сообщений об ошибках, чтобы в докладе об ошибке с участием переменной <code>_ENV.x</code> указывать ее как <code>global х</code>.) Точно так же перевод из <code>var</code> в <code>_ENV.var</code> — это простая синтаксическая замена без скрытого смысла. В частности, после этого перевода <code>_ENV</code> будет относиться любой переменной <code>_ENV</code>, которая видна на этом этапе кода, исходя из стандартных правил видимости.</p>
<h3 id="Chapter14.xhtml#sigil_toc_id_114">14.4. Использование <span class="code">_ENV</span></h3>
<p>В этом разделе мы увидим некоторые способы для освоения той гибкости, которую дает нам <code>_ENV</code>. Имейте в виду, что большинство примеров из данного раздела должно выполняться отдельным куском. При построчном вводе кода в интерактивном режиме каждая строка становится отдельным куском и таким образом получает свою переменную <code>_ENV</code>. Для выполнения фрагмента кода как отдельного куска вам нужно либо запустить его из файла, либо в интерактивном режиме поместить внутрь пары <strong>do</strong>—<strong>end</strong>.</p>
<p>Поскольку <code>_ENV</code> — это обычная переменная, мы можем обращаться к ней и присваивать значения как и любой другой переменной. Присваивание <code>_ENV=nil</code> сведет на нет любой прямой доступ к глобальным переменным в оставшейся части куска. Это может пригодиться для контроля над тем, какие переменные использует ваш код:</p>
<pre><code>local print, sin = print, math.sin
_ENV = nil
print(13)              --&gt; 13
print(sin(13))         --&gt; 0.42016703682664
print(math.cos(13))    -- ошибка!</code></pre>
<p>Любое присваивание свободному имени вызовет аналогичную ошибку.</p>
<p>Мы можем написать <code>_ENV</code> явным образом, чтобы миновать локальное объявление:</p>
<pre><code>a = 13           -- глобальная
local a = 12
print(a)         --&gt; 12    (локальная)
print(_ENV.a)    --&gt; 13    (глобальная)</code></pre>
<p>Конечно, главной областью применения <code>_ENV</code> является изменение окружения, используемого фрагментом кода. Как только вы измените ваше окружение, все обращения к глобальным переменным будут пользоваться новой таблицей:</p>
<pre><code>-- изменяет текущее окрущение на новую пустую таблицу
_ENV = {}
a = 1    -- создает поле в _ENV
print(a)
  --&gt; stdin:4: attempt to call global &#39;print&#39; (a nil value)</code></pre>
<p>Если новое окружение пусто, то вы теряете доступ ко всем вашим глобальным переменным, включая <code>print</code>. Поэтому сперва вы должны заполнить его какими-нибудь полезными значениями, например старым окружением:</p>
<pre><code>a = 15             -- создает глобальную переменную
_ENV = {g = _G}    -- изменяет текущее окружение
a = 1              -- создает поле в _ENV
g.print(a)         --&gt; 1
g.print(g.a)       --&gt; 15</code></pre>
<p>Теперь, когда вы обращаетесь к «глобальной» <code>g</code>, вы получаете старое окружение, в котором вы найдете функцию <code>print</code>.</p>
<p>Мы можем переписать предыдущий пример, используя имя <code>_G</code> вместо <code>g</code>:</p>
<pre><code>a = 15              -- создает глобальную переменную
_ENV = {_G = _G}    -- изменяет текущее окружение
a = 1               -- создает поле в _ENV
_G.print(a)         --&gt; 1
_G.print(_G.a)      --&gt; 15</code></pre>
<p>Для Lua <code>_G</code> — такое же имя, как и все остальные. Его особый статус проявляется только тогда, когда Lua создает исходную глобальную таблицу и присваивает эту таблицу глобальной переменной <code>_G</code>. Для Lua не важно текущее значение этой переменной. Но обычно принято использовать одно и то же имя всякий раз, когда у нас есть ссылка на глобальное окружение, как в переписанном примере.</p>
<p>Другой способ заполнить ваше новое окружение — применить наследование:</p>
<pre><code>a = 1
local newgt = {}     -- создает новое окружение
setmetatable(newgt, {__index = _G})
_ENV = newgt         -- устанавливает его
print(a)             --&gt; 1</code></pre>
<p>В этом коде новое окружение наследует из старого и <code>print</code>, и <code>а</code>. Несмотря на это, любое присваивание поступает в новую таблицу. Теперь изменение переменной в глобальном окружении по ошибке не опасно, хотя вы по-прежнему можете изменять их через <code>_G</code>:</p>
<pre><code>-- продолжаем предыдущий код
a = 10
print(a)       --&gt; 10
print(_G.a)    --&gt; 1
_G.a = 20
print(_G.a)    --&gt; 20</code></pre>
<p>Поскольку <code>_ENV</code> является обычной переменной, она подчиняется обычным правилам видимости. В частности, функции, определенные внутри куска, обращаются к <code>_ENV</code> так же, как и к любой другой внешней переменной:</p>
<pre><code>_ENV = {_G = _G}
local function foo ()
  _G.print(a)               -- скомпилировано как &#39;_ENV._G.print(_ENV.a)&#39;
end
a = 10                      -- _ENV.a
foo()                       --&gt; 10
_ENV = {_G = _G, a = 20}
foo()                       --&gt; 20</code></pre>
<p>Если мы определим новую локальную переменную с именем <code>_ENV</code>, то ссылки на свободные имена будут привязаны к ней:</p>
<pre><code>a = 2
do
  local _ENV = {print = print, a = 14}
  print(a)    --&gt; 14
end
print(a)      --&gt; 2    (возвращение к изначальной _ENV)</code></pre>
<p>Поэтому несложно построить функцию с закрытым окружением:</p>
<pre><code>function factory (_ENV)
  return function ()
    return a    -- &quot;глобальная&quot; a
  end
end

f1 = factory{a = 6}
f2 = factory{a = 7}
print(f1())    --&gt; 6
print(f2())    --&gt; 7</code></pre>
<p>Функция <code>factory</code> создает простые замыкания, которые возвращают значение из их глобальных <code>а</code>. При созданном замыкании видимая переменная <code>_ENV</code> является параметром <code>_ENV</code> из охватывающей его функции <code>factory</code>; поэтому замыкание использует эту внешнюю переменную (в качестве верхнего значения) для доступа к своим свободным именам.</p>
<p>Используя обычные правила видимости, мы можем работать с окружениями различными способами. Например, у нас может быть несколько функций с общим для них окружением или функция, которая изменяет окружение, общее с другими функциями.</p>
<h3 id="Chapter14.xhtml#sigil_toc_id_115">14.5. <span class="code">_ENV</span> и <span class="code">load</span></h3>
<p>Как я ранее упоминал, <code>load</code> обычно инициализирует верхнее значение <code>_ENV</code> из загруженного куска посредством глобального окружения. Однако, у <code>load</code> есть необязательный четвертый параметр, который задает значение для <code>_ENV</code>. (У функции <code>loadfile</code> есть аналогичный параметр.)</p>
<p>В качестве первого примера допустим, что у нас есть типичный конфигурационный файл, определяющий различные константы и функции, используемые программой; это может быть что-то вроде:</p>
<pre><code>-- файл &#39;config.lua&#39;
width = 200
height = 300
...</code></pre>
<p>Мы можем загрузить его при помощи следующего кода:</p>
<pre><code>env = {}
f = loadfile(&quot;config.lua&quot;, &quot;t&quot;, env)
f()</code></pre>
<p>Весь код из конфигурационного файла будет выполнен в пустом окружении <code>env</code>. Важнее то, что все его определения перейдут именно в это окружение. Этот конфигурационный файл никоим образом не может повлиять на что-либо еще, даже по ошибке. Даже вредоносный код не сможет причинить много вреда. Все, что он может, — выполнить DoS-атаку (приводящую к отказу от обслуживания), тратя процессорное время и память.</p>
<p>Иногда вам может понадобиться выполнить кусок несколько раз, каждый раз с другой таблицей окружения. В этом случае дополнительный аргумент для <code>load</code> бесполезен. Вместо этого у нас есть два других варианта.</p>
<p>Первый вариант — это использовать функцию <code>debug.setupvalue</code> из отладочной библиотеки. Как следует из имени, <code>setupvalue</code> позволяет нам изменить любое верхнее значение заданной функции. Следующий фрагмент иллюстрирует его использование:</p>
<pre><code>f = loadfile(filename)
...
env = {}
debug.setupvalue(f, 1, env)</code></pre>
<p>Первый аргумент при вызове <code>setupvalue</code> — это функция, второй — индекс верхнего значения, а третий — новое значение для верхнего значения. При типичном применении второй аргумент всегда равен единице: когда функция является результатом <code>load</code> или <code>loadfile</code>, Lua следит за тем, чтобы у нее было лишь одно верхнее значение, равное <code>_ENV</code>.</p>
<p>Небольшим минусом данного решения является зависимость от отладочной библиотеки. Эта библиотека нарушает некоторые стандартные соглашения о программах. Например, <code>debug.setupvalue</code> нарушает правила видимости Lua, которые следят за тем, чтобы к локальной переменной нельзя было обратиться вне ее лексической области видимости.</p>
<p>Другой способ выполнения куска с различными окружениями состоит в небольшом изменении куска при его загрузке. Представьте, что мы добавляем следующую строку прямо в начало загружаемого куска:</p>
<pre><code>_ENV = ...;</code></pre>
<p>Вспомним из раздела 8.1, что Lua компилирует любой кусок в виде вариадической функции. Поэтому эта дополнительная строка присвоит переменной <code>_ENV</code> первый аргумент куска, устанавливая его как окружение. После загрузки этого куска мы вызываем полученную функцию, передавая нужное нам окружение как первый аргумент. Следующий фрагмент кода иллюстрирует эту идею при помощи функции <code>loadwithprefix</code> из упражнения 8.1:</p>
<pre><code>f = loadwithprefix(&quot;local _ENV = ...;&quot;, io.lines(filename, &quot;*L&quot;))
...
env = {}
f(env)</code></pre>
<h3 id="Chapter14.xhtml#sigil_toc_id_116">Упражнения</h3>
<p><strong>Упражнение 14.1.</strong> Функция <code>getfield</code>, которую мы определили в начале этой главы, слишком неприхотлива, так как она допускает «поля» вроде <code>math?sin</code> или <code>string!!!gsub</code>. Перепишите ее так, чтобы она принимала в качестве разделителя имен только одиночную точку. (Для этого упражнения вам может понадобиться информация из главы 21.)</p>
<p><strong>Упражнение 14.2.</strong> Объясните в деталях, что происходит в следующей программе и каким будет ее вывод.</p>
<pre><code>local foo
do
  local _ENV = _ENV
  function foo () print(X) end
end
X = 13
_ENV = nil
foo()
X = 0</code></pre>
<p><strong>Упражнение 14.3.</strong> Объясните в деталях, что происходит в следующей программе и каким будет ее вывод.</p>
<pre><code>local print = print
function foo (_ENV, a)
  print(a + b)
end

foo({b = 14}, 12)
foo({b = 10}, 1)</code></pre>
<p><span id="Chapter15.xhtml"></span></p>
<h2>ГЛАВА 15</h2>
<h2 id="Chapter15.xhtml#sigil_toc_id_117">Модули и пакеты</h2>
<p>Обычно Lua не обязывает к каким-либо соглашениям. Вместо этого Lua предоставляет механизмы, которые достаточно эффективны для групп разработчиков, чтобы реализовать наиболее подходящие для них соглашения. Однако, этот подход не годится для модулей. Одна из основных целей модульной системы состоит в том, чтобы позволить разным группам совместно использовать код. Отсутствие общих соглашений мешает такому использованию.</p>
<p>Начиная с версии 5.1, Lua определил набор соглашений для модулей и пакетов (пакет является набором модулей). Эти соглашения не требуют от языка никаких дополнительных средств; программисты могут реализовать их при помощи того, что мы уже видели: таблиц, функций, метатаблиц и окружений. Программисты могут использовать любые другие соглашения. Разумеется, альтернативные реализации могут привести к тому, что программы не смогут использовать чужие модули, а модули не смогут быть использованы чужими программами.</p>
<p>С точки зрения пользователя, <em>модуль</em> — это некоторый код (на Lua или С), который может быть загружен посредством <code>require</code> и который создает и возвращает таблицу. Все, что модуль экспортирует, будь то функции или таблицы, он определяет внутри этой таблицы, которая выступает в качестве пространства имен.</p>
<p>Например, все стандартные библиотеки — это модули. Вы можете использовать математическую библиотеку следующим образом:</p>
<pre><code>local m = require &quot;math&quot;
print(m.sin(3.14))</code></pre>
<p>Однако, автономный интерпретатор заранее загружает все стандартные библиотеки при помощи кода, эквивалентного следующему:</p>
<pre><code>math = require &quot;math&quot;
string = require &quot;string&quot;
...</code></pre>
<p>Эта предварительная загрузка позволяет нам записывать <code>math.sin</code> привычным образом.</p>
<p>Очевидное преимущество от использования таблиц для реализации модулей состоит в том, что мы можем работать с модулями как с любыми другими таблицами, и применять всю силу Lua для создания дополнительных средств. В большинстве языков модули не являются значениями первого класса (то есть не могут храниться в переменных, передаваться как аргументы функциям и т. п.), поэтому таким языкам нужны специальные механизмы для каждого дополнительного средства, которое они хотят предложить для модулей. В Lua вы получаете дополнительные средства бесплатно.</p>
<p>Например, для пользователя существует несколько способов вызвать функцию из модуля. Обычным способом является следующий:</p>
<pre><code>local mod = require &quot;mod&quot;
mod.foo()</code></pre>
<p>Пользователь может задать для модуля любое локальное имя:</p>
<pre><code>local m = require &quot;mod&quot;
m.foo()</code></pre>
<p>Также можно предоставить альтернативные имена для отдельных функций:</p>
<pre><code>local m = require &quot;mod&quot;
local f = mod.foo
f()</code></pre>
<p>Эти средства удобны тем, что они не требуют специальной поддержки от языка. Они используют только то, что уже предлагает язык.</p>
<p>Распространенная жалоба на <code>require</code> состоит в том, что эта функция не может передавать аргументы загружаемому модулю. Например, у математического модуля могла бы быть опция для выбора между градусами и радианами:</p>
<pre><code>-- bad code
local math = require(&quot;math&quot;, &quot;degree&quot;)</code></pre>
<p>Проблема в том, что одна из основных задач <code>require</code> — избегать многократной загрузки модуля. Как только модуль загружен, он может быть многократно использован любой частью программы, которой он снова потребуется. Если бы один и тот же модуль был затребован с разными параметрами, это привело бы к конфликту:</p>
<pre><code>-- плохой код
local math = require(&quot;math&quot;, &quot;degree&quot;)

-- где-то еще в той же программе
local math = require(&quot;math&quot;, &quot;radians&quot;)</code></pre>
<p>В случае, когда вы действительно хотите, чтобы у вашего модуля были параметры, лучше создать явную функцию для их задания, например так:</p>
<pre><code>local mod = require&quot;mod&quot;
mod.init(0, 0)</code></pre>
<p>Если инициализирующая функция возвращает сам модуль, то мы можем написать код вроде следующего:</p>
<pre><code>local mod = require&quot;mod&quot;.init(0, 0)</code></pre>
<p>Другой вариант — сделать так, чтобы модуль возвращал свою функцию для инициализации, и лишь эта функция возвращала бы таблицу модуля:</p>
<pre><code>local mod = require&quot;mod&quot;(0, 0)</code></pre>
<p>В любом случае помните, что сам модуль загружается всего один раз; разрешение конфликтных инициализаций остается на его усмотрение.</p>
<h3 id="Chapter15.xhtml#sigil_toc_id_118">15.1. Функция <span class="code">require</span></h3>
<p>Функция <code>require</code> пытается свести к минимуму свои предположения о том, что является модулем. Для <code>require</code> модуль — это всего лишь какой-то код, который определяет некоторые значения (например, функции или таблицы, содержащие функции). Обычно этот код возвращает таблицу, состоящую из функций этого модуля. Однако, поскольку это делается кодом самого модуля, а не <code>require</code>, некоторые модули могут выбрать возвращать другие значения или даже иметь побочные эффекты.</p>
<p>Для загрузки модуля мы просто вызываем <code>require &quot;</code><em>имя_модуля</em><code>&quot;</code>. Первым шагом <code>require</code> является проверка по таблице <code>package.loaded</code>, не был ли загружен данный модуль ранее. Если да, <code>require</code> возвращает его соответствующее значение. Поэтому, как только модуль загружен, другие вызовы, для которых он требуется, просто вернут то же значение без повтороного выполнения какого-либо кода.</p>
<p>Если модуль еще не загружен, то <code>require</code> ищет файл Lua с именем модуля. Если он находит этот файл, то загружает его при помощи <code>loadfile</code>. Результатом этого является функция, которую мы называем <em>загрузчиком</em> <strong>(loader)</strong>. (Загрузчик — это функция, которая при вызове загружает модуль.)</p>
<p>Если <code>require</code> не может найти файл Lua с именем модуля, то она ищет библиотеку С с этим именем модуля. Если она находит библиотеку С, то она загружает ее посредством <code>package.loadlib</code> (которую мы обсудили в разделе 8.3) и ищет функцию с именем <code>luaopen_</code><em>имя_модуля</em> (<span class="underline">Примечание</span>: В разделе 27.3 мы обсудим, как писать библиотеки C). В этом случае загрузчик является результатом <code>loadlib</code>, то есть функцией <code>luaopen_</code><em>имя_модуля</em>, представленной в качестве функции Lua.</p>
<p>Независимо от того, где был найден модуль, — в файле Lua или в библиотеке С, у <code>require</code> теперь есть для него загрузчик. Для окончательной загрузки модуля <code>require</code> вызывает загрузчик с двумя аргументами: именем модуля и именем файла, из которого был взят этот загрузчик. (Большинство модулей просто игнорируют эти аргументы.) Если загрузчик возвращает какое-либо значение, <code>require</code> возвращает это значение и хранит в таблице <code>package.loaded</code>, чтобы всегда возвращать одинаковые значения при будущих вызовах этого же модуля. Если загрузчик не возвращает никакие значения, <code>require</code> ведет себя так, как если бы модуль вернул true. Без этого уточнения, последующие вызовы <code>require</code> снова бы выполняли этот модуль.</p>
<p>Чтобы заставить <code>require</code> загрузить один и тот же модуль дважды, мы просто стираем запись о нем из <code>package.loaded</code>:</p>
<pre><code>package.loaded.&lt;имя_модуля&gt; = nil</code></pre>
<p>В следующий раз, когда понадобится этот модуль, <code>require</code> проделает всю необходимую работу еще раз.</p>
<h4 id="Chapter15.xhtml#sigil_toc_id_119">Переименование модуля</h4>
<p>Обычно мы используем модули с их изначальными именами, но иногда мы должны переименовать модуль, чтобы избежать конфликта имен. Типичной ситуацией является загрузка разных версий одного и того же модуля, например для тестирования. У модулей Lua нет внутренней привязки к именам, поэтому обычно достаточно переименовать соответствующий файл с расширением <code>.lua</code>. Однако, мы не можем отредактировать бинарную библиотеку для корректировки имени ее функции <code>luaopen_*</code>. Чтобы поддерживать подобные переименования у <code>require</code> есть небольшая хитрость: если имя модуля содержит дефис, то <code>require</code> отбрасывает этот дефис и все, что стоит перед ним, когда создает имя функции <code>luaopen_*</code>. Например, если модуль называется <code>а-b</code>, то <code>require</code> ожидает, что функция для его открытия будет называться <code>luaopen_b</code>, а не <code>luaopen_a-b</code> (что по-любому не является допустимым именем в языке С). Поэтому если нам нужно использовать два модуля с именем <code>mod</code>, то мы можем переименовать один из них в <code>v1-mod</code>, например. Когда мы вызовем <code>m1=require &quot;</code><code>v1-mod&quot;</code>, функция <code>require</code> найдет переименованный файл <code>v1-mod</code> и внутри этого файла найдет функцию с изначальным именем <code>luaopen_mod</code>.</p>
<h4 id="Chapter15.xhtml#sigil_toc_id_120">Поиск пути</h4>
<p>При поиске файла Lua <code>require</code> использует путь, который несколько отличается от типичных путей. Типичный путь — это список директорий, в которых нужно искать заданный файл. Однако, в ANSI С (абстрактная платформа, на которой выполняется Lua) нет понятия директории. Поэтому путь, используемый <code>require</code>, — это список <em>шаблонов</em> <strong>(template)</strong> каждый из которых задает свой способ преобразования имени модуля (аргумента <code>require</code>) в имя файла. Более точно, каждый шаблон в пути — это имя файла, содержащее необязательные знаки вопроса. Для каждого шаблона <code>require</code> заменяет каждый '<code>?</code>' на имя модуля и проверяет, есть ли файл с получившимся именем; если нет, она переходит к следующему шаблону. Шаблоны в пути разделены точками с запятой (символ, редко используемый в именах файлов в большинстве операционных систем). Например, если путем является</p>
<pre><code>?;?.lua;c:\windows\?;/usr/local/lua/?/?.lua</code></pre>
<p>то вызов <code>require &quot;sql</code>&quot; попробует открыть следующие файлы Lua:</p>
<pre><code>sql
sql.lua
c:\windows\sql
/usr/local/lua/sql/sql.lua</code></pre>
<p>Функция <code>require</code> допускает использование лишь точки с запятой (для разделения составляющих) и вопросительного знака; все остальное, включая разделители директорий и расширения файлов, определяется самим путем.</p>
<p>Путь, который <code>require</code> использует для поиска файлов Lua, — это всегда текущее значение переменной <code>package.path</code>. Во время запуска Lua инициализирует эту переменную значением переменной окружения <code>LUA_PATH_5_2</code>. Если эта переменная окружения не определена, Lua пытается использовать переменную окружения <code>LUA_PATH</code>. Если они обе не определены, Lua использует путь по умолчанию, заданный при компиляции (<span class="underline">Примечание</span>: В Lua 5.2 опция командной строки <code>-E</code> предотвращает использование этих переменных окружения и заставляет использовать значение по умолчанию). При использовании значения переменной окружения Lua подставляет путь по умолчанию вместо любой подстроки &quot;<code>;;</code>&quot;. Например, если вы установите <code>LUA_PATH_5_2</code> на &quot;<code>mydir/?.lua;;</code>&quot;, то окончательный путь будет шаблоном &quot;<code>mydir/?.lua</code>&quot;, за которым следует путь по умолчанию.</p>
<p>Путь для поиска библиотек С работает точно так же, но его значение берется из переменной <code>package.cpath</code> (вместо <code>package.path</code>). Аналогично эта переменная получает свое начальное значение из переменной окружения <code>LUA_CPATH_5_2</code> или <code>LUA_CPATH</code>. Типичным значением этого пути в UNIX является следующее:</p>
<pre><code>./?.so;/usr/local/lib/lua/5.2/?.so</code></pre>
<p>Обратите внимание, что путь определяет расширение файла. Предыдущий пример использует <code>.so</code> для всех шаблонов; в Windows типичный путь будет примерно таким:</p>
<pre><code>.\?.dll;C:\Program Files\Lua502\dll\?.dll</code></pre>
<p>Функция <code>package.searchpath</code> запрограммирована с учетом всех вышеприведенных правил для поиска библиотек. Она получает имя модуля и путь, а затем ищет файл, следуя этим правилам. Она возвращает либо имя первого найденного файла, либо nil и сообщение об ошибке, описывающее все файлы, которые она безуспешно пыталась открыть, как в следующем примере:</p>
<pre><code>&gt; path = &quot;.\\?.dll;C:\\Program Files\\Lua502\\dll\\?.dll&quot;
&gt; print(package.searchpath(&quot;X&quot;, path))
nil
 no file &#39;.\X.dll&#39;
 no file &#39;C:\Program Files\Lua502\dll\X.dll&#39;</code></pre>
<h4 id="Chapter15.xhtml#sigil_toc_id_121">Искатели</h4>
<p>В действительности <code>require</code> несколько сложнее, чем мы описали. Поиск файла Lua и библиотеки С — это лишь два частных случая более общего понятия <em>искателя</em> <strong>(searcher)</strong>. Искатель — это просто функция, которая получает имя модуля и возвращает либо загрузчик для него, либо nil, если не может найти ни одного.</p>
<p>Массив <code>package.searchers</code> содержит перечень искателей, которыми пользуется <code>require</code>. При поиске модуля <code>require</code> поочередно вызывает каждого искателя из этого перечня, передавая ему имя модуля, до тех пор, пока не найдет загрузчик для этого модуля. Если поиск не дает результата, <code>require</code> вызывает ошибку.</p>
<p>В Lua 5.2 параметр командной строки <code>-Е</code> предотвращает использование переменных окружения и приводит к использованию пути, заданного при компиляции.</p>
<p>Использование списка для управления поиском модуля придает огромную гибкость функции <code>require</code>. Например, если вы хотите хранить модули сжатыми в zip-файлы, то вам лишь нужно предоставить соответствующую функцию-искатель и добавить ее к списку. Однако, чаще всего программам все же не нужно изменять содержимое <code>package.searchers</code>. В конфигурации по умолчанию искатель файлов Lua искатель библиотек С, которые мы описали выше, занимают в списке вторую и третью позиции, соответственно. Перед ними стоит искатель предзагрузки.</p>
<p>Искатель <em>предзагрузки</em> <strong>(preload)</strong> позволяет определить для загрузки модуля произвольную функцию. Он использует таблицу <code>package.preload</code> для отображения имен модулей в загрузочные функции. При поиске имени модуля данный искатель просто ищет заданное имя в этой таблице. Если он находит в ней функцию, он возвращает ее в качестве загрузчика модуля. Иначе он возвращает nil. Этот искатель предоставляет общий метод для обработки некоторых нетрадиционных ситуаций. Например, библиотека С, статически прилинкованная к Lua, может зарегистрировать свою функцию <code>luaopen_</code> в таблице <code>preload</code> так, что она будет вызвана, только когда (и если) пользователю понадобится этот модуль. Таким образом, программа не тратит время на открытие модуля, если он не используется.</p>
<p>По умолчанию <code>package.searchers</code> включает в себя четвертую функцию, которая нужна лишь для подмодулей. Мы обсудим ее в разделе 15.4.</p>
<h3 id="Chapter15.xhtml#sigil_toc_id_122">15.2. Основной подход к написанию модулей на Lua</h3>
<p>Простейший способ создать модуль на Lua поистине прост: мы создаем таблицу, помещаем все функции, которые мы хотим экспортировать, внутрь нее и возвращаем эту таблицу. Листинг 15.1 демонстрирует этот подход. Обратите внимание на то, как мы определяем функцию <code>inv</code> в качестве закрытой, просто объявляя ее локальной для этого куска.</p>
<p><strong>Листинг 15.1.</strong> Простой модуль для комплексных чисел</p>
<pre><code>local M = {}

function M.new (r, i) return {r=r, i=i} end

-- определяет константу &#39;i&#39;
M.i = M.new(0, 1)

function M.add (c1, c2)
  return M.new(c1.r + c2.r, c1.i + c2.i)
end

function M.sub (c1, c2)
  return M.new(c1.r - c2.r, c1.i - c2.i)
end

function M.mul (c1, c2)
  return M.new(c1.r*c2.r - c1.i*c2.i, c1.r*c2.i + c1.i*c2.r)
end

local function inv (c)
  local n = c.r^2 + c.i^2
  return M.new(c.r/n, -c.i/n)
end

function M.div (c1, c2)
  return M.mul(c1, inv(c2))
end

function M.tostring (c)
  return &quot;(&quot; .. c.r .. &quot;,&quot; .. c.i .. &quot;)&quot;
end

return M</code></pre>
<p>Некоторым не правится оператор <strong>return</strong> в конце. Одним из способов его устранения является присваивание таблицы модуля непосредственно <code>package.loaded</code>:</p>
<pre><code>local M = {}
package.loaded[...] = M
  &lt;как прежде&gt;</code></pre>
<p>Вспомним, что <code>require</code> вызывает загрузчик, передавая имя модуля как первый аргумент. Поэтому выражение с переменным числом аргументов <code>...</code> в индексе приводит к возврату этого имени. После этого присваивания нам больше не нужно возвращать <code>M</code> в конце модуля: если модуль не возвращает значение, то <code>require</code> вернет текущее значение <code>package.loaded[modname]</code> (если оно не nil). В любом случае, я предпочитаю писать <strong>return</strong> в конце модуля, поскольку это выглядит аккуратнее.</p>
<p>Другой способ записи модуля состоит в определении всех функций как локальных и построении возвращаемой таблицы в конце модуля, как в листинге 15.2. В чем преимущества этого подхода? Вам не нужно начинать каждое имя с <code>M</code>. или чего-то похожего; здесь явный список экспортируемых функций; вы определяете и используете экспортируемые и внутренние функции внутри модуля одним и тем же образом. В чем недостатки этого подхода? Список экспортируемых функций находится в конце модуля, а не в начале, где он был бы более удобен в качестве быстрой справки; и этот список в некоторой степени избыточен, так как каждое имя нужно писать дважды. (Этот последний недостаток может стать преимуществом, поскольку позволяет функциям иметь разные имена снаружи модуля и внутри него, но я думаю, что программисты редко этим пользуются.) Лично мне нравится данный стиль, но вкусы у всех разные.</p>
<p><strong>Листинг 15.2.</strong> Модуль со списком экспортируемых функций</p>
<pre><code>local function new (r, i) return {r=r, i=i} end

-- определяет константу &#39;i&#39;
local i = complex.new(0, 1)

  &lt;другие функции следуют этому же образцу&gt;

return {
  new      = new,
  i        = i,
  add      = add,
  sub      = sub,
  mul      = mul,
  div      = div,
  tostring = tostring,
}</code></pre>
<p>В любом случае, помните, что вне зависимости от того, как определен модуль, пользователи должны иметь возможность использовать его стандартным образом:</p>
<pre><code>local cpx = require &quot;complex&quot;
print(cpx.tostring(cpx.add(cpx.new(3,4), cpx.i)))
  --&gt; (3,5)</code></pre>
<h3 id="Chapter15.xhtml#sigil_toc_id_123">15.3. Использование окружений</h3>
<p>Одним из недостатков тех базовых методов для создания модулей является то, что с ними слишком легко засорить глобальное пространство имен, например просто забыв <strong>local</strong> в закрытом объявлении.</p>
<p>Окружения предоставляют интересный подход к созданию модулей, который решает эту проблему. Когда у главного куска модуля есть свое окружение, то в эту таблицу переходят не только все его функции, но и все глобальные переменные. Поэтому мы можем объявить все открытые функции в качестве глобальных переменных, и они автоматически попадут в отдельную таблицу. Все, что нужно сделать модулю, — присвоить эту таблицу переменной <code>_ENV</code>. После этого, когда мы объявим функцию <code>add</code>, она станет <code>M.add</code>:</p>
<pre><code>local M = {}
_ENV = M
function add (c1, c2)
  return new(c1.r + c2.r, c1.i + c2.i)
end</code></pre>
<p>Более того, мы можем вызывать другие функции из этого же модуля без какого-либо префикса. В предыдущем коде <code>add</code> обращается к <code>new</code> из своего окружения, то есть вызывает <code>M.new</code>.</p>
<p>Этот метод обеспечивает хорошую поддержку модулей, требуя очень небольшой работы от программиста. Префиксы с ним вообще не нужны. Нет никакой разницы между вызовом экспортированной и закрытой функций. Если программист забывает вставить <strong>local</strong>, то он не засоряет глобальное пространство имен; вместо этого закрытая функция просто становится открытой.</p>
<p>Тем не менее, в настоящее время я по-прежнему предпочитаю один из двух методов, рассмотренных в предыдущем разделе. Хотя они могут потребовать чуть больше работы, результат выполнения такого кода более понятен. Чтобы не создать по ошибке глобальную переменную, я пользуюсь простым методом, который состоит в присваивании <code>_ENV</code> значения nil. После этого любое присваивание глобальной переменной вызовет ошибку.</p>
<p>Чего при этом не хватает, так это, разумеется, доступа к другим модулям. Как только мы изменим значение <code>_ENV</code>, мы потеряем доступ ко всем предыдущим глобальным переменным. Есть несколько способов восстановить этот доступ, каждый со своими плюсами и минусами.</p>
<p>Первый способ состоит в применении наследования:</p>
<pre><code>local M = {}
setmetatable(M, {__index = _G})
_ENV = M</code></pre>
<p>(Вам нужно вызвать <code>setmetatable</code> перед присваиванием <code>_ENV</code>; зачем?) С данной конструкцией у модуля есть прямой доступ к любому глобальному идентификатору, с небольшими затратами при каждом обращении. Любопытным последствием этого решения является то, что ваш модуль, по идее, теперь содержит все глобальные переменные. Например, любой, кто использует ваш модуль, теперь может вызывать стандартную функцию для вычисления синуса, написав <code>complex.math.sin(х)</code>. (Данная особенность также есть в системе пакетов Perl.)</p>
<p>Еще одним быстрым методом доступа к другим модулям является объявление локальной переменной, которая хранит исходное окружение:</p>
<pre><code>local M = {}
local _G = _G
_ENV = M        -- или _ENV = nil</code></pre>
<p>Теперь вы должны начинать каждое глобальное имя с <code>_G.</code>, но доступ происходит немного быстрее, поскольку никакие метаметоды не задействованы.</p>
<p>Более взвешенный подход заключается в том, чтобы объявить локальными только те функции, которые вам нужны, или, по крайней мере, лишь нужные вам модули:</p>
<pre><code>-- настройка модуля
local M = {}

-- Импортируемая секция:
-- объявляет все, что этому модулю потребуется извне
local sqrt = math.sqrt
local io = io

-- с данного момента внешнего доступа больше нет
_ENV = nil -- or _ENV = M</code></pre>
<p>Этот подход требует больше работы, но он лучше документирует зависимости вашего модуля. При этом код, который получается при его применении, выполняется немного быстрее, чем в прежних схемах, из-за использования локальных переменных.</p>
<h3 id="Chapter15.xhtml#sigil_toc_id_124">15.4. Подмодули и пакеты</h3>
<p>Lua разрешает именам модулей быть иерархическими, используя точку для разделения уровней имен. Например, модуль с именем <code>mod.sub</code> является <em>подмодулем</em> модуля <code>mod</code>. <em>Пакет</em> — это полное дерево модулей; он является единицей распространения кода в Lua.</p>
<p>Когда вам нужен модуль с именем <code>mod.sub</code>, функция <code>require</code> сперва обращается к таблице <code>package.loaded</code>, а затем к таблице <code>package.preload</code>, используя полное имя &quot;<code>mod.sub</code>&quot; в качестве ключа; в этом случае точка является таким же символом в имене модуля, как и любой другой.</p>
<p>Однако, при поиске файла, определяющего этот подмодуль, <code>require</code> переводит точку в другой символ, обычно системный разделитель директорий (то есть '<code>/</code>' для UNIX и '<code>\</code>' для Windows). После этого преобразования <code>require</code> ищет получившееся имя, как и любое другое. Предположим, что у нас есть разделитель директорий '<code>/</code>' и следующий путь:</p>
<pre><code>./?.lua;/usr/local/lua/?.lua;/usr/local/lua/?/init.lua</code></pre>
<p>Вызов <code>require &quot;a.b&quot;</code> попробует открыть следующие файлы:</p>
<pre><code>./a/b.lua
/usr/local/lua/a/b.lua
/usr/local/lua/a/b/init.lua</code></pre>
<p>Это поведение позволяет всем модулям пакета находиться в одной директории. Например, если в пакете содержатся модули <code>р</code>, <code>р.а</code> и <code>р.b</code>, то соответствующими файлами могут быть <code>p/init.lua</code>, <code>р/а.lua</code> и <code>p/b.lua</code>, директория <code>р</code> которых содержится в другой подходящей директории.</p>
<p>Разделитель директорий, используемый Lua, настраивается во время компиляции и может быть любой строкой (вспомните, что Lua ничего не знает про директории). Например, системы без иерархических директорий могут использовать в качестве такого разделителя '<code>_</code>', так что <code>require &quot;a.b</code>&quot; будет искать файл <code>a_b.lua</code>.</p>
<p>Имена в С не могут содержать точки, поэтому библиотека С для подмодуля <code>а.b</code> не может экспортировать функцию <code>luaopen_a.b</code>. В этом случае <code>require</code> переводит точку в другой символ — подчеркивание. Таким образом, библиотека С с именем <code>а.b</code> должна назвать свою инициализирующую функцию <code>luaopen_a_b</code>. Мы также можем воспользоваться здесь уловкой с дефисом, что может пригодиться в некоторых случаях. Например, если у нас есть библиотека С с именем <code>а</code> и мы хотим сделать ее подмодулем <code>mod</code>, то мы можем переименовать ее файл в <code>mod/v-a</code>. Когда мы напишем <code>require &quot;mod.v-a</code><code>&quot;</code>, функция <code>require</code> правильно найдет новый файл <code>mod/v-a</code>, так же как и функцию <code>luaopen_a</code> внутри него.</p>
<p>В качестве дополнительного средства у <code>require</code> есть еще один искатель для загрузки подмодулей С. Когда он не может найти ни файл Lua, ни файл С для подмодуля, этот искатель опять ищет в пути для С, но на этот раз он ищет имя пакета. Например, если программе требуется подмодуль <code>а.b.с</code>, этот искатель будет искать <code>а</code>. Если он найдет библиотеку С с этим именем, то <code>require</code> будет искать в этой библиотеке соответствующую открывающую функцию, в нашем случае <code>luaopen_a_b_c</code>. Данное средство позволяет размещать несколько подмодулей в одной библиотеке С, каждый со своей открывающей функцией.</p>
<p>С точки зрения Lua, подмодули в одном пакете не имеют явной связи. Загрузка модуля <code>а</code> не приводит к автоматической загрузке любого из ее подмодулей; аналогично, при загрузке <code>a.b</code> не произойдет автоматической загрузки <code>а</code>. Конечно, разработчик пакета при желании может задать эти связи. Например, модуль <code>а</code> может при загрузке явно потребовать один или все свои подмодули.</p>
<h3 id="Chapter15.xhtml#sigil_toc_id_125">Упражнения</h3>
<p><strong>Упражнение 15.1.</strong> Перепишите код в листинге 13.1 в виде соответственного модуля.</p>
<p><strong>Упражнение 15.2.</strong> Что случится при поиске библиотеки, если какая-то часть пути зафиксирована (то есть не содержит знак вопроса)? Может ли пригодиться такое поведение?</p>
<p><strong>Упражнение 15.3.</strong> Напишите искатель, который одновременно ищет файлы Lua и библиотеки <span style="text-indent: 1.5em;">С. Например, путь для этого искателя может быть чем-то вроде:</span></p>
<pre><code>./?.lua;./?.so;/usr/lib/lua5.2/?.so;/usr/share/lua5.2/?.lua</code></pre>
<p>(Подсказка: используйте <code>package.searchpath</code> для поиска соответствующего файла и потом попытайтесь загрузить его, сначала при помощи <code>loadfile</code>, а затем при помощи <code>package.loadlib</code>.)</p>
<p><strong>Упражнение 15.4.</strong> Что случится, если вы установите метатаблицу для <code>package.preload</code> при помощи метаметода <code>__index</code>? Может ли пригодиться такое поведение?</p>
<p><span id="Chapter16.xhtml"></span></p>
<h2>ГЛАВА 16</h2>
<h2 id="Chapter16.xhtml#sigil_toc_id_126">Объектно-ориентированное программирование</h2>
<p>Таблица в Lua — это объект во многих отношениях. Подобно объектам, у таблиц есть состояние. Подобно объектам, у таблиц есть идентичность (собственное «я» — <em>self</em>), которая не зависит от ее значений; в частности, две таблицы с одинаковыми значениями являются разными объектами, и при этом каждый объект может иметь разные значения в разные моменты времени. Подобно объектам, у таблиц есть жизненный цикл, который не зависит от того, кто их создал или где они были созданы.</p>
<p>У объектов есть свои собственные действия. У таблиц также могут быть действия, как показано ниже:</p>
<pre><code>Account = {balance = 0}
function Account.withdraw (v)
  Account.balance = Account.balance - v
end</code></pre>
<p>Это определение создает новую функцию и хранит ее в поле <code>withdraw</code> объекта <code>Account</code>. Затем мы можем вызвать ее, как показано ниже:</p>
<pre><code>Account.withdraw(100.00)</code></pre>
<p>Данная разновидность функции — это почти то, что мы называем <em>методом</em>. Однако, использование глобального имени <code>Account</code> внутри функции является плохой практикой программирования. Во-первых, эта функция будет работать только для данного конкретного объекта. Во-вторых, даже для этого объекта функция будет работать ровно до тех пор, пока этот объект хранится в той конкретной глобальной переменной. Если мы изменим имя объекта, то <code>withdraw</code> больше не будет работать:</p>
<pre><code>a, Account = Account, nil
a.withdraw(100.00)    -- ОШИБКА!</code></pre>
<p>Подобное поведение нарушает принцип, что у каждого объекта должен быть свой, независимый цикл жизни.</p>
<p>Более гибкий подход состоит в работе с <em>получателем</em> <strong>(receiver)</strong> операции. Для этого нашему методу понадобится дополнительный параметр со значением получателя. Этот параметр обычно называется <em>self</em> или <em>this</em>:</p>
<pre><code>function Account.withdraw (self, v)
  self.balance = self.balance - v
end</code></pre>
<p>Теперь при вызове метода мы должны задать объект, над которым он должен работать:</p>
<pre><code>a1 = Account; Account = nil
...
a1.withdraw(a1, 100.00)    -- OK</code></pre>
<p>При использовании параметра <em>self</em> мы можем использовать один и тот же метод для многих объектов:</p>
<pre><code>a2 = {balance=0, withdraw = Account.withdraw}
...
a2.withdraw(a2, 260.00)</code></pre>
<p>Данное применение параметра <em>self</em> является ключевым моментом в любом объектно-ориентированном языке. В большинстве объектно-ориентированных языков данный механизм частично скрыт от программиста, поэтому этот параметр не нужно объявлять (хотя он можно по-прежнему пользоваться именем <em>self</em> или <em>this</em> внутри метода). Lua также может скрывать этот параметр при помощи <em>операции двоеточия</em>. Мы можем переписать предыдущее определение метода в виде</p>
<pre><code>function Account:withdraw (v)
  self.balance = self.balance - v
end</code></pre>
<p>а вызов метода как</p>
<pre><code>a:withdraw(100.00)</code></pre>
<p>Двоеточие добавляет дополнительный скрытый параметр в определение метода и добавляет дополнительный аргумент в вызов метода. Двоеточие является всего лишь синтаксическим сахаром, хотя и довольно удобным; ничего принципиально нового здесь нет. Мы можем определить функцию, воспользовавшись точкой, и вызвать ее, применив двоеточие, или наоборот, до тех пор, пока мы правильно обрабатываем дополнительный параметр:</p>
<pre><code>Account = { balance=0,
            withdraw = function (self, v)
                         self.balance = self.balance - v
                       end
          }

function Account:deposit (v)
  self.balance = self.balance + v
end

Account.deposit(Account, 200.00)
Account:withdraw(100.00)</code></pre>
<p>К данному моменту у наших объектов есть идентичность, состояние и действия над этим состоянием. Им по-прежнему не хватает системы классов, наследования и скрытия членов. Давайте займемся первой задачей: как нам создать различные объекты с одинаковым поведением? В частности, как нам создать несколько счетов?</p>
<h3 id="Chapter16.xhtml#sigil_toc_id_127">16.1. Классы</h3>
<p>Класс работает как шаблон для создания объектов. Большинство объектно-ориентированных языков предлагает понятие класса. В таких языках каждый объект является экземпляром какого-то конкретного класса. В Lua нет понятия класса; каждый объект определяет свое собственное поведение и состояние. Однако, смоделировать в Lua классы не трудно, если следовать примеру языков на основе прототипов, вроде Self или NewtonScript. В этих языках у объектов нет классов. Вместо этого у каждого объекта может быть прототип, который является обычным объектом, в котором первый объект ищет неизвестные ему действия. Для представления классов в таких языках мы просто создаем объект, который будет использован только в качестве прототипа для других объектов (его экземпляров). И классы, и прототипы работают в качестве мест хранения поведения, общего для различных объектов.</p>
<p>В Lua мы можем реализовать прототипы, используя идею наследования из раздела 13.4. Точнее, если у нас есть два объекта <code>а</code> и <code>b</code>, то все, что нам нужно сделать, чтобы <code>b</code> стал прототипом для <code>а</code>, — это следующее:</p>
<pre><code>setmetatable(a, {__index = b})</code></pre>
<p>После этого <code>а</code> будет искать в <code>b</code> любое действие, которого у нет. Называть объект <code>b</code> классом объекта <code>а</code> — это не что иное, как замена терминов.</p>
<p>Давайте вернемся к нашему примеру с банковским счетом. Для создания других счетов с поведением, аналогичным <code>Account</code>, мы сделаем так, что эти новые объекты унаследуют свои действия от <code>Account</code> при <span>помощи метаметода</span> <code>__index</code><span>. Небольшая оптимизация будет состоять в том, что нам не нужно</span> <span>создавать дополнительную таблицу в качестве метатаблицы для объектов</span> <code>Account</code><span>; для этой цели мы будем использовать саму таблицу</span> <code>Account</code><span>:</span></p>
<pre><code>function Account:new (o)
  o = o or {}    -- создает таблицу, если пользователь ее не предоставил
  setmetatable(o, self)
  self.__index = self
  return o
end</code></pre>
<p>(Когда мы вызываем <code>Account:new</code>, параметр <code>self</code> равен <code>Account</code>; поэтому мы могли бы явно использовать <code>Account</code> вместо <code>self</code>. Однако, использование <code>self</code> отлично пригодится в следующем разделе, когда мы введем наследование.) Что произойдет после выполнения данного кода, когда мы создадим новый счет и вызовем его метод, как показано ниже?</p>
<pre><code>a = Account:new{balance = 0}
a:deposit(100.00)</code></pre>
<p>Когда мы создаем новый счет, у <code>а</code> в качестве метатаблицы будет <code>Account</code> (из-за параметра <code>self</code> в вызове <code>Account:new</code>). Затем, когда мы вызываем <code>а:deposit(100.00)</code>, на самом деле происходит вызов <code>a.deposit(а,100.00)</code>; двоеточие — это всего лишь синтаксический сахар. Однако, Lua не может найти запись &quot;<code>deposit</code>&quot; в таблице <code>а</code>; поэтому Lua ищет запись <code>__index</code> в метатаблице. Теперь ситуация выглядит примерно следующим образом:</p>
<pre><code>getmetatable(a).__index.deposit(a, 100.00)</code></pre>
<p>Метатаблицей <code>а</code> является <code>Account</code>, а <code>Account.__index</code> — это тоже <code>Account</code> (поскольку метод <code>new</code> выполнил <code>self.__index=self</code>). <span style="text-indent: 1.5em;">Поэтому предыдущее выражение сокращается до</span></p>
<pre><code>Account.deposit(a, 100.00)</code></pre>
<p>То есть Lua вызывает исходную функцию <code>deposit</code>, но передает ей <code>а</code> в качестве параметра <code>self</code>. Таким образом, новый счет <code>а</code> унаследовал функцию <code>deposit</code> от <code>Account</code>. По этой же схеме он наследует все поля от <code>Account</code>.</p>
<p>Это наследование работает не только для методов, но также и для других полей, отсутствующих в новом счете. Поэтому класс может предоставлять не только методы, но и значения по умолчанию для полей <span>экземпляра. Напомним, что в нашем первом определении</span> <code>Account</code> <span>мы предоставили поле</span> <code>balance</code> <span>со значением 0. Поэтому если мы создадим счет без начального значения баланса, то он унаследует это значение по умолчанию:</span></p>
<pre><code>b = Account:new()
print(b.balance)    --&gt; 0</code></pre>
<p>При вызове метода <code>deposit</code> у <code>b</code> он выполнит код, эквивалентный следующему (поскольку <code>self</code> равен <code>b</code>):</p>
<pre><code>b.balance = b.balance + v</code></pre>
<p>Выражение <code>b.balance</code> дает 0, и метод присваивает начальный вклад <code>b.balance</code>. Последующие обращения к <code>b.balance</code> уже не приведут к вызову метаметода <code>__index</code>, так как у <code>b</code> теперь есть свое собственное поле <code>balance</code>.</p>
<h3 id="Chapter16.xhtml#sigil_toc_id_128">16.2. Наследование</h3>
<p>Поскольку классы являются объектами, они также могут получать методы от других классов. Это поведение позволяет легко реализовать наследование (в обычном объектно-ориентированном смысле) в Lua.</p>
<p>Пусть у нас есть базовый класс, такой как <code>Account</code>:</p>
<pre><code>Account = {balance = 0}

function Account:new (o)
  o = o or {}
  setmetatable(o, self)
  self.__index = self
  return o
end

function Account:deposit (v)
  self.balance = self.balance + v
end

function Account:withdraw (v)
  if v &gt; self.balance then error&quot;insufficient funds&quot; end
  self.balance = self.balance - v
end</code></pre>
<p>От этого класса мы можем унаследовать подкласс <code>SpecialAccount</code>, позволяющий покупателю снять больше, чем есть на его балансе. Мы начинаем с пустого класса, который просто наследует все свои операции от своего базового класса:</p>
<pre><code>SpecialAccount = Account:new()</code></pre>
<p>До сих пор <code>SpecialAccount</code> является лишь одним из экземпляров <code>Account</code>. Теперь происходит замечательная вещь:</p>
<pre><code>s = SpecialAccount:new{limit=1000.00}</code></pre>
<p><code>SpecialAccount</code> наследует <code>new</code> от <code>Account</code>, как и любые другие методы. Однако, на этот раз при выполнении <code>new</code> его параметр <code>self</code> уже будет ссылаться на <code>SpecialAccount</code>. Поэтому метатаблицей <code>s</code> будет <code>SpecialAccount</code>, чье значение в поле <code>__index</code> тоже равно <code>SpecialAccount</code>. Поэтому <code>s</code> наследует от <code>SpecialAccount</code>, который, в свою очередь, наследует от <code>Account</code>. При вычислении</p>
<pre><code>s:deposit(100.00)</code></pre>
<p>Lua не сможет найти поле <code>deposit</code> в <code>s</code>, поэтому он будет искать его в <code>SpecialAccount</code>; там его он тоже не найдет и потому поищет в <code>Account</code>, где и обнаружит исходную реализацию этого метода.</p>
<p>Что делает <code>SpecialAccount</code> особенным, так это то, что мы можем переопределить любой метод, унаследованный от его суперкласса. Все, что нам нужно, — это просто записать новый метод:</p>
<pre><code>function SpecialAccount:withdraw (v)
  if v - self.balance &gt;= self:getLimit() then
    error&quot;insufficient funds&quot;
  end
  self.balance = self.balance - v
end

function SpecialAccount:getLimit ()
  return self.limit or 0
end</code></pre>
<p>Теперь, когда мы вызовем <code>s:withdraw(200.00)</code>, Lua не обратится к <code>Account</code>, поскольку первым он найдет новый метод <code>withdraw</code> в классе <code>SpecialAccount</code>. Так как <code>s.limit</code> равно 1000.00 (как вы помните, мы задали это поле при создании <code>s</code>), то программа осуществит снятие со счета, оставляя в результате <code>s</code> с отрицательным балансом.</p>
<p>У объектов в Lua есть интересный аспект: вам не нужно создавать новый класс для задания нового поведения. Если требуется изменить поведение лишь одного объекта, то мы можем реализовать данное поведение непосредственно в этом объекте. Например, если счет <code>s</code> представляет особого клиента, чей лимит всегда равен 10% от текущего баланса, то мы можем изменить лишь этот один счет:</p>
<pre><code>function s:getLimit ()
  return self.balance * 0.10
end</code></pre>
<p>После данного объявления вызов <code>s:withdraw(200.0)</code> выполнит метод <code>withdraw</code> из класса <code>SpecialAccount</code>, но когда <code>withdraw</code> вызовет <code>self:getLimit</code>, произойдет вызов только что определенной функции.</p>
<h3 id="Chapter16.xhtml#sigil_toc_id_129">16.3. Множественное наследование</h3>
<p>Поскольку в Lua объекты не являются примитивами, в нем есть несколько способов реализации объектно-ориентированного программирования. Подход с применением метаметода <code>__index</code>, который мы только что видели, является, наверное, лучшей комбинацией простоты, скорости и гибкости. Однако, есть и другие реализации, которые могут оказаться более подходящими в некоторых частных случаях. Ниже мы увидим альтернативную реализацию, которая обеспечивает множественное наследование в Lua.</p>
<p>Основой данной реализации является использование функции для метаполя <code>__index</code>. Вспомним о том, что когда у метатаблицы некоторой таблицы есть функция в поле <code>__index</code>, Lua будет вызывать эту функцию всякий раз, когда не сможет найти ключ в этой исходной таблице. При этом <code>__index</code> может искать отсутствующий ключ в любом количестве родительских классов.</p>
<p>Множественное наследование означает, что у класса может быть более одного суперкласса. Таким образом, мы не можем использовать метод класса для создания подклассов. Взамен с этой целью мы определим особую функцию <code>createClass</code>, у которой в качестве аргументов суперклассы нового класса (см. листинг 16.1). Эта функция создает таблицу для представления нового класса и устанавливает его метатаблицу с метаметодом <code>__index</code>, который и реализует множественное наследование. Несмотря на множественное наследование, каждый созданный объект по-прежнему принадлежит одному классу, в котором он ищет все свои методы. Поэтому отношения между классами и суперклассами отличается от отношений между классами и его экземплярами. В частности, класс не может одновременно быть метатаблицей для своих экземпляров и своих подклассов. В листинге 6.1 мы используем класс как метатаблицу для его экземпляров и создаем другую таблицу в качестве метатаблицы класса.</p>
<p><strong>Листинг 16.1.</strong> Реализация множественного наследования</p>
<pre><code>-- ищет &#39;k&#39; в списке таблиц &#39;plist&#39;
local function search (k, plist)
  for i = 1, #plist do
    local v = plist[i][k]    -- пробует&#39;i&#39;-ый суперкласс
    if v then return v end
  end
end

function createClass (...)
  local c = {}    -- новый класс
  local parents = {...}

  -- класс будет искать каждый метод в списке своих родительских классов
  setmetatable(c, {__index = function (t, k)
    return search(k, parents)
  end})

  -- подготавливает &#39;c&#39; стать метатаблицей для своих экземпляров
  c.__index = c

  -- определяет новый конструктор для этого нового класса
  function c:new (o)
    o = o or {}
    setmetatable(o, c)
    return o
  end

  return c    -- возвращает новый класс
end</code></pre>
<p>Давайте проиллюстрируем использование <code>createClass</code> при помощи небольшого примера. Пусть у нас есть наш предыдущий класс <code>Account</code> и новый класс <code>Named</code> лишь с двумя методами: <code>setname</code> и <code>getname</code>.</p>
<pre><code>Named = {}
function Named:getname ()
  return self.name
end

function Named:setname (n)
  self.name = n
end</code></pre>
<p>Для создания нового класса <code>NamedAccount</code>, который является подклассом и <code>Account</code>, и <code>Named</code>, мы просто вызовем <code>createClass</code>:</p>
<pre><code>NamedAccount = createClass(Account, Named)</code></pre>
<p>Мы создаем и используем экземпляры этого класса как обычно:</p>
<pre><code>account = NamedAccount:new{name = &quot;Paul&quot;}
print(account:getname())    --&gt; Paul</code></pre>
<p>Теперь давайте проследим, как работает этот последний оператор. Lua не может найти поле &quot;<code>getname</code>&quot; в <code>account</code>; поэтому он ищет поле <code>__index</code> в метатаблице <code>account</code>, то есть в <code>NamedAccount</code>. Но в <code>NamedAccount</code> также нет поля &quot;<code>getname</code>&quot;, поэтому Lua ищет поле <code>__index</code> в метатаблице <code>NamedAccount</code>. Поскольку это поле содержит функцию, Lua вызывает ее. Далее эта функция сперва ищет &quot;<code>getname</code>&quot; в <code>Account</code> и, не обнаружив его, проверяет <code>Named</code>, где она и находит отличное от nil значение, которое и становится окончательным результатом поиска.</p>
<p>Конечно, из-за сложной структуры такого поиска быстродействие множественного наследования не такое же, как у одиночного. Простым способом улучшить это быстродействие является копирование унаследованных методов в подклассы. С использованием этого подхода метаметод <code>__index</code> для классов будет выглядеть следующим образом:</p>
<pre><code>setmetatable(c, {__index = function (t, k)
  local v = search(k, parents)
  t[k] = v     -- сохраняет для следующего обращения
  return v
end})</code></pre>
<p>При помощи данного приема доступ к унаследованным методам становится столь же быстрым, как и доступ к локальным методам (за исключением первого обращения). Недостаток состоит в том, что во время выполнения сложно изменить определения методов, поскольку эти изменения не передаются по цепочке наследования.</p>
<h3 id="Chapter16.xhtml#sigil_toc_id_130">16.4. Конфиденциальность</h3>
<p>Многие считают конфиденциальность (возможность скрытия элементов) неотъемлемой частью объектно-ориентированного языка; состояние каждого объекта является его личным делом. В некоторых объектно-ориентированных языках, таких как C++ и Java, вы можете управлять тем, будет ли поле объекта (также называемое <em>экземплярной переменной</em>) или его метод видны вне этого объекта. Язык Smalltalk, который популяризовал объектно-ориентированные языки, делает все переменные закрытыми <strong>(private)</strong>, а все методы открытыми <strong>(public)</strong>. Simula, самый первый объектно-ориентированный язык, вообще не обеспечивал защиту данных.</p>
<p>Основная схема работы с объектами в Lua, которую мы рассмотрели до этого, не предоставляет механизмы скрытия. Частично это является следствием нашего применения общих структур (таблиц) для представления объектов. Кроме того, Lua избегает чрезмерной избыточности и искусственных ограничений. Если вы не хотите обращаться к чему-либо внутри объекта, то <em>просто не делайте этого</em>.</p>
<p>Тем не менее, Lua стремится оставаться гибким, предлагая метамеханизмы, позволяющие моделировать множество прочих механизмов. Хотя базовая схема работы с объектами в Lua не предусматривает механизмы скрытия, мы можем реализовать объекты иначе, и таким образом получить управление доступом. Хотя программисты нечасто применяют данную реализацию, узнать о ней будет полезным, поскольку она приоткрывает некоторые интересные аспекты Lua и может пригодиться для решения других задач.</p>
<p>Основная идея этой альтернативной схемы — представлять каждый объект при помощи двух таблиц: одна — для его состояния, а другая — для его действий (его интерфейс). Обращение к самому объекту происходит через вторую таблицу, то есть посредством действий, образующих его интерфейс. Во избежание несанкционированного доступа, таблица, представляющая состояние объекта, не хранится в поле другой таблицы; вместо этого она хранится лишь в замыкании методов. Например, применив данную схему для представления банковского счета, мы могли бы создавать новые объекты при помощи следующей функции-фабрики:</p>
<pre><code>function newAccount (initialBalance)
  local self = {balance = initialBalance}

  local withdraw = function (v)
                     self.balance = self.balance - v
                   end

  local deposit = function (v)
                    self.balance = self.balance + v
                  end

  local getBalance = function () return self.balance end

  return {
    withdraw = withdraw,
    deposit = deposit,
    getBalance = getBalance
  }
end</code></pre>
<p>Сначала функция создает таблицу для содержания внутреннего состояния объекта и хранит ее в локальной переменной <code>self</code>. Затем функция создает методы этого объекта. Наконец, функция создает и возвращает внешний объект, который отображает имена методов на их настоящие реализации. Ключевой момент здесь в том, что эти методы не получают <code>self</code> как дополнительный параметр; вместо этого они обращаются к <code>self</code> напрямую. Поскольку дополнительного аргумента нет, мы не используем синтаксис с двоеточием для работы с такими объектами. Мы вызываем их методы просто как обычные функции:</p>
<pre><code>acc1 = newAccount(100.00)
acc1.withdraw(40.00)
print(acc1.getBalance())    --&gt; 60</code></pre>
<p>Эта схема обеспечивает полную конфиденциальность всего, что хранится в таблице <code>self</code>. После возврата управления из функции <code>newAccount</code> нет никакого способа получить прямой доступ к этой таблице. Хотя наш пример помещает в таблицу скрытия лишь одну экземплярную переменную, мы можем хранить в этой таблице все закрытые части объекта. всего одну переменную в закрытой таблице, мы можем хранить все закрытые части объекта в этой таблице. Таким же образом мы можем определить и закрытые методы: они похожи на открытые, но мы не помещаем их в интерфейс. Например, наши счета могли бы предоставлять дополнительный 10%-ый кредит тем пользователям, чей баланс уже превысил определенный лимит, но нам не нужно, чтобы у пользователей был доступ к деталям таких расчетов. Мы можем реализовать эту функциональность следующим образом:</p>
<pre><code>function newAccount (initialBalance)
  local self = {
    balance = initialBalance,
    LIM = 10000.00,
  }

  local extra = function ()
    if self.balance &gt; self.LIM then
      return self.balance*0.10
    else
      return 0
  end
end

local getBalance = function ()
return self.balance + extra()
end

&lt;как прежде&gt;</code></pre>
<p>Опять же, ни один пользователь никоим образом не может обратиться к <code>extra</code> напрямую.</p>
<h3 id="Chapter16.xhtml#sigil_toc_id_131">16.5. Подход с единственным методом</h3>
<p>Частным случаем предыдущего подхода для объектно-ориентированного программирования является случай, когда у объекта есть лишь один метод. В подобном случае нам не нужно создавать интерфейсную таблицу; мы можем просто вернуть этот единственный метод в качестве представления объекта. Если это звучит немного странно, то стоит перечитать раздел 7.1, где мы конструировали итерирующие функции, хранящие свое состояние как замыкания. Итератор, хранящий свое состояние, — это ничто иное как объект с одним методом.</p>
<p>Другим интересным случаем объектов с единственным методом является случай, когда этот метод на самом деле диспетчером, который выполняет различные задачи в зависимости от выделенного с этой целью аргумента. Возможная реализация такого объекта приведена ниже:</p>
<pre><code>function newObject (value)
  return function (action, v)
    if action == &quot;get&quot; then return value
    elseif action == &quot;set&quot; then value = v
    else error(&quot;invalid action&quot;)
    end
  end
end</code></pre>
<p>Его использование не вызывает затруднений:</p>
<pre><code>d = newObject(0)
print(d(&quot;get&quot;))    --&gt; 0
d(&quot;set&quot;, 10)
print(d(&quot;get&quot;))    --&gt; 10</code></pre>
<p>Такая необычная реализация объектов весьма эффективна. Синтаксис <code>d(&quot;set&quot;,10)</code> хотя и выглядит странно, всего на два символа длиннее, чем более традиционный <code>d:set(10)</code>. Каждый объект использует одно единственное замыкание, что дешевле одной таблицы. Здесь нет наследования, но зато у нас есть полная конфиденциальность: обратиться к состоянию объекта можно лишь одним способом — через его единственный метод.</p>
<p>Tcl/Tk использует схожий подход для своих виджетов. Имя виджета в Tk обозначает функцию (<em>команду виджета</em>), которая может выполнять все виды действий над виджетом.</p>
<h3 id="Chapter16.xhtml#sigil_toc_id_132">Упражнения</h3>
<p><strong>Упражнение 16.1.</strong> Реализуйте класс <code>Stack</code> с методами <code>push</code>, <code>pop</code>, <code>top</code> и <code>isempty</code>.</p>
<p><strong>Упражнение 16.2.</strong> Реализуйте класс <code>StackQueue</code> как подкласс <code>Stack</code>. Кроме унаследованных методов, добавьте к этому классу метод <code>insertbottom</code>, который вставляет элемент в конец стека. (Этот метод позволяет использовать объекты данного класса как очереди.)</p>
<p><strong>Упражнение 16.3.</strong> Другой способ обеспечить конфиденциальность объектов — это реализовать их через посредников (см. раздел 13.4). Каждый объект представлен пустой таблицей-посредником. Внутренняя таблица отображает посредников на таблицы, хранящие состояние объекта. Эта внутренняя таблица не доступна снаружи, но методы используют ее для перевода своего параметра <code>self</code> в реальную таблицу, с которой они работают. Реализуйте пример с классом <code>Account</code> при помощи этого подхода и рассмотрите его плюсы и минусы.</p>
<p>(С этим подходом есть одна маленькая проблема. Постарайтесь найти ее сами или обратитесь к разделу 17.3, где предлагается ее решение.)</p>
<p><span id="Chapter17.xhtml"></span></p>
<h2>ГЛАВА 17</h2>
<h2 id="Chapter17.xhtml#sigil_toc_id_133">Слабые таблицы и финализаторы</h2>
<p>Lua осуществляет автоматическое управление памятью. Программы создают объекты (таблицы, нити и т. п.), но функции уничтожения объектов не существует. Lua автоматически уничтожает объекты, которые становятся мусором, при помощи <em>сборки мусора</em>. Это освобождает вас от бремени управления памятью и, что более важно, освобождает от большинства ошибок, связанных с этой деятельностью, таких как повисшие указатели и утечки памяти.</p>
<p>Применение сборщика мусора означает, что у Lua нет проблем с циклами. Вам не нужно предпринимать никаких специальных действий при использовании циклических структур данных; они освобождаются автоматически, как и любые другие данные. Тем не менее, иногда даже умному сборщику мусора нужна ваша помощь. Ни один сборщик мусора не позволит вам забыть обо всех проблемах управления ресурсами, таких как переполнение памяти и внешние ресурсы.</p>
<p>Слабые таблицы и финализаторы — это механизмы, которые вы можете использовать в Lua, чтобы помочь сборщику мусора. Слабые таблицы позволяют сбор объектов Lua, которые все еще доступны программе, в то время как финализаторы позволяют сборку внешних объектов, не находящихся под непосредственным контролем сборщика мусора. В этой главе мы обсудим оба этих механизма.</p>
<h3 id="Chapter17.xhtml#sigil_toc_id_134">17.1. Слабые таблицы</h3>
<p>Сборщик мусора может собрать только то, что гарантированно является мусором; он не может догадаться, что считаете мусором именно вы. Типичным примером является стек, реализованный как массив с индексом для вершины стека. Вы знаете, что допустима лишь та часть массива, которая идет до вершины, но этого не знает Lua. Если вы выталкиваете элемент, просто уменьшая индекс вершины, то оставшийся в массиве объект не является мусором для Lua. Точно так же любой объект, который хранится в глобальной переменной, не будет мусором для Lua, даже если ваша программа никогда не воспользуется им снова. В обоих случаях вам (т.е. вашей программе) придется позаботиться о присваивании nil этим позициям, чтобы они в дальнейшем не помешали уничтожению данного объекта.</p>
<p>Тем не менее, простой чистки ваших ссылок не всегда достаточно. Для некоторых конструкций нужно организовать дополнительное взаимодействие между программой и сборщиком мусора. Типичным примером является хранение в вашей программе коллекции всех живых объектов определенного вида (например, файлов). Задача кажется простой: вам лишь требуется вставлять каждый новый объект в коллекцию. Однако, как только объект становится частью этой коллекции, его уничтожение становится невозможным! Даже если на него не ссылаются другие объекты, на него ссылается сама коллекция. Lua не может знать о том, что эта ссылка не должна препятствовать утилизации данного объекта, если только вы не сообщили Lua этот факт.</p>
<p>Слабые таблицы — это тот механизм, который вы используете, чтобы указать Lua на то, что ссылка не должна препятствовать уничтожению объекта. <em>Слабая ссылка</em> <strong>(weak reference)</strong> — это такая ссылка на объект, которая не учитывается сборщиком мусора. Если все ссылки, указывающие на объект, являются слабыми, то данный объект утилизируется, а эти слабые ссылки каким-либо образом удаляются. Lua реализует слабые ссылки как слабые таблицы: <em>слабая таблица</em> <strong>(weak table)</strong> — это такая таблица, все ссылки которой являются слабыми. Это значит, что если объект хранится только внутри слабых таблиц, то Lua со временем его утилизирует.</p>
<p>У таблиц есть ключи и значения, которые при этом могут содержать любые виды объектов. В обычных обстоятельствах сборщик мусора не утилизирует объекты, которые являются ключами и ссылками в открытой для доступа таблице. То есть и ключи, и значения являются <em>сильными ссылками</em> <strong>(strong reference)</strong>, то есть они предотвращают утилизацию тех объектов, на которые они указывают. В слабой таблице и ключи, и значения могут быть слабыми. Это значит, что существуют три вида слабых таблиц: таблицы со слабыми ключами, таблицы со слабыми значениями и полностью слабые таблицы, где и ключи, и значения являются слабыми. Независимо от вида таблицы, при уничтожении ключа или значения из нее удаляется вся запись.</p>
<p>Слабость таблицы задается полем <code>__mode</code> ее метатаблицы. Значение этого поля, когда оно присутствует, должно быть строкой; если эта строка равна &quot;<code>k</code>&quot;, то ключи в этой таблице являются слабыми; если эта строка равна &quot;<code>v</code>&quot;, то слабыми являются значения в этой таблице; если эта строка равна &quot;<code>kv</code>&quot;, то и ключи, и значения в данной таблице являются слабыми. Следующий пример, хотя и искусственный, показывает основное поведение слабых таблиц:</p>
<pre><code>a = {}
b = {__mode = &quot;k&quot;}
setmetatable(a, b)    -- теперь у &#39;a&#39; есть слабые ключи
key = {}              -- создает первый ключ
a[key] = 1
key = {}              -- создает второй ключ
a[key] = 2
collectgarbage()      -- принудительно задействует цикл сборки мусора
for k, v in pairs(a) do print(v) end
  --&gt; 2</code></pre>
<p>В этом примере второе присваивание <code>kеу={}</code> перезаписывает ссылку на первый ключ. Вызов <code>collectgarbage</code> заставляет сборщик мусора провести полную утилизацию. Поскольку на первый ключ больше не осталось ссылок, этот ключ утилизируется, а соответствующая запись в таблице удаляется. Однако второй ключ по-прежнему хранится в переменной <code>key</code> и поэтому не утилизируется.</p>
<p>Обратите внимание, что из слабой таблицы могут быть утилизированы лишь объекты. Значения, например числа и логические значения, сборщиком не собираются. Например, если мы вставим числовой ключ в таблицу <code>а</code> (из нашего предыдущего примера), то сборщик мусора никогда его не удалит. Разумеется, если значение, соответствующее числовому ключу, хранится в таблице со слабыми значениями, то из нее удаляется вся соответствующая запись.</p>
<p>Со строками есть одна тонкость: хотя строки и утилизируются сборщиком мусора, с точки зрения реализации они отличаются от остальных утилизируемых объектов. Другие объекты, такие как таблицы и нити, создаются явно. Например, когда Lua вычисляет выражение <code>{}</code>, то он создает новую таблицу. Однако, создает ли Lua новую строку при вычислении &quot;<code>a</code>&quot;<code>..</code>&quot;<code>b</code>&quot;? Что, если в системе уже есть строка &quot;<code>ab</code>&quot;? Создаст ли Lua новую строку? Может ли компилятор создать эту строку перед выполнением программы? Это не имеет никакого значения: это все детали реализации. С точки зрения программиста, строки являются значениями, а не объектами. Поэтому, так же как и число или логическое значение, строка не удаляется из слабой таблицы (кроме случая, когда удаляется связанное с ней значение).</p>
<h3 id="Chapter17.xhtml#sigil_toc_id_135">17.2. Функции с запоминанием</h3>
<p>Распространенным программистским приемом является получение выигрыша во времени за счет проигрыша по памяти. Вы можете ускорить функцию посредством <em>запоминания</em> <strong>(memorizing)</strong> ее результатов, чтобы в дальнейшем, когда вы вызовете эту же функцию с теми же аргументами, функция смогла воспользоваться тем же результатом.</p>
<p>Представьте себе обычный сервер, получающий запросы в виде строк, содержащих код Lua. Каждый раз при получении запроса сервер выполняет <code>load</code> для полученной строки и затем вызывает полученную функцию. Однако <code>load</code> — затратная функция, и некоторые команды для сервера могут довольно часто повторяться. Вместо повторного вызова <code>load</code> каждый раз, когда сервер получает распространенную команду вроде &quot;<code>closeconnection()</code>&quot;, сервер может <em>запомнить</em> результат <code>load</code> при помощи вспомогательной таблицы. Перед вызовом <code>load</code> сервер проверяет по этой таблице — не была ли уже преобразована данная строка. Если сервер не может найти эту строку, тогда (и только тогда) он вызывает <code>load</code> и сохраняет результат в этой таблице. Мы можем заложить это поведение в новую функцию:</p>
<pre><code>local results = {}
function mem_loadstring (s)
  local res = results[s]
  if res == nil then         -- результат не доступен?
    res = assert(load(s))    -- вычисляет новый результат
    results[s] = res         -- сохраняет для последующего переиспользования
  end
  return res
end</code></pre>
<p>Выигрыш от этой схемы может быть огромным. Однако, она также может привести к непредвиденным затратам ресурсов. Хотя некоторые команды повторяются снова и снова, многие другие команды выполняются лишь однажды. Таблица <code>results</code> постепенно собирает все команды, которые сервер когда-либо получал, вместе с их кодами; спустя некоторое время это может привести к исчерпанию памяти на сервере. Слабые таблицы предоставляют простое решение данной проблемы. Если таблица <code>results</code> хранит слабые значения, то каждый цикл сборки мусора удалит все неиспользуемые на данный момент преобразования (то есть практически все):</p>
<pre><code>local results = {}
setmetatable(results, {__mode = &quot;v&quot;})    -- делает значения слабыми
function mem_loadstring (s)
  &lt;как прежде&gt;</code></pre>
<p>На самом деле, поскольку индексы всегда являются строками, при желании мы можем сделать эту таблицу полностью слабой:</p>
<pre><code>setmetatable(results, {__mode = &quot;kv&quot;})</code></pre>
<p>Окончательный результат такой же.</p>
<p>Техника запоминания также полезна, когда нужно быть уверенными в уникальности объекта определенного вида. Например, представим систему, в которой цвета представлены таблицами с полями <code>red</code>, <code>green</code> и <code>blue</code>. Примитивная фабрика цветов генерирует новый цвет при каждом новом запросе:</p>
<pre><code>function createRGB (r, g, b)
  return {red = r, green = g, blue = b}
end</code></pre>
<p>Используя технику запоминания, мы можем многократно использовать одну и ту же таблицу для одного и того же цвета. При создании уникального ключа для каждого цвета мы просто конкатенируем индексы цвета посредством какого-либо разделителя:</p>
<pre><code>local results = {}
setmetatable(results, {__mode = &quot;v&quot;})    -- делает значения слабыми
function createRGB (r, g, b)
  local key = r .. &quot;-&quot; .. g .. &quot;-&quot; .. b
  local color = results[key]
  if color == nil then
    color = {red = r, green = g, blue = b}
    results[key] = color
  end
  return color
end</code></pre>
<p>Интересным последствием этой реализации является то, что пользователь может сравнивать цвета при помощи стандартной операции сравнения, поскольку два сосуществующих одинаковых цвета всегда представлены одной и той же таблицей. Обратите внимание, что данный цвет может быть представлен разными таблицами в разные моменты времени, поскольку время от времени цикл сборки мусора очищает таблицу <code>results</code>. Однако, пока данный цвет используется, он не может быть удален из <code>results</code>. Поэтому, когда цвет существует так долго, что его сравнивают с новым цветом, его представление также будет существовать достаточно долго, чтобы пригодиться для нового цвета.</p>
<h3 id="Chapter17.xhtml#sigil_toc_id_136">17.3. Атрибуты объекта</h3>
<p>Другой важной областью применения слабых таблиц является связывание атрибутов с объектами. Существует множество ситуаций, в которых нам нужно прикрепить некоторый атрибут к объекту: имена к функциям, значения по умолчанию к таблицам, размеры к массивам и т. д.</p>
<p>Когда объект является таблицей, мы можем хранить атрибут в самой таблице, подобрав подходящий уникальный ключ. Как мы уже видели, простой и безошибочный способ создать уникальный ключ — это создать новый объект (обычно таблицу) и применять его в качестве ключа. Однако, если объект не является таблицей, то он не может хранить свои собственные атрибуты. Даже в случае таблиц нам не всегда нужно хранить атрибут в исходном объекте. Например, нам может понадобится хранить подобный атрибут закрытым или нам не нужно, чтобы атрибут мешал обходу таблицы. Во всех этих случаях нам нужен иной способ связывания атрибутов с объектами.</p>
<p>Конечно, внешняя таблица предоставляет идеальный способ присоединения атрибутов к объектам (не случайно, что таблицы иногда называют <em>ассоциативными массивами</em>). Мы используем объекты как ключи, а их атрибуты — как значения. Внешняя таблица может хранить атрибуты объектов любого типа, так как Lua позволяет использовать объекты любого типа в качестве ключей таблицы. Более того, атрибуты, хранящиеся во внешней таблице, не влияют на другие объекты и могут быть закрытыми, так же как и сама таблица.</p>
<p>Однако, это на первый взгляд идеальное решение обладает огромным недостатком: как только мы использовали объект в качестве ключа в таблице, мы обрекли его на вечное существование. Lua не может утилизировать объект, который используется в качестве ключа. Если мы используем обычную таблицу , чтобы привязать к функциям их имена, то ни одна из этих функций никогда не будет удалена. Как вы вероятно догадались, мы можем избежать этого недостатка при помощи слабых таблиц. Однако, на этот раз нам понадобятся слабые ключи. Применение слабых ключей не предотвращает их утилизацию, когда на них не остается больше ссылок. С другой стороны, у таблицы не могут быть слабые значения; иначе атрибуты существующих объектов могли бы быть утилизированы.</p>
<h3 id="Chapter17.xhtml#sigil_toc_id_137">17.4. Вновь таблицы со значениями по умолчанию</h3>
<p>В разделе 13.4 мы обсуждали, как реализовать таблицы со значениями по умолчанию, отличными от nil. Мы рассмотрели один частный подход и заметили, что в двух других подходах применяются слабые таблицы, поэтому их мы отложили на потом. Теперь пора вернуться к этой теме. Как вы увидите, эти два решения задачи реализации значений по умолчанию на самом деле являются частными случаями уже рассмотренных подходов: атрибутов объектов и запоминания.</p>
<p>В первом решении мы используем слабую таблицу, чтобы связать с каждой таблицей ее значения по умолчанию:</p>
<pre><code>local defaults = {}
setmetatable(defaults, {__mode = &quot;k&quot;})
local mt = {__index = function (t) return defaults[t] end}
function setDefault (t, d)
  defaults[t] = d
  setmetatable(t, mt)
end</code></pre>
<p>Если бы у <code>defaults</code> не было слабых ключей, то все эти таблицы со значениями по умолчанию существовали бы постоянно.</p>
<p>Во втором решении мы используем разные метатаблицы для разных значений по умолчанию, но при этом мы многократно используем одну и ту же метатаблицу при каждом повторном использовании значения по умолчанию. Это типичное применение запоминания:</p>
<pre><code>local metas = {}
setmetatable(metas, {__mode = &quot;v&quot;})
function setDefault (t, d)
  local mt = metas[d]
  if mt == nil then
    mt = {__index = function () return d end}
    metas[d] = mt -- memorize
  end
  setmetatable(t, mt)
end</code></pre>
<p>В данном случае мы применяем слабые значения, чтобы разрешить утилизацию уже неиспользуемых метатаблиц.</p>
<p>Какая из этих двух реализаций является лучшей? Как обычно, это зависит от обстоятельств. У обеих схожая сложность и схожее быстродействие. Первая реализация требует нескольких слов <strong>(1 слово = 2 байта)</strong> памяти для каждой таблицы со значением по умолчанию (для записей в <code>defaults</code>). Вторая реализация требует нескольких десятков слов памяти для каждого отдельного значения по умолчанию (новая таблица, новое замыкание и запись в <code>metas</code>). Поэтому если в вашем приложении тысячи таблиц с всего несколькими различными значениями по умолчанию, то второе решение явно будет лучше. С другой стороны, если несколько таблиц обладают общими значениями по умолчанию, то вам лучше предпочесть первую реализацию.</p>
<h3 id="Chapter17.xhtml#sigil_toc_id_138">17.5. Эфемерные таблицы</h3>
<p>Сложная ситуация возникает, когда в таблице со слабыми ключами значение ссылается на свой собственный ключ.</p>
<p>Этот случай гораздо более распространен, чем может показаться. В качестве типичного примера возьмем фабрику функций-констант. Подобная фабрика получает объект и возвращает функцию, которая при вызове возвращает этот объект:</p>
<pre><code>function factory (o)
  return function () return o end
end</code></pre>
<p>Эта фабрика является хорошим кандидатом для запоминания, чтобы не создавать новое замыкание, когда уже есть готовое:</p>
<pre><code>do
  local mem = {}
  setmetatable(mem, {__mode = &quot;k&quot;})
  function factory (o)
    local res = mem[o]
    if not res then
      res = function () return o end
      mem[o] = res
    end
    return res
  end
end</code></pre>
<p>Однако, здесь есть один подвох. Обратите внимание, что значение (функция-константа), связанное с объектом внутри <code>mem</code>, ссылается на свой собственный ключ (сам объект). Хотя ключи в этой таблице слабые, значения слабыми не являются. При стандартной интерпретации слабых таблиц ничто не будет удалено из таблицы с запоминанием. Поскольку значения не являются слабыми, всегда есть сильная ссылка на каждую функцию. Каждая функция ссылается на свой соответственный объект, поэтому на каждый объект всегда есть сильная ссылка. Таким образом, несмотря на слабые ключи, эти объекты не будут утилизированы.</p>
<p>Однако, эта ограниченная интерпретация не очень удобна. Большинство ожидает, что значение в таблице доступно только через соответствующий ключ. Поэтому мы можем рассматривать вышеописанный случай в качестве разновидности цикла, где замыкание ссылается на объект, который (через таблицу с запоминанием) в свою очередь ссылается на это замыкание.</p>
<p>Lua 5.2 решает данную проблему при помощи концепции эфемерных таблиц. В Lua 5.2 таблица со слабыми ключами и сильными значениями является <em>эфемерной таблицей</em> <strong>(ephemeron table)</strong>. В эфемерной таблице доступность ключа управляет доступностью соответствующего значения. В частности, рассмотрим запись (<em>k</em>, <em>v</em>) в эфемерной таблице. Ссылка на <em>v</em> является сильной, только если существует сильная ссылка на <em>k</em>. В противном случае запись со временем удаляется из таблицы, даже если <em>v</em> ссылается (прямо или косвенно) на <em>k</em>.</p>
<h3 id="Chapter17.xhtml#sigil_toc_id_139">17.6. Финализаторы</h3>
<p>Хотя задачей сборщика мусора является утилизация объектов Lua, он также может помочь программам с освобождением внешних ресурсов. С этой целью некоторые языки программирования предлагают механизм финализаторов. <em>Финализатор</em> <strong>(finalizer)</strong> — это функция, связанная с объектом, которая вызывается перед тем, как объект будет удален сборщиком мусора.</p>
<p>Lua реализует финализаторы при помощи метаметода <code>__gc</code>. Посмотрите на следующий пример:</p>
<pre><code>o = {x = &quot;hi&quot;}
setmetatable(o, {__gc = function (o) print(o.x) end})
o = nil
collectgarbage() --&gt; hi</code></pre>
<p>В этом примере мы сперва создаем таблицу и устанавливаем для нее метатаблицу, у которой есть метаметод <code>__gc</code>. Затем мы уничтожаем единственную ссылку на эту таблицу (глобальная переменная <code>о</code>) и запускаем полную сборку мусора при помощи вызова <code>collectgarbage</code>. Во время сборки мусора Lua обнаруживает, что данная таблица не является доступной и вызывает ее финализатор (метаметод <code>__gc</code>).</p>
<p>У финализаторов Lua есть один нюанс, связанный с пометкой объекта для финализации. Мы помечаем объект для финализации, когда задаем для него метатаблицу с ненулевым метаметодом <code>__gc</code>. Если мы не пометим объект, то он не будет финализирован. Большая часть кода, который мы пишем, работает ожидаемым образом, но иногда возникают странные случаи вроде следующего:</p>
<pre><code>o = {x = &quot;hi&quot;}
mt = {}
setmetatable(o, mt)
mt.__gc = function (o) print(o.x) end
o = nil
collectgarbage()    --&gt; (ничего не печатает)</code></pre>
<p>В этом примере метатаблица, которую мы устанавливаем для <code>о</code>, не содержит метаметода <code>__gc</code>, поэтому объект и не помечается для финализации. Даже если потом добавить поле <code>__gc</code> метатаблице, Lua не посчитает это присваивание каким-то особенным, так что объект не будет помечен. Как мы и сказали, это редко бывает проблемой; метаметоды редко изменяются после начала использования метатаблицы.</p>
<p>Если вы действительно хотите задать метаметод позже, то вы можете использовать любое значение для поля <code>__gc</code> в качестве временного:</p>
<pre><code>o = {x = &quot;hi&quot;}
mt = {__gc = true}
setmetatable(o, mt)
mt.__gc = function (o) print(o.x) end
o = nil
collectgarbage()    --&gt; hi</code></pre>
<p>Теперь, поскольку метатаблица содержит поле <code>__gc</code>, объект <code>о</code> надлежащим образом помечается для финализации. Нет никакой проблемы в том, чтобы задать метаметод позже; Lua вызывает финализатор, только если он является соответственной функцией.</p>
<p>Когда сборщик мусора утилизирует несколько объектов в одном и том же цикле, он вызывает их финализаторы в порядке, обратном тому, в котором объекты были помечены для финализации. Рассмотрим следующий пример, который создает связанный список объектов с финализаторами:</p>
<pre><code>mt = {__gc = function (o) print(o[1]) end}
list = nil
for i = 1, 3 do
  list = setmetatable({i, link = list}, mt)
end
list = nil
collectgarbage()
  --&gt; 3
  --&gt; 2
  --&gt; 1</code></pre>
<p>Первым финализируемым объектом будет объект 3, который был последним помеченным объектом.</p>
<p>Считать, что ссылки между утилизируемыми объектами могут повлиять на порядок их финализации — распространенное заблуждение. Например, можно подумать, что объект 2 в предыдущем примере должен быть финализирован перед объектом 1, поскольку существует ссылка от 2 к 1. Однако, ссылки могут формировать циклы. Поэтому они никак не влияют на порядок финализации.</p>
<p>Другим неочевидным моментом, связанным с финализаторами, является <em>восстановление</em> <strong>(resurrection)</strong>. При своем вызове финализатор получает в качестве параметра финализируемый объект. Таким образом, объект снова становится живым, по крайней мере на время финализации. Я называю это <em>временным восстановлением</em> <strong>(transient resurrection)</strong>. Во время выполнения финализатора ничто не мешает ему сохранить объект, скажем, в глобальной переменной, чтобы объект остался доступным после возврата из финализатора. Я называю это <em>перманентным восстановлением</em> <strong>(permanent resurrection)</strong>.</p>
<p>Восстановление должно быть временным. Рассмотрим следующий фрагмент кода:</p>
<pre><code>A = {x = &quot;this is A&quot;}
B = {f = A}
setmetatable(B, {__gc = function (o) print(o.f.x) end})
A, B = nil
collectgarbage()    --&gt; this is A</code></pre>
<p>Финализатор для <code>B</code> обращается к <code>A</code>, поэтому <code>A</code> не может быть удален до финализации <code>B</code>. Lua должен восстановить и <code>A</code>, и <code>B</code> перед вызовом финализатора.</p>
<p>Из-за восстановления объекты с финализаторами собираются в два этапа. Вначале, когда сборщик мусора обнаруживает, что объект с финализатором недостижим, он восстанавливает этот объект и добавляет его к очереди финализации. После выполнения финализатора Lua помечает объект как финализированный. В следующий раз, когда сборщик мусора обнаружит, что объект недостижим, он его уничтожит. Если вы хотите быть уверенными в том, что весь мусор в вашей программе был действительно собран, то вы должны вызвать <code>collectgarbage</code> дважды; второй вызов уничтожит объекты, которые были финализированы во время первого вызова.</p>
<p>Финализатор для каждого объекта выполняется ровно один раз, поскольку Lua ставит пометку на финализированные объекты. Если объект не был собран сборщиком до конца работы программы, то Lua вызовет его финализатор при закрытии всего состояния Lua. Эта последняя особенность позволяет реализовать в Lua аналог функций <code>atexit</code>, то есть функций, которые вызываются непосредственно перед завершением программы. Все, что для этого нужно, — создать таблицу с финализатором и закрепить ее где-нибудь, например в глобальной переменной:</p>
<pre><code>_G.AA = {__gc = function ()
  -- поместите здесь ваш &#39;atexit&#39;-код
  print(&quot;finishing Lua program&quot;)
end}
setmetatable(_G.AA, _G.AA)</code></pre>
<p>Другой интересный подход позволяет вызывать заданную функцию каждый раз, когда Lua завершает цикл сборки мусора. Поскольку финализатор выполняется ровно один раз, то хитрость здесь в том, чтобы финализатор создавал новый объект для вызова следующего финализатора:</p>
<pre><code>do
  local mt = {__gc = function (o)
    -- делайте все, что хотите
    print(&quot;new cycle&quot;)
    -- создает новый объект для следующего цикла
    setmetatable({}, getmetatable(o))
  end}

  -- создает первый объект
  setmetatable({}, mt)
end

collectgarbage()    --&gt; новый цикл
collectgarbage()    --&gt; новый цикл
collectgarbage()    --&gt; новый цикл</code></pre>
<p>Во взаимодействии объектов с финализаторами и слабыми таблицами тоже есть нюанс. Сборщик мусора очищает значения в слабой таблице перед восстановлением, в то время как ключи очищаются после восстановления. Следующий фрагмент кода иллюстрирует это поведение:</p>
<pre><code>-- таблица со слабыми ключами
wk = setmetatable({}, {__mode = &quot;k&quot;})

-- таблица со слабыми значениями
wv = setmetatable({}, {__mode = &quot;v&quot;})

o = {}    -- объект
wv[1] = o; wk[o] = 10    -- добавляет их к обеим таблицам

setmetatable(o, {__gc = function (o)
print(wk[o], wv[1])
end})

o = nil; collectgarbage()    --&gt;    10    nil</code></pre>
<p>Во время выполнения финализатора он находит объект в таблице <code>wk</code>, но не в таблице <code>wv</code>. Обоснованием такого поведения является то, что мы часто храним свойства объекта в таблицах со слабыми ключами (как мы обсудили в разделе 17.3), и финализаторам может понадобиться доступ к этим атрибутам. Однако, мы используем таблицы со слабыми значениями для многократного использования живых объектов; в этом случае финализируемые объекты становятся бесполезны.</p>
<h3 id="Chapter17.xhtml#sigil_toc_id_140">Упражнения</h3>
<p><strong>Упражнение 17.1.</strong> Напишите проверочный код, чтобы определить, действительно ли Lua использует эфемерные таблицы. (Не забудьте вызвать <code>collectgarbage</code> для принудительного цикла сборки мусора.) По возможности проверьте ваш код как в Lua 5.1, так и в Lua 5.2, чтобы увидеть разницу.</p>
<p><strong>Упражнение 17.2.</strong> Рассмотрим первый пример из раздела 17.6, который создает таблицу с финализатором, печатающим сообщение лишь при вызове. Что произойдет, если программа завершится без цикла сборки мусора? Что случится, если программа вызовет <code>os.exit</code>? Что произойдет, если программа завершит свое выполнение с ошибкой?</p>
<p><strong>Упражнение 17.3.</strong> Допустим, вам нужно реализовать таблицу с запоминанием для функции, получающей строку и возвращающей строку. Применение слабой таблицы не позволит удалять записи, поскольку слабые таблицы не рассматривают строки как удаляемые объекты. Как вы можете реализовать запоминание в этом случае?</p>
<p><strong>Упражнение 17.4.</strong> Объясните вывод следующей программы:</p>
<pre><code>local count = 0

local mt = {__gc = function () count = count - 1 end}
local a = {}

for i = 1, 10000 do
  count = count + 1
  a[i] = setmetatable({}, mt)
end

collectgarbage()
print(collectgarbage&quot;count&quot; * 1024, count)
a = nil
collectgarbage()
print(collectgarbage&quot;count&quot; * 1024, count)
collectgarbage()
print(collectgarbage&quot;count&quot; * 1024, count)</code></pre>
<p><span id="Part3.xhtml"></span></p>
<div style="text-align: center; padding: 0pt; margin: 0pt;">
<h1>Часть III</h1>
<h1 id="Part3.xhtml#sigil_toc_id_141" class="part">Стандартные библиотеки</h1>
<svg xmlns="http://www.w3.org/2000/svg" height="75%" preserveaspectratio="xMidYMid meet" version="1.1" viewbox="0 0 1400 1300" width="100%" xlink="http://www.w3.org/1999/xlink">

</svg>
</div>
<p><span id="Chapter18.xhtml"></span></p>
<h2>ГЛАВА 18</h2>
<h2 id="Chapter18.xhtml#sigil_toc_id_142">Математическая библиотека</h2>
<p>В этой и следующих главах, посвященных стандартным библиотекам, моей целью является не дать полную спецификацию каждой функции, а показать, какую функциональность предоставляет каждая библиотека. Для ясности изложения я могу опускать некоторые специфические опции или режимы работы. Главной целью является зажечь в вас любопытство, которое затем может быть удовлетворено чтением справочника Lua.</p>
<p>Библиотека <code>math</code> содержит стандартный набор математических функций, таких как тригонометрические функции (<code>sin</code>, <code>cos</code>, <code>tan</code>, <code>asin</code>, <code>acos</code> и т. п.), возведение в степень и логарифмирование (<code>exp</code>, <code>log</code>, <code>log10</code>), функции округления (<code>floor</code>, <code>ceil</code>), <code>min</code>, <code>max</code>, функции для генерации псевдослучайных чисел (<code>random</code>, <code>randomseed</code>), переменная <code>pi</code> и переменная <code>huge</code>, которая является наибольшим представимым в Lua числом (на некоторых платформах может принимать специальное значение <em>inf</em>).</p>
<p>Все тригонометрические функции работают с радианами. Вы можете использовать функции <code>deg</code> и <code>rad</code> для перевода между градусами и радианами. Если вы хотите работать с градусами, вы можете переопределить тригонометрические функции:</p>
<pre><code>do
  local sin, asin, ... = math.sin, math.asin, ...
  local deg, rad = math.deg, math.rad
  math.sin = function (x) return sin(rad(x)) end
  math.asin = function (x) return deg(asin(x)) end
  ...
end</code></pre>
<p>Функция <code>math.random</code> генерирует псевдослучайные числа. Вы можете вызывать ее тремя способами. Когда мы вызываем ее без аргументов, она возвращает вещественное псевдослучайное число с равномерным распределением в диапазоне [0,1). Когда мы вызываем ее с единственным аргументом, целочисленным <em>n</em>, то она возвращает псевдослучайное целое число <em>х</em>, такое, что <em>1 ≤ x ≤ n</em>. Например, вы можете смоделировать бросок кубика при помощи <code>random(6)</code>. Наконец, мы можем вызвать <code>random</code> с двумя целочисленными аргументами <em>l</em> и <em>u</em>, чтобы получить псевдослучайное целое число <em>x</em>, такое что <em>l ≤ x ≤ u</em>.</p>
<p>Вы можете задать затравку <strong>(seed)</strong> для генератора псевдослучайных чисел при помощи функции <code>randomseed</code>; затравка является ее единственным числовым аргументом. Обычно, при запуске программы она инициализирует генератор некоторым фиксированным значением. Это значит, что каждый раз, когда вы запускаете вашу программу, она генерирует одну и ту же последовательность псевдослучайных чисел. Для отладки это качество весьма удобно, но в игре все будет происходить по одному и тому же сценарию снова и снова. Распространенным приемом для решения данной проблемы является использование в качестве затравки текущего времени путем вызова <code>math.randomseed(os.time())</code>. Функция <code>os.time</code> возвращает число, представляющее текущее время, обычно в виде числа секунд, прошедших с определенного момента времени.</p>
<p>Функция <code>math.random</code> использует функцию <code>rand</code> из стандартной библиотеки С. В некоторых реализациях эта функция возвращает числа с не очень хорошими статистическими свойствами. Вы можете попробовать отыскать более удачный генератор псевдослучайных чисел в независимых дистрибутивах. (Стандартная поставка Lua не включает в себя подобного генератора во избежание проблем с авторским правом. Она содержит только код, написанный авторами Lua.)</p>
<h3 id="Chapter18.xhtml#sigil_toc_id_143">Упражнения</h3>
<p><strong>Упражнение 18.1.</strong> Напишите функцию для проверки того, является ли заданное число степенью двойки.</p>
<p><strong>Упражнение 18.2.</strong> Напишите функцию для расчета объема прямого кругового конуса по его высоте и углу между его образующей и осью.</p>
<p><strong>Упражнение 18.3.</strong> Реализуйте другой генератор псевдослучайных чисел в Lua. Поищите хороший алгоритм в Интернете. (Вам может понадобиться побитовая библиотека; см. главу 19.)</p>
<p><strong>Упражнение 18.4.</strong> Используя <code>math.random</code>, напишите функцию для получения псевдослучайных чисел со стандартным нормальным распределением (по Гауссу).</p>
<p><strong>Упражнение 18.5.</strong> Напишите функцию для перемешивания заданного списка. Убедитесь, что все варианты равновероятны.</p>
<p><span id="Chapter19.xhtml"></span></p>
<h2>ГЛАВА 19</h2>
<h2 id="Chapter19.xhtml#sigil_toc_id_144">Побитовая библиотека</h2>
<p>Источником постоянных жалоб насчет Lua является отсутствие в нем побитовых операций. Это отсутствие вовсе не случайно. Не так легко помирить побитовые операции с числами с плавающей точкой.</p>
<p>Мы можем выразить некоторые побитовые операции как арифметические операции. Например, сдвиги влево соответствуют умножению на степени двух, сдвиги направо соответствуют делению, Однако, у побитовых AND и OR нет таких арифметических аналогов. Они определены для двоичных представлений целых чисел. Практически невозможно расширить их на операции с плавающей точкой. Даже некоторые простые операции теряют смысл. Что должно быть дополнением 0.0? Должно ли это быть равно -1? Или 0xFFFFFFFF (что в Lua равно 4 294 967 295, что явно неравно -1)? Или может быть 2<sup>64</sup>-1 (число, которое нельзя точно представить при помощи значения типа double)?</p>
<p>Во избежание подобных проблем, Lua 5.2 вводит побитовые операции при помощи библиотеки, а не как встроенные в язык операции. Это делает ясным, что данные операции не являются «родными» для чисел в Lua, но они используют определенную интерпретацию для работы с этими числами. Более того, другие библиотеки могут предложить иные интерпретации побитовых операций (например, используя более 32 битов).</p>
<p>Для большинства примеров в этой главе я буду использовать шестнадцатеричную запись. Я буду использовать слово мах для обозначения 0xFFFFFFFF (то есть 2<sup>32</sup>-1). В примерах я буду использовать следующую дополнительную функцию:</p>
<pre><code>function printx (x)
  print(string.format(&quot;0x%X&quot;, x))
end</code></pre>
<p>Побитовая библиотека в Lua 5.2 называется <code>bit32</code>. Как следует из имени, она работает с 32-битовыми числами. Поскольку <strong>and</strong>, <strong>or</strong> и <strong>not</strong> являются зарезервированными в Lua словами, то соответствующие функции названы <code>band</code>, <code>bor</code> и <code>bnot</code>. Для последовательности в названиях функция побитового исключающего ИЛИ названа <code>bхог</code>:</p>
<pre><code>printx(bit32.band(0xDF, 0xFD))    --&gt; 0xDD
printx(bit32.bor(0xD0, 0x0D))     --&gt; 0xDD
printx(bit32.bxor(0xD0, 0xFF))    --&gt; 0x2F
printx(bit32.bnot(0))             --&gt; 0xFFFFFFFF</code></pre>
<p>Функции <code>band</code>, <code>bor</code> и <code>bxor</code> принимают любое количество аргументов:</p>
<pre><code>printx(bit32.bor(0xA, 0xA0, 0xA00))        --&gt; 0xAAA
printx(bit32.band(0xFFA, 0xFAF, 0xAFF))    --&gt; 0xAAA
printx(bit32.bxor(0, 0xAAA, 0))            --&gt; 0xAAA
printx(bit32.bor())                        --&gt; 0x0
printx(bit32.band())                       --&gt; 0xFFFFFFFF
printx(bit32.bxor())                       --&gt; 0x0</code></pre>
<p>(Они все коммутативны и ассоциативны.)</p>
<p>Побитовая библиотека работает с беззнаковыми целыми числами. В ходе работы любое число, переданное как аргумент, приводится к целому числу в диапазоне 0—<code>MAX</code>. Во-первых, неуказанные числа округляются неуказанным способом. Во-вторых, числа вне диапазона 0—<code>МАХ</code> приводятся к нему при помощи операции остатка от деления: целое <em>n</em> становится <em>n%2<sup>32</sup></em>. Эта операция эквивалентна получению двоичного представления числа и затем взятию его младших 32 бит. Как и ожидается, -1 становится <code>MAX</code>. Вы можете использовать следующие операции для нормализации числа (то есть отображения его в диапазон 0-<code>MAX</code>):</p>
<pre><code>printx(bit32.bor(2^32))    --&gt; 0x0
printx(bit32.band(-1))     --&gt; 0xFFFFFFFF</code></pre>
<p>Конечно, в стандартном Lua легче просто выполнить <code>n%(2^32)</code>.</p>
<p>Если явно не указано, все функции в библиотеке возвращают результат, который также лежит в 0—<code>MAX</code>. Однако, вам следует быть осторожными при использовании результатов побитовых операций в качестве обычных чисел. Иногда Lua компилируется, используя другой тип для чисел. В частности, некоторые системы с ограниченными возможностями используют 32-битовые числа в качестве чисел в Lua. В этих системах <code>MAX</code> равен -1. Более того, некоторые побитовые библиотеки используют различные соглашения для своих результатов. Поэтому всякий раз, когда вам нужно использовать результат побитовой операции в качестве числа, будьте осторожны. Избегайте сравнений: вместо <code>х&lt;0</code> напишите <code>bit32.btest(х,0x80000000)</code>. (Мы скоро увидим функцию <code>btest</code>.) Используйте саму побитовую библиотеку для нормализации констант:</p>
<pre><code>if bit32.or(a, b) == bit32.or(-1) then
  &lt;какой-нибудь код&gt;</code></pre>
<p>Побитовая библиотека также определяет операции для сдвига и вращения бит: <code>lshift</code> для сдвига налево; <code>rshift</code> и <code>arshift</code> (арифметический сдвиг) для сдвига направо; <code>lrotate</code> для вращения налево и <code>rrotate</code> для вращения направо. За исключением арифметического сдвига (<code>arshift</code>), все сдвиги заполняют новые биты нулями. Арифметический сдвиг заполняет биты слева копиями своего последнего бита («сигнальным битом»):</p>
<pre><code>printx(bit32.rshift(0xDF, 4))           --&gt; 0xD
printx(bit32.lshift(0xDF, 4))           --&gt; 0xDF0
printx(bit32.rshift(-1, 28))            --&gt; 0xF
printx(bit32.arshift(-1, 28))           --&gt; 0xFFFFFFFF
printx(bit32.lrotate(0xABCDEF01, 4))    --&gt; 0xBCDEF01A
printx(bit32.rrotate(0xABCDEF01, 4))    --&gt; 0x1ABCDEF0</code></pre>
<p>Сдвиг или вращение на отрицательное число бит сдвигает (вращает) в противоположную сторону. Например, сдвиг на -1 бит направо эквивалентен сдвигу на 1 бит влево. Результат сдвига на более чем 31 бит равен 0 или <code>MAX</code>, поскольку все исходные биты пропали:</p>
<pre><code>printx(bit32.lrotate(0xABCDEF01, -4))     --&gt; 0x1ABCDEF0
printx(bit32.lrotate(0xABCDEF01, -36))    --&gt; 0x1ABCDEF0
printx(bit32.lshift(0xABCDEF01, -36))     --&gt; 0x0
printx(bit32.rshift(-1, 34))              --&gt; 0x0
printx(bit32.arshift(-1, 34))             --&gt; 0xFFFFFFFF</code></pre>
<p>Кроме этих, более или менее стандартных операций, побитовая библиотека также предоставляет три дополнительные функции. Функция <code>btest</code> осуществляет ту же операцию, что и <code>band</code>, но возвращает результат сравнения побитовой операции с нулем:</p>
<pre><code>print(bit32.btest(12, 1)) --&gt; false
print(bit32.btest(13, 1)) --&gt; true</code></pre>
<p>Другой распространенной операцией является извлечение заданных битов из числа. Обычно эта операция включает в себя сдвиг и побитовое AND; побитовая библиотека упаковывает все это в одну функцию. Вызов <code>bit32.extract(х, f,w)</code> возвращает <code>w</code> бит из <code>х</code>, начиная с бита <code>f</code>:</p>
<pre><code>printx(bit32.extract(0xABCDEF01, 4, 8))      --&gt; 0xF0
printx(bit32.extract(0xABCDEF01, 20, 12))    --&gt; 0xABC
printx(bit32.extract(0xABCDEF01, 0, 12))     --&gt; 0xF01</code></pre>
<p>Эта операция считает биты от 0 до 31. Если третий аргумент <code>(w</code>) не задан, то он считается равным единице:</p>
<pre><code>printx(bit32.extract(0x0000000F, 0))     --&gt; 0x1
printx(bit32.extract(0xF0000000, 31))    --&gt; 0x1</code></pre>
<p>Обратной к операции <code>extract</code> является операция <code>replace</code>, которая заменяет заданные биты. Первым параметром является исходное число. Второй параметр задает значение, которое надо вставить. Последние два параметра, <code>f</code> и <code>w</code>, имеют тот же смысл, что и в <code>bit32.extract</code>:</p>
<pre><code>printx(bit32.replace(0xABCDEF01, 0x55, 4, 8))    --&gt; 0xABCDE551
printx(bit32.replace(0xABCDEF01, 0x0, 4, 8))     --&gt; 0xABCDE001</code></pre>
<p>Обратите внимание, что для любых допустимых значений <code>х</code>, <code>f</code> и <code>w</code> выполняется следующее равенство:</p>
<pre><code>assert(bit32.replace(x, bit32.extract(x, f, w), f, w) == x)</code></pre>
<h3 id="Chapter19.xhtml#sigil_toc_id_145">Упражнения</h3>
<p><strong>Упражнение 19.1.</strong> Напишите функцию для проверки того, что заданное число является степенью двух.</p>
<p><strong>Упражнение 19.2.</strong> Напишите функцию для вычисления веса Хэмминга заданного целого числа. (<em>Вес Хэмминга</em> для числа — это количество единичных бит в двоичном представлении этого числа).</p>
<p><strong>Упражнение 19.3.</strong> Напишите функцию для проверки того, является ли двоичное представление числа палиндромом (перевертышем).</p>
<p><strong>Упражнение 19.4.</strong> Определите операции сдвига и побитовый AND при помощи арифметических операций Lua.</p>
<p><strong>Упражнение 19.5.</strong> Напишите функцию, которая получает строку, закодированную в UTF-8, и возвращает ее первый символ как число. Функция должна вернуть nil, если строка не начинается с допустимой в UTF-8 последовательности.</p>
<p><span id="Chapter20.xhtml"></span></p>
<h2>ГЛАВА 20</h2>
<h2 id="Chapter20.xhtml#sigil_toc_id_146">Табличная библиотека</h2>
<p>Библиотека <code>table</code> состоит из вспомогательных функций для работы с таблицами как с массивами. Она предоставляет функции для вставки и удаления элементов из списков, для сортировки элементов массива и для конкатенации всех строк в массиве.</p>
<h3 id="Chapter20.xhtml#sigil_toc_id_147">20.1. Функции <span class="code">insert</span> и <span class="code">remove</span></h3>
<p>Функция <code>table.insert</code> вставляет элемент в заданную позицию массива, отодвигая остальные элементы, чтобы освободить место. Например, если <code>t</code> — это массив <code>{10, 20, 30)</code>, то после вызова <code>table.insert(t,1,15)</code> массив <code>t</code> станет равен <code>{15, 10, 20, 30}</code>. В качестве особого (и частого) случая, если мы вызовем <code>insert</code> без указания позиции, то она вставит элемент в последнюю позицию массива (и потому не станет сдвигать элементы). В качестве примера следующий код построчно читает ввод программы, храня все строки в массиве:</p>
<pre><code>t = {}
for line in io.lines() do
  table.insert(t, line)
end
print(#t)    --&gt; (количество считанных строк)</code></pre>
<p>В Lua 5.0 данная идиома была широко распространена. В более поздних версиях я предпочитаю идиому <code>t[#t + 1] = line</code>, чтобы добавить элементы к списку.</p>
<p>Функция <code>table.remove</code> удаляет (и возвращает) элемент с заданной позиции массива, при этом сдвигая остальные элементы, чтобы занять его место. При вызове без указания позиции она удаляет последний элемент массива.</p>
<p>При помощи этих двух функций довольно легко реализовать стеки, очереди и двойные очереди. Мы можем инициализировать подобные структуры как <code>t={}</code>. Операция заталкивания эквивалентна <code>table.insert(t,х)</code>; операция выталкивания эквивалентна <code>table.remove(t)</code>. Вызов <code>table.insert(t,1,x)</code> вставляет элемент в другой конец этой структуры (по сути, в ее начало), а вызов <code>table.remove(t,1)</code> удаляет элемент с этого конца. Две последние операции не особенно эффективны, поскольку они должны сдвигать и отодвигать элементы. Однако, учитывая, что библиотека <code>table</code> реализована на С, эти циклы не слишком затратны и потому данная реализация довольно хороша для небольших массивов (скажем, до нескольких сот элементов).</p>
<h3 id="Chapter20.xhtml#sigil_toc_id_148">20.2. Сортировка</h3>
<p>Еще одной полезной функцией для массивов является <code>table.sort</code>; мы уже видели ее прежде. Она принимает массив и необязательную функцию упорядочения. Эта функция принимает два аргумента и должна вернуть true, когда ее первый аргумент должен идти перед вторым в отсортированном массиве. Если эта функция не предоставлена, <code>sort</code> по умолчанию использует сравнение «меньше, чем» (соответствующее операции '<code>&lt;</code>').</p>
<p>Обычно путаница возникает, когда программист пытается упорядочить индексы в таблице. В таблице индексы образуют множество, в котором нет никакого порядка. Если вы хотите их упорядочить, то вам надо скопировать их в массив и затем этот массив отсортировать. Давайте рассмотрим пример. Допустим, вы прочли исходный файл и построили таблицу, которая для каждого имени функции хранит номер строки, в которой эта функция была определена; получится нечто вроде:</p>
<pre><code>lines = {
  luaH_set = 10,
  luaH_get = 24,
  luaH_present = 48,
}</code></pre>
<p>А теперь вам нужно напечатать имена этих функций в алфавитном порядке. Если вы обойдете эту таблицу при помощи <code>pairs</code>, то имена окажутся в произвольном порядке. Вы не можете отсортировать их непосредственно, поскольку эти имена являются ключами таблицы. Однако, если поместить их в массив, то вы сможете их отсортировать. Сначала вы должны создать массив с этими именами, затем отсортировать его и в итоге напечатать результат:</p>
<pre><code>a = {}
for n in pairs(lines) do a[#a + 1] = n end
table.sort(a)
for _, n in ipairs(a) do print(n) end</code></pre>
<p>Некоторых это смущает. В конце концов, в массивах Lua тоже нет никакого порядка (они же все-таки таблицы). Но раз мы умеем считать, мы навяжем порядок при обращении к массиву с помощью упорядоченных индексов. Именно поэтому вы всегда должны обходить массивы при помощи <code>ipairs</code>, а не <code>pairs</code>. Первая функция задает порядок ключей 1, 2, ..., в то время как вторая работает с естественным произвольным порядком таблицы.</p>
<p>В качестве более продвинутого решения мы можем написать итератор, который перебирает таблицу, следуя порядку ее ключей. Необязательный параметр <code>f</code> позволяет задать другой порядок. Этот итератор сначала сортирует ключи в отдельный массив, а затем уже обходит этот массив. На каждом шаге он возвращает ключ и его значение из исходного таблицы:</p>
<pre><code>function pairsByKeys (t, f)
  local a = {}
  for n in pairs(t) do a[#a + 1] = n end
  table.sort(a, f)
  local i = 0           -- итерационная переменная
  return function ()    -- итерирующая функция
    i = i + 1
    return a[i], t[a[i]]
  end
end</code></pre>
<p>При помощи этой функции можно легко напечатать имена тех функций в алфавитном порядке:</p>
<pre><code>for name, line in pairsByKeys(lines) do
  print(name, line)
end</code></pre>
<h3 id="Chapter20.xhtml#sigil_toc_id_149">20.3. Конкатенация</h3>
<p>Мы уже видели <code>table.concat</code> в разделе 11.6. Она берет список строк и возвращает результат конкатенации всех этих строк. Необязательный второй аргумент задает разделитель строк, который вставляется между строками из списка. Данная функция также принимает два других необязательных аргумента, которые задают индексы первой и последней конкатенируемых строк.</p>
<p>Следующая функция является интересным обобщением <code>table.concat</code>. Она способна принимать вложенные списки строк:</p>
<pre><code>function rconcat (l)
  if type(l) ~= &quot;table&quot; then return l end
  local res = {}
  for i = 1, #l do
    res[i] = rconcat(l[i])
  end
  return table.concat(res)
end</code></pre>
<p>Для каждого элемента списка функция <code>rconcat</code> рекурсивно вызывает себя для конкатенации возможного вложенного списка. Затем она вызывает исходную <code>table.concat</code> для объединения всех промежуточных результатов.</p>
<pre><code>print(rconcat{{&quot;a&quot;, {&quot; nice&quot;}}, &quot; and&quot;, {{&quot; long&quot;}, {&quot; list&quot;}}})
  --&gt; аккуратный и длинный список</code></pre>
<h3 id="Chapter20.xhtml#sigil_toc_id_150">Упражнения</h3>
<p><strong>Упражнение 20.1.</strong> Перепишите функцию <code>rconcat</code> так, чтобы она могла принимать разделитель, как это делает <code>table.concat</code>:</p>
<pre><code>print(rconcat({{{&quot;a&quot;, &quot;b&quot;}, {&quot;c&quot;}}, &quot;d&quot;, {}, {&quot;e&quot;}}, &quot;;&quot;)
  --&gt; a;b;c;d;e</code></pre>
<p><strong>Упражнение 20.2.</strong> Проблема с <code>table.sort</code> в том, что эта сортировка не устойчива, то есть элементы, которые функция упорядочения считает равными, могут и не сохранить свой первоначальный порядок в массиве после сортировки. Как можно реализовать устойчивую сортировку в Lua?</p>
<p><strong>Упражнение 20.3.</strong> Напишите функцию для проверки того, является ли заданная таблица допустимой последовательностью.</p>
<p><span id="Chapter21.xhtml"></span></p>
<h2>ГЛАВА 21</h2>
<h2 id="Chapter21.xhtml#sigil_toc_id_151">Строковая библиотека</h2>
<p>Возможности самого интерпретатора Lua для работы со строками довольно ограничены. Программа может создавать строковые литералы, соединять их и получать длину строки. Но она не может извлекать подстроки или исследовать их содержимое. Полноценные возможности обработки строк в Lua заключены в его строковой библиотеке.</p>
<p>Строковая библиотека экспортирует свои функции в виде модуля с именем <code>string</code>. Начиная с Lua 5.1, она также экспортирует свои функции как методы, принадлежащие типу string (при помощи метатаблицы данного типа). Поэтому, например, перевод строки в заглавные буквы можно записать либо как <code>string.upper(s)</code>, либо как <code>s:upper()</code>. Выбирайте сами.</p>
<h3 id="Chapter21.xhtml#sigil_toc_id_152">21.1. Основные строковые функции</h3>
<p>Некоторые функции в строковой библиотеке крайне просты: вызов <code>string.len(s)</code> возвращает длину строки <code>s</code>. Это эквивалентно <code>#s</code>. Вызов <code>string.rep(s,n)</code> (или <code>s:rep(n)</code>) возвращает строку <code>s</code>, повторенную <code>n</code> раз. Вы можете создать строку в 1 Мб (например, для тестов) при помощи <code>string.rep(&quot;а&quot;,2^20)</code>. Вызов <code>string.lower(s)</code> возвращает копию <code>s</code>, у которой заглавные буквы преобразованы в строчные; все прочие символы остаются прежними. (Функция <code>string.upper</code> преобразует строчные буквы в заглавные.) Обычно, когда требуется отсортировать строки независимо от регистра их букв, можно написать что-то вроде этого:</p>
<pre><code>table.sort(a, function (a, b)
  return a:lower() &lt; b:lower()
end)</code></pre>
<p>Вызов <code>string.sub(s,i,j)</code> извлекает часть строки <code>s</code> от символа с индексом <code>i</code> по символ с индексом <code>j</code> включительно. В Lua индекс первого символа строки равен 1. При этом вы можете применять отрицательные индексы, которые отсчитываются с конца строки: индекс -1 ссылается на последний символ строки, -2 на предпоследний символ и т. д. Таким образом, вызов <code>string.sub(s,1,j)</code> (или <code>s:sub(1,j)</code>) возвращает префикс строки <code>s</code> c длиной, равной <code>j</code>; вызов <code>string.sub(s,j,-1)</code> (или просто <code>s:sub(j)</code>, поскольку значением по умолчанию для последнего аргумента является -1) возвращает окончание строки, начиная с символа с индексом <code>j</code>; а вызов <code>string.sub(s,2,-2)</code> возвращает копию строки <code>s</code>, в которой удалены первый и последний символы:</p>
<pre><code>s = &quot;[in brackets]&quot;
print(s:sub(2, -2))    --&gt; in brackets</code></pre>
<p>Помните, что строки в Lua неизменяемы. Функция <code>string.sub</code>, как и любая другая функция в Lua, не изменяет значение строки, а возвращает новую строку. Написать нечто вроде <code>s:sub(2,-2)</code> и ждать, что это изменит значение строки <code>s</code>, — распространенная ошибка. Если вы хотите изменить значение переменной, то вы должны присвоить ей новое значение:</p>
<pre><code>s = s:sub(2, -2)</code></pre>
<p>Функции <code>string.char</code> и <code>string.byte</code> выполняют преобразование между символами и их внутренними числовыми представлениями. Функция <code>string.char</code> принимает ноль или более целых чисел, преобразует каждое из них в символ и возвращает строку, в которой все эти символы соединены. Вызов <code>string.byte(s,i)</code> возвращает внутреннее числовое представление символа с индексом <code>i</code> в строке <code>s</code>; второй аргумент необязателен, поэтому вызов <code>string.byte(s)</code> возвращает внутреннее числовое представление первого (или единственного) символа строки <code>s</code>. В следующих примерах мы считаем, что символы представлены кодировкой ASCII:</p>
<pre><code>print(string.char(97))                     --&gt; a
i = 99; print(string.char(i, i+1, i+2))    --&gt; cde
print(string.byte(&quot;abc&quot;))                  --&gt; 97
print(string.byte(&quot;abc&quot;, 2))               --&gt; 98
print(string.byte(&quot;abc&quot;, -1))              --&gt; 99</code></pre>
<p>В последней строке кода мы использовали отрицательный индекс для обращения к последнему символу строки.</p>
<p>Начиная с Lua 5.1, функция <code>string.byte</code> поддерживает третий необязательный аргумент. Вызов наподобие <code>string.byte(s,i,j)</code> ряд значений в форме числовых представлений всех символов между индексами <code>i</code> и <code>j</code> включительно:</p>
<pre><code>print(string.byte(&quot;abc&quot;, 1, 2))</code></pre>
<p>Значением по умолчанию для <code>j</code> является <code>i</code>, поэтому вызов без третьего аргумента возвращает лишь символ по индексу <code>i</code>. Есть прекрасная идиома <code>{s:byte(1,-1)}</code>, которая создает таблицу с кодами всех символов строки <code>s</code>. По этой таблице мы можем воссоздать исходную строку путем вызова <code>string.char(table.unpack(t))</code>. Этот прием не работает для очень длинных строк (более 1 Мб), поскольку в Lua есть ограничение на число возвращаемых функцией значений.</p>
<p>Функция <code>string.format</code> — это мощный инструмент для форматирования строк, обычно для вывода. Она возвращает отформатированную версию всех своих аргументов (так как является варидической), следуя описанию, заданному своим первым аргументом, так называемой <em>форматирующей строкой</em> <strong>(format string)</strong>. Форматирующая строка следует правилам, похожим на те, что используются в функции <code>printf</code> стандартного С: она состоит из обычного текста и указаний, которые руководят тем, где и как будет помещен каждый аргумент в отформатированной строке. <em>Указание</em> <strong>(directive)</strong> состоит из символа '<code>%</code>' и буквы, которая поясняет, как отформатировать аргумент: '<code>d</code>' для десятичных чисел, '<code>х</code>' для шестнадцатеричных чисел, '<code>о</code>' для восьмеричных, '<code>f</code>' для чисел с плавающей точкой, '<code>s</code>' для строк; есть и другие варианты. Между '<code>%</code>' и буквой могут быть включены другие опции, управляющие деталями форматирования, например, количеством десятичных цифр для числа с плавающей точкой:</p>
<pre><code>print(string.format(&quot;pi = %.4f&quot;, math.pi))         --&gt; pi = 3.1416
d = 5; m = 11; y = 1990
print(string.format(&quot;%02d/%02d/%04d&quot;, d, m, y))    --&gt; 05/11/1990
tag, title = &quot;h1&quot;, &quot;a title&quot;
print(string.format(&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;, tag, title, tag))
  --&gt; &lt;h1&gt;a title&lt;/h1&gt;</code></pre>
<p>В первом примере <code>%.4f</code> означает число с плавающей точкой с четырьмя цифрами после десятичной точки. Во втором примере <code>%02d</code> обозначает десятичное число минимум из двух цифр с дополнением нулями при необходимости; указание <code>%2d</code> без нуля дополняло бы число пробелами. За полным описанием этих указаний обратитесь к справочнику по Lua или, еще лучше, обратитесь к справочнику по С, так как Lua вызывает функции из стандартной библиотеки С для выполнения данной тяжелой работы.</p>
<h3 id="Chapter21.xhtml#sigil_toc_id_153">21.2. Функции сопоставления с образцом</h3>
<p>Наиболее эффективными функциями в строковой библиотеке являются функци <code>find</code> (поиск), <code>match</code> (сопоставление), <code>gsub</code> (глобальная замена) и <code>gmatch</code> (глобальное сопоставление). Все они основаны на <em>образцах</em> <strong>(pattern)</strong>.</p>
<p>В отличие от ряда других скриптовых языков, Lua не использует для сопоставления с образцом <strong>(pattern matching)</strong> регулярные выражения из POSIX или Perl. Главной причиной этого решения является размер: типичная реализация регулярных выражений POSIX занимает более 4000 строк кода. Это больше размера всех вместе взятых стандартных библиотек Lua. Для сравнения реализация сопоставления с образцом в Lua занимает менее 600 строк. Конечно, сопоставление с образцом в Lua уступает полноценной реализации POSIX. Тем не менее, сопоставление с образцом в Lua является мощным инструментом и включает в себя некоторые возможности, для которых нелегко подобрать аналог в стандартных реализациях POSIX.</p>
<h4 id="Chapter21.xhtml#sigil_toc_id_154">Функция <code>string.find</code></h4>
<p>Функция <code>string.find</code> ищет образец внутри заданной обрабатываемой строки. Простейшей формой образца является слово, которое соответствует лишь копии самого себя. Например, образец '<code>hello</code>' задаст поиск подстроки &quot;<code>hello</code>&quot; внутри обрабатываемой строки. При нахождении образца <code>find</code> возвращает два значения: индекс, с которого начинается совпадение, и индекс, на котором совпадение заканчивается. Если совпадение не найдено, возвращается nil:</p>
<pre><code>s = &quot;hello world&quot;
i, j = string.find(s, &quot;hello&quot;)
print(i, j)                       --&gt; 1 5
print(string.sub(s, i, j))        --&gt; hello
print(string.find(s, &quot;world&quot;))    --&gt; 7 11
i, j = string.find(s, &quot;l&quot;)
print(i, j)                       --&gt; 3 3
print(string.find(s, &quot;lll&quot;))      --&gt; nil</code></pre>
<p>Когда совпадение найдено, мы можем вызвать <code>string.sub</code> со значениями, возвращенными <code>string.find</code>, чтобы получить часть обрабатываемой строки, удовлетворяющей образцу. Для простых образцов этой частью будет сам образец.</p>
<p>У функции <code>string.find</code> есть необязательный третий параметр: индекс, указывающий, с какого места обрабатываемой строки следует начать поиск. Этот параметр удобен, когда мы хотим обработать все индексы, где был обнаружен заданный образец: мы систематически ищем новый образец, каждый раз начиная с той позиции, где мы нашли предыдущий. В качестве примера следующий код строит таблицу с позициями всех переводов строки внутри заданной строки:</p>
<pre><code>local t = {}                     -- таблица для хранения индексов
local i = 0
while true do
i = string.find(s, &quot;\n&quot;, i+1)    -- ищет следующий перевод строки
if i == nil then break end
t[#t + 1] = i
end</code></pre>
<p>Позже мы увидим более простой способ записи подобных циклов — с применением итератора <code>string.gmatch</code>.</p>
<h4 id="Chapter21.xhtml#sigil_toc_id_155">Функция <code>string.match</code></h4>
<p>Функция <code>string.match</code> похожа на <code>string.find</code> в том смысле, что она тоже ищет образец в строке. Однако, вместо возвращения тех позиций, где был найден образец, она возвращает часть обрабатываемой строки, удовлетворяющую образцу:</p>
<pre><code>print(string.match(&quot;hello world&quot;, &quot;hello&quot;))    --&gt; hello</code></pre>
<p>Для фиксированных образцов вроде '<code>hello</code>' эта функция не имеет смысла. Она показывает свою эффективность, когда используется с переменными образцами, как в следующем примере:</p>
<pre><code>date = &quot;Today is 17/7/1990&quot;
d = string.match(date, &quot;%d+/%d+/%d+&quot;)
print(d)   --&gt; 17/7/1990</code></pre>
<p>Вскоре мы обсудим значение образца <code>'%d+/%d+/%d+'</code> и более продвинутое применение <code>string.match</code>.</p>
<h4 id="Chapter21.xhtml#sigil_toc_id_156">Функция <code>string.gsub</code></h4>
<p>У функции <code>string.gsub</code> три обязательных параметра: обрабатываемая строка, образец и замещающая строка. Ее основное применение состоит в замене всех вхождений образца на замещающую строку внутри обрабатываемой:</p>
<pre><code>s = string.gsub(&quot;Lua is cute&quot;, &quot;cute&quot;, &quot;great&quot;)
print(s)            --&gt; Lua is great
s = string.gsub(&quot;all lii&quot;, &quot;l&quot;, &quot;x&quot;)
print(s)            --&gt; axx xii
s = string.gsub(&quot;Lua is great&quot;, &quot;Sol&quot;, &quot;Sun&quot;)
print(s)            --&gt; Lua is great</code></pre>
<p>Необязательный четвертый параметр ограничивает число выполняемых замен:</p>
<pre><code>s = string.gsub(&quot;all lii&quot;, &quot;l&quot;, &quot;x&quot;, 1)
print(s)            --&gt; axl lii
s = string.gsub(&quot;all lii&quot;, &quot;l&quot;, &quot;x&quot;, 2)
print(s)            --&gt; axx lii</code></pre>
<p>Функция <code>string.gsub</code> также возвращает в качестве второго значения число выполненных замен. Например, простой способ посчитать число пробелов в строке:</p>
<pre><code>count = select(2, string.gsub(str, &quot; &quot;, &quot; &quot;))</code></pre>
<h4 id="Chapter21.xhtml#sigil_toc_id_157">Функция <code>string.gmatch</code></h4>
<p>Функция <code>string.gmatch</code> возвращает функцию, которая перебирает все вхождения образца в строку. Например, следующий пример собирает все слова в заданной строке <code>s</code>:</p>
<pre><code>words = {}
for w in string.gmatch(s, &quot;%a+&quot;) do
  words[#words + 1] = w
end</code></pre>
<p>Как мы вскоре обсудим, образец '<code>%а+</code>' соответствует последовательностям из одной или более букв (то есть словам). Поэтому цикл <strong>for</strong> обойдет все слова внутри обрабатываемой строки, сохраняя их в список <code>words</code>.</p>
<p>Следующий пример реализует функцию, аналогичную <code>package.searchpath</code>, при помощи <code>gmatch</code> и <code>gsub</code>:</p>
<pre><code>function search (modname, path)
  modname = string.gsub(modname, &quot;%.&quot;, &quot;/&quot;)
  for c in string.gmatch(path, &quot;[^;]+&quot;) do
    local fname = string.gsub(c, &quot;?&quot;, modname)
    local f = io.open(fname)
    if f then
      f:close()
      return fname
    end
  end
  return nil    -- не найден
end</code></pre>
<p>Первым шагом будет замена всех точек на разделитель путей директорий, которым в данном примере является '<code>/</code>' (Как мы в дальнейшем увидим, у точки в образцах особое назначение. Для сопоставления с символом точки мы должны написать '<code>%.</code>'.) Далее функция перебирает все составляющие пути, где каждая составляющяя — это непрерывный ряд любых символов, отличных от точки с запятой. Для каждой составляющей функция меняет все вопросительные знаки на имя модуля и проверяет, существует ли такой файл. Если да, то функция закрывает этот файл и возвращает его имя.</p>
<h3 id="Chapter21.xhtml#sigil_toc_id_158">21.3. Образцы</h3>
<p>Вы можете сделать образцы более полезными при помощи классов символов. <em>Класс символов</em> <strong>(character class)</strong> — это элемент в образце, который может соответствовать любому символу из заданного множества. Например, класс <code>%d</code> соответствует любой цифре. Таким образом, вы можете искать дату в формате <code>dd/mm/yyyy</code> при помощи образца '<code>%d%d/%d%d/%d%d%d%d</code>':</p>
<pre><code>s = &quot;Deadline is 30/05/1999, firm&quot;
date = &quot;%d%d/%d%d/%d%d%d%d&quot;
print(string.sub(s, string.find(s, date)))    --&gt; 30/05/1999</code></pre>
<p>Следующая таблица содержит список всех классов символов:</p>
<table>
<tbody>
<tr class="odd">
<td><code>.</code> все символы<br />
<code>%a</code> буквы<br />
<code>%c</code> управляющие символы<br />
<code>%d</code> цифры<br />
<code>%g</code> печатные символы кроме пробельных<br />
<code>%l</code> строчные буквы<br />
<code>%p</code> символы пунктуации<br />
<code>%s</code> пробельные символы<br />
<code>%u</code> заглавные буквы<br />
<code>%w</code> буквенно-цифровые символы<br />
<code>%x</code> шестнадцатеричные цифры</td>
</tr>
</tbody>
</table>
<p>Любая из этих букв в верхнем регистре представляет собой дополнение класса, т.е. множество не входящих в него символов. Например, '<code>%А</code>' соответствует всем небуквенным символам:</p>
<pre><code>print(string.gsub(&quot;hello, up-down!&quot;, &quot;%A&quot;, &quot;.&quot;))
  --&gt; hello..up.down. 4</code></pre>
<p>(Число 4 не являются частью итоговой строки. Это второе значение, возвращаемое <code>gsub</code>, — полное число выполненных замен. В дальнейших примерах с выводом результата <code>gsub</code> я буду опускать это число.)</p>
<p>У некоторых символов, называемых <em>магическими символами</em> <strong>(magic character)</strong>, есть особое значение при использовании в образце. Магическими символами являются</p>
<pre><code>( ) . % + - * ? [ ] ^ $</code></pre>
<p>Символ '<code>%</code>' работает для этих магических символов как экран. Таким образом, '<code>%.</code>' соответствует точке, а '<code>%%</code>' соответствует самому символу '<code>%</code>'. Вы можете применять экранирующий '<code>%</code>' не только с магическими символами, но и с любыми символами, отличными от буквенно-цифровых. Когда сомневаетесь, не рискуйте и используйте экран.</p>
<p>Для парсера Lua образцы являются обычными строками. К ним нет особого отношения — они подчиняются тем же правилам, что и остальные строки. Только функции сопоставления с образцом рассматривают их как образцы, и только эти функции считают символ '<code>%</code>' экраном. Для помещения кавычек внутрь образца используются те же самые приемы, что и для других строк; например, вы можете экранировать кавычки при помощи '<code>\</code>', который является экранирующим символом в Lua.</p>
<p><em>Множество символов</em> <strong>(char-set)</strong> позволяет вам создавать ваши собственные классы символов, группируя различные классы и одиночные символы внутри квадратных скобок. Например, множество '<code>[%w_]</code>' соответствует как буквенно-цифровым символам, так и символу подчеркивания; множество '<code>[01]</code>' соответствует двоичным цифрам; а множество '<code>[%[%]]</code>' соответствует квадратным скобкам. Для подсчета гласных в тексте вы можете написать</p>
<pre><code>nvow = select(2, string.gsub(text, &quot;[AEIOUaeiou]&quot;, &quot;&quot;))</code></pre>
<p>При этом вы также можете включать во множества символов диапазоны, записывая первый и последний символы с дефисом между ними. Я редко пользуюсь данным средством, поскольку все наиболее употребительные диапазоны уже предопределены; например, '<code>[0-9]</code>' — это то же самое, что и '<code>%d</code>', а '<code>[0-9a-fA-F]</code>' — это то же самое, что и '<code>%х</code>' Однако, если вам потребуется найти восьмеричную цифру, то вы можете предпочесть '<code>[0-7]</code>' вместо явного перечисления '<code>[01234567]</code>'. Вы также можете получить дополнение любого множества символов, поставив перед ним '<code>^</code>': так, образец '<code>[^0-7]</code>' находит любой символ, который не является восьмеричной цифрой, а '<code>[^\n]</code>' соответствует любому символу, отличному от перевода строки. Но не забывайте, что вы можете получить дополнение для простых классов посредством их версии в верхнем регистре: '<code>%S</code>' проще, чем '<code>[^%s]</code>'.</p>
<p>Вы можете сделать образцы еще удобнее с помощью модификаторов для повторений и необязательных частей. Образцы в Lua предлагают четыре таких модификатора:</p>
<table>
<tbody>
<tr class="odd">
<td><code>+</code> 1 или более повторений<br />
<code>*</code> 0 или более повторений<br />
<code>-</code> 0 или более коротких повторений<br />
<code>?</code> 0 или 1 вхождение (необязательный образец)</td>
</tr>
</tbody>
</table>
<p>Модификатор '<code>+</code>' соответствует одному или более символам первоначального класса. Он всегда возвращает самую длинную последовательность символов, которая соответствует образцу. Например, образец '<code>%а+</code>' означает одну или несколько букв, то есть слово:</p>
<pre><code>print(string.gsub(&quot;one, and two; and three&quot;, &quot;%a+&quot;, &quot;word&quot;))
  --&gt; word, word word; word word</code></pre>
<p>Образец '<code>%d+</code>' соответствует одной или нескольким цифрам (целочисленному нумералу):</p>
<pre><code>print(string.match(&quot;the number 1298 is even&quot;, &quot;%d+&quot;))    --&gt; 1298</code></pre>
<p>Модификатор '<code>*</code>' похож на '<code>+</code>' , но при этом он допускает нулевое число вхождений символов заданного класса. Обычно используется для обозначения необязательных пробелов между частями образца. Например, для сопоставления с парой пустых круглых скобок, например <code>()</code> или <code>( )</code>, можно использовать образец '<code>%(%s*%)</code>': образец '<code>%s*</code>' соответствует нулю и более пробелов. (У круглых скобок также есть особое значение в образцах, поэтому мы должны их экранировать.) В качестве другого примера образец '<code>[_%а] [_%w]*</code>' соответствует идентификаторам внутри программы на Lua: начинается с пробела или символа подчеркивания, за которым идет ноль или большее количество подчеркиваний и буквенно-цифровых символов.</p>
<p>Подобно '<code>*</code>', модификатор '<code>-</code>' также соответствует нулю или большему количеству символов заданного класса. Однако, вместо соответствия самой длинной последовательности он соответствует самой короткой. Иногда между '<code>*</code>' и '<code>-</code>' нет никакой разницы, но обычно они дают совершенно разные результаты. Например, если вы попытаетесь найти идентификатор при помощи образца '<code>[_%а] [_%а]-</code>', то вы получите лишь первую букву, <span>поскольку '</span><code>[_%w]-</code><span>' всегда соответствует пустой последовательности. С другой стороны, предположим, что вы хотите найти комментарии в программе С. Многие сперва пробуют '</span><code>/%*.*%*/</code><span>' (то есть '</span><code>/*</code><span>', за которыми следует последовательность любых символов, за которой следует</span> &quot;<code>*/</code>&quot;, и все это с соответственными экранами<span>). Однако, поскольку '</span><code>.*</code><span>'. длится столько, сколько сможет, первые комбинация</span> &quot;<code>/*</code>&quot; в вашей программе <span>закроется лишь самой последней</span> &quot;<code>*/</code>&quot;<span>:</span></p>
<pre><code>test = &quot;int x; /* x */ int y; /* y */&quot;
print(string.match(test, &quot;/%*.*%*/&quot;))
  --&gt; /* x */ int y; /* y */</code></pre>
<p>Образец '<code>.-</code>' наоборот захватит наименьшее количество символов, необходимое для нахождения первого сочетания '<code>*/</code>', и даст, таким образом, желаемый результат:</p>
<pre><code>test = &quot;int x; /* x */ int y; /* y */&quot;
print(string.gsub(test, &quot;/%*.-%*/&quot;, &quot;&quot;))
--&gt; int x; int y;</code></pre>
<p>Последний модификатор '<code>?</code>' соответствует необязательному символу. Например, предположим, что мы хотим найти целое число в тексте, которое при этом может содержать необязательный знак. Образец '<code>[+-]?%d+</code>' справляется с работой, находя такие последовательности, как &quot;<code>-12</code>&quot;, &quot;<code>23</code>&quot; и &quot;<code>+1009</code>&quot;. Класс '<code>[+-]</code>' соответствует либо знаку '<code>+</code>', либо знаку '<code>-</code>'; следующий за ним '<code>?</code>' делает этот знак необязательным.</p>
<p>В отличие от других систем, в Lua модификатор может быть применен только к классу символов; группировать образцы под одним модификатором нельзя. Например, в Lua нет образца, соответствующего необязательному слову (если только вы не ищете однобуквенные слова). Обычно это ограничение можно обойти при помощи продвинутых приемов, которые мы рассмотрим в конце данной главы.</p>
<p>Если образец начинается с символа '<code>^</code>', то он будет сопоставляться только с началом обрабатываемой строки. И точно так же, если образец заканчивается символом '<code>$</code>', то он будет сопоставляться только с концом обрабатываемой строки. Вы можете использовать эти две метки для создания образцов. Например, следующий тест проверяет, начинается ли строка с цифры:</p>
<pre><code>if string.find(s, &quot;^%d&quot;) then ...</code></pre>
<p>А этот тест проверяет, что строка является целым числом, без других символов в начале или конце:</p>
<pre><code>if string.find(s, &quot;^[+-]?%d+$&quot;) then ...</code></pre>
<p>Символы '<code>^</code>' и '<code>$</code>' являются магическими лишь тогда, когда применяются в начале или конце образца. Иначе они служат обычными символами, которые соответствуют самим себе.</p>
<p>Еще одним элементом в образце является '<code>%b</code>', который соответствует сбалансированным строкам <strong>(у которых парные символы по краям)</strong>. Мы записываем его как '<code>%b</code><em>ху</em>', где <em>х</em> и <em>у</em> — это два разных символа; символ <em>х</em> выступает как открывающий символ, а <em>у</em> — как закрывающий. Например, образец '<code>%b()</code>' соответствует частям строки, которые начинаются с '<code>(</code>' и заканчиваются на соответствующей '<code>)</code>':</p>
<pre><code>s = &quot;a (enclosed (in) parentheses) line&quot;
print(string.gsub(s, &quot;%b()&quot;, &quot;&quot;))    --&gt; a line</code></pre>
<p>Обычно мы используем этот образец в виде '<code>%b()</code>', '<code>%b[]</code>', '<code>%b{}</code>' или '<code>%b&lt;&gt;</code>', но вы можете использовать в качестве разделителей отличные друг от друга символы.</p>
<p>Наконец, элемент '<code>%f</code><code>[</code><em>множество_символов</em><code>]</code>' является <em>пограничным образцом</em> <strong>(frontier pattern)</strong>. Он соответствует пустой строке, только если следующий символ входит во <em>множество_символов</em>, а предыдущий — нет:</p>
<pre><code>s = &quot;the anthem is the theme&quot;
print(s:gsub(&quot;%f[%w]the%f[%W]&quot;, &quot;one&quot;))
  --&gt; one anthem is one theme</code></pre>
<p>Образец '<code>%f[%w]</code>' соответствует границе между небуквенно-цифровым и буквенно-цифровым символами, а образец '<code>%f[%w]</code>' соответствует границе между буквенно-цифровым символом и небуквенно-цифровым символом. Поэтому данный образец сопоставляет строке &quot;<code>the</code>&quot; только целое слово. Обратите внимание, что мы должны писать множество символов внутри квадратных скобок даже тогда, когда оно является одним единственным классом.</p>
<p>Позиции перед первым и после последнего символов в обрабатываемой строке трактуются как содержащие нуль-символ (символ с ASCII кодом 0). В предыдущем примере первое &quot;<code>the</code>&quot; начинается с границы между нуль-символом (не во множестве '<code>[%w]</code>') и '<code>t</code>' (во множестве '<code>[%w]</code>').</p>
<p>Пограничный образец был реализован еще в Lua 5.1, но не был документирован. Официальным он стал только в Lua 5.2.</p>
<h3 id="Chapter21.xhtml#sigil_toc_id_159">21.4. Захваты</h3>
<p>Механизм <em>захвата</em> <strong>(capture)</strong> позволяет образцу выдергивать из обрабатываемой строки те части, которые удовлетворяют частям образца, в целях дальнейшего использования. Вы можете указать захват посредством записи захватываемых частей образца внутри круглых скобок.</p>
<p>Когда в образце есть захваты, то функция <code>string.match</code> возвращает каждое захваченное значение как отдельный результат; другими словами, она разбивает строку на ее захваченные части.</p>
<pre><code>pair = &quot;name = Anna&quot;
key, value = string.match(pair, &quot;(%a+)%s*=%s*(%a+)&quot;)
print(key, value)    --&gt; name Anna</code></pre>
<p>Образец '<code>%a+</code>' задает непустую последовательность букв; образец '<code>%s*</code>' задает возможно пустую последовательность пробелов. Поэтому в примере выше весь образец задает последовательности и знак равенства в следующем порядке: буквы, пробелы, знак равенства, пробелы, буквы. У обеих последовательностей букв их образцы заключены в круглые скобки, поэтому при соответствии они будут захвачены. Ниже похожий пример:</p>
<pre><code>date = &quot;Today is 17/7/1990&quot;
d, m, y = string.match(date, &quot;(%d+)/(%d+)/(%d+)&quot;)
print(d, m, y) --&gt; 17 7 1990</code></pre>
<p>Внутри образца элемент вида '<code>%</code><em>d</em>', где <em>d</em> — это одиночная цифра, соответствует лишь копии <em>d</em>-ого захвата. Чтобы продемонстрировать типичное применение, рассмотрим случай, когда вы хотите внутри строки найти подстроку, заключенную в одинарные или двойные кавычки. Вы можете попробовать образец наподобие '<code>[&quot;'].-[&quot;']</code>', то есть кавычка, за которой следует что угодно, за которым следует другая кавычка; но при этом у вас будут проблемы со строками вроде &quot;<code>it's all right</code>&quot;. Для решения данной проблемы можно захватить первую кавычку и использовать ее для задания второй кавычки:</p>
<pre><code>s = [[then he said: &quot;it&#39;s all right&quot;!]]
q, quotedPart = string.match(s, &quot;([\&quot;&#39;])(.-)%1&quot;)
print(quotedPart)    --&gt; it&#39;s all right
print(q)             --&gt; &quot;</code></pre>
<p>Первый захват — это сам символ кавычки, а второй — это подстрока между кавычками (подстрока, удовлетворяющая '<code>.-</code>')</p>
<p>Похожим примером является образец, соответствующий длинным строкам в Lua:</p>
<pre><code>%[(=*)%[(.-)%]%1%]</code></pre>
<p>Он соответствует символам в следующем порядке: открывающая квадратная скобка, ноль или большее число знаков равенства, еще одна открывающая квадратная скобка, что угодно (содержимое строки), закрывающая квадратная скобка, то же самое количество знаков равенства, еще одна закрывающая квадратная скобка. Пример:</p>
<pre><code>p = &quot;%[(=*)%[(.-)%]%1%]&quot;
s = &quot;a = [=[[[ something ]] ]==] ]=]; print(a)&quot;
print(string.match(s, p))    --&gt; = [[ something ]] ]==]</code></pre>
<p>Первый захват — это последовательность знаков равенства (в данном примере лишь один знак); второй захват — это содержимое строки.</p>
<p>Третья область применения захваченных значений — замещающая строка для <code>gsub</code>. Как и образец, замещающая строка может содержать элементы наподобие '<code>%</code><em>d</em>', которые заменяются на соответствующие захваты при выполнении подстановки. В частности, элемент '<code>%0</code>' меняется на полное соответствие. (Кстати, '<code>%</code>' в замещающей строке должен быть экранирован как '<code>%%</code>'.) В качестве примера, следующая команда дублирует каждую букву в строке, добавляя дефис между копиями:</p>
<pre><code>print(string.gsub(&quot;hello Lua!&quot;, &quot;%a&quot;, &quot;%0-%0&quot;))
  --&gt; h-he-el-ll-lo-o L-Lu-ua-a!</code></pre>
<p>Этот пример меняет местами соседние символы:</p>
<pre><code>print(string.gsub(&quot;hello Lua&quot;, &quot;(.)(.)&quot;, &quot;%2%1&quot;))    --&gt; ehll ouLa</code></pre>
<p>В качестве более полезного примера давайте напишем простой преобразователь формата, который получает строку с командами в стиле LaTeX и переводит их в формат XML:</p>
<pre><code>\command{some text}    --&gt; &lt;command&gt;some text&lt;/command&gt;</code></pre>
<p>Если нам не нужны вложенные команды, то поможет следующий вызов <code>string.gsub</code>:</p>
<pre><code>s = [[the \quote{task} is to \em{change} that.]]
s = string.gsub(s, &quot;\\(%a+){(.-)}&quot;, &quot;&lt;%1&gt;%2&lt;/%1&gt;&quot;)
print(s)
  --&gt; the &lt;quote&gt;task&lt;/quote&gt; is to &lt;em&gt;change&lt;/em&gt; that.</code></pre>
<p>(В следующем разделе мы увидим, как обрабатывать вложенные команды.)</p>
<p>Еще один полезный пример удаляет пробелы по краям строки:</p>
<pre><code>function trim (s)
  return (string.gsub(s, &quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;))
end</code></pre>
<p>Обратите внимание на разумный выбор формата образцов. Два якоря ('<code>^</code>' и '<code>$</code>') обеспечивают получение всей строки. Поскольку '<code>.-</code>' старается выбрать наименьшее число символов, два образца '<code>%s*</code>' соответствуют всем пробелам по краям. Также обратите внимание, что поскольку <code>gsub</code> возвращает два значения, то мы используем круглые скобки вокруг его вызова для отбрасывания лишнего результата (числа замен).</p>
<h3 id="Chapter21.xhtml#sigil_toc_id_160">21.5. Замены</h3>
<p>Вместо строки в качестве третьего аргумента <code>string.gsub</code> мы можем использовать функцию или таблицу. При вызове с функцией <code>string.gsub</code> вызывает эту функцию каждый раз, когда находит соответствие; аргументами каждого вызова являются захваты, а возвращенное функцией значение используется в качестве замещающей строки. При вызове с таблицей <code>string.gsub</code> обращается к ней, используя первый захват как ключ, а связанное с ним значение как замещающую строку. Если результатом вызова или обращения к таблице является nil, то <code>gsub</code> не производит замену совпавшей части.</p>
<p>В качестве первого примера следующая функция расширяет переменные путем замены внутри строки значения переменной <code>$varname</code> на значение глобальной переменной <code>varname</code>:</p>
<pre><code>function expand (s)
  return (string.gsub(s, &quot;$(%w+)&quot;, _G))
end

name = &quot;Lua&quot;; status = &quot;great&quot;
print(expand(&quot;$name is $status, isn&#39;t it?&quot;))
  --&gt; Lua is great, isn&#39;t it?</code></pre>
<p>При каждом совпадении с '<code>$(%w+)</code>' (знак доллара, за которым следует имя переменной) функция <code>gsub</code> ищет захваченное имя в глобальной таблице <code>_G</code>; результат заменяет совпавшую часть строки. Когда в таблице нет соответствующего ключа, замена не производится:</p>
<pre><code>print(expand(&quot;$othername is $status, isn&#39;t it?&quot;))
  --&gt; $othername is great, isn&#39;t it?</code></pre>
<p>Если вы не уверены в том, есть ли у данных переменных строковые значения, то вы можете попробовать применить к их значениям <code>tostring</code>. В таком случае в качестве замещающего значения вы можете использовать функцию:</p>
<pre><code>function expand (s)
  return (string.gsub(s, &quot;$(%w+)&quot;, function (n)
                                     return tostring(_G[n])
                                   end))
end

print(expand(&quot;print = $print; a = $a&quot;))
  --&gt; print = function: 0x8050ce0; a = nil</code></pre>
<p>Теперь при каждом совпадении с образцом '<code>$(%w+)</code>' функция <code>gsub</code> вызывает заданную функцию с захваченным именем в качестве аргумента; возвращенное значение используется для замены.</p>
<p>В последнем примере мы возвращаемся к нашему преобразователю формата из предыдущего раздела. И вновь мы хотим преобразовывать команды в стиле LaTeX (<code>\example{text}</code>) в команды в стиле XML (<code>text</code>), но на этот раз мы разрешим вложенные команды. Следующая функция использует для этого рекурсию:</p>
<pre><code>function toxml (s)
  s = string.gsub(s, &quot;\\(%a+)(%b{})&quot;, function (tag, body)
        body = string.sub(body, 2, -2)    -- убирает квадратные скобки
        body = toxml(body)                -- обрабатывает вложенные команды
        return string.format(&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;, tag, body, tag)
      end)
  return s
end

print(toxml(&quot;\\title{The \\bold{big} example}&quot;))
  --&gt; &lt;title&gt;The &lt;bold&gt;big&lt;/bold&gt; example&lt;/title&gt;</code></pre>
<h4 id="Chapter21.xhtml#sigil_toc_id_161">Кодировка URL</h4>
<p>Для нашего следующего примера мы воспользуемся <em>кодировкой URL</em> <strong>(URL encoding)</strong>, которая применяется HTTP для передачи параметров в URL. Кодировка преобразует специальные символы (наподобие '<code>=</code>', '<code>&amp;</code>' и '<code>+</code>') в '<code>%</code><em>хх'</em>, где <em>хх</em> — это шестнадцатеричный код этих символов. После этого она меняет пробелы на '<code>+</code>'. Например, данная кодировка зашифрует &quot;<code>а+b = с</code>&quot; как &quot;<code>%2Bb+%3D+c</code>&quot;. И наконец, она записывает имя каждого параметра и его значение со знаком равенства между ними и соединяет получившиеся пары <code>name=value</code> <span>с помощью амперсанда ('</span><code>&amp;</code><span>') между ними</span><span>. Например, значения</span></p>
<pre><code>name = &quot;al&quot;; query = &quot;a+b = c&quot;; q=&quot;yes or no&quot;</code></pre>
<p>будут закодированы как &quot;<code>name=al&amp;query=a%2Bb+%3D+c&amp;q=yes+or+no</code>&quot;.</p>
<p>Теперь допустим, что нам требуется декодировать этот URL и сохранить каждое значение в таблицу, проиндексировав его именем соответственного параметра. Следующая функция выполняет основное декодирование:</p>
<pre><code>function unescape (s)
  s = string.gsub(s, &quot;+&quot;, &quot; &quot;)
  s = string.gsub(s, &quot;%%(%x%x)&quot;, function (h)
      return string.char(tonumber(h, 16))
    end)
  return s
end</code></pre>
<p>Первый оператор заменяет каждый '<code>+</code>' в строке на пробел. Второй <code>gsub</code> сопоставляет все шестнадцатеричные нумералы из двух цифр, перед которыми стоит '<code>%</code>' и для каждого совпадения вызывает анонимную функцию. Эта функция преобразует шестнадцатеричный нумерал в число (<code>tonumber</code> по основанию 16) и возвращает соответствующий символ (<code>string.char</code>). Например:</p>
<pre><code>print(unescape(&quot;a%2Bb+%3D+c&quot;))    --&gt; a+b = c</code></pre>
<p>Для декодирования пap <code>name=value</code> мы воспользуемся <code>gmatch</code>. Поскольку и имя, и значение не могут содержать '<code>&amp;</code>' или '<code>=</code>', то мы можем сопоставить их при помощи образца '<code>[^&amp;=]+</code>':</p>
<pre><code>cgi = {}
function decode (s)
  for name, value in string.gmatch(s, &quot;([^&amp;=]+)=([^&amp;=]+)&quot;) do
    name = unescape(name)
    value = unescape(value)
    cgi[name] = value
  end
end</code></pre>
<p>Вызов <code>gmatch</code> сопоставляет все пары вида <code>name=value</code>. Для каждой пары итератор возвращает соответствующие захваты (отмеченные круглыми скобками в образце) как значения для <code>name</code> и <code>value</code>. Тело цикла просто вызывает <code>unsecape</code> для обеих строк и записывает эту пару в таблицу <code>cgi</code>.</p>
<p>Также легко записать и соответствующее кодирование. Для начала мы напишем функцию <code>escape</code>; эта функция кодирует все специальные символы как '<code>%</code>', за которым следует шестнадцатеричный код символа (функция <code>format</code> с опцией &quot;<code>%02Х</code>&quot; создает шестнадцатеричное число из двух цифр, используя 0 как заполнитель), а затем меняет пробелы на '<code>+</code>':</p>
<pre><code>function escape (s)
  s = string.gsub(s, &quot;[&amp;=+%%%c]&quot;, function (c)
      return string.format(&quot;%%%02X&quot;, string.byte(c))
    end)
  s = string.gsub(s, &quot; &quot;, &quot;+&quot;)
  return s
end</code></pre>
<p>Функция <code>encode</code> обходит всю таблицу, которую нужно закодировать, строя при этом итоговую строку:</p>
<pre><code>function encode (t)
  local b = {}
  for k,v in pairs(t) do
    b[#b + 1] = (escape(k) .. &quot;=&quot; .. escape(v))
  end
  return table.concat(b, &quot;&amp;&quot;)
end

t = {name = &quot;al&quot;, query = &quot;a+b = c&quot;, q = &quot;yes or no&quot;}
print(encode(t))    --&gt; q=yes+or+no&amp;query=a%2Bb+%3D+c&amp;name=al</code></pre>
<h4 id="Chapter21.xhtml#sigil_toc_id_162">Разложение символов табуляции на пробелы</h4>
<p>У пустого захвата наподобие '<code>()</code>' в Lua есть особое значение. Вместо того, чтобы не захватывать ничего (довольно бесполезное занятие), этот образец захватывает свою позицию в обрабатываемой строке как число:</p>
<pre><code>print(string.match(&quot;hello&quot;, &quot;()ll()&quot;))    --&gt; 3    5</code></pre>
<p>(Обратите внимание, что результат этого примера отличается от результата вызова <code>string.find</code>, поскольку позиция второго пустого захвата следует <em>после</em> совпадения с образцом.)</p>
<p>Прекрасным примером использования позиционных захватов является разложение символов табуляции в строке на пробелы:</p>
<pre><code>function expandTabs (s, tab)
  tab = tab or 8 -- tab &quot;size&quot; (default is 8)
  local corr = 0
  s = string.gsub(s, &quot;()\t&quot;, function (p)
      local sp = tab - (p - 1 + corr)%tab
      corr = corr - 1 + sp
      return string.rep(&quot; &quot;, sp)
    end)
  return s
end</code></pre>
<p>Образец <code>gsub</code> находит все символы табуляции внутри строки, захватывая их позиции. Для каждого символа табуляции внутренняя функция использует эту позицию, чтобы вычислить количество пробелов, которое нужно, чтобы получить столбец, кратный значению <code>tab</code>: сначала она вычитает единицу из этой позиции, чтобы выставить начало в ноль, а затем добавляет <code>corr</code> для компенсации предыдущих символов табуляции (замена каждого символа табуляции влияет на позицию последующих символов). Затем функция вычисляет поправку для следующего символа табуляции: вычитает единицу для удаляемого таба и прибавляет <code>sp</code> для добавляемых пробелов. Наконец, она возвращает строку с соответствующим числом пробелов.</p>
<p>Для полноты давайте рассмотрим, как можно обратить эту операцию, преобразуя пробелы в символы табуляции. Можно было бы тоже начать с использования пустых захватов для обработки позиций, но есть более простое решение: на каждом восьмом символе мы вставим пометку внутрь строки. Затем всякий раз, когда перед этой пометкой будут стоять пробелы, мы заменим эту последовательность из пробелов и метки символом табуляции:</p>
<pre><code>function unexpandTabs (s, tab)
  tab = tab or 8
  s = expandTabs(s)
  local pat = string.rep(&quot;.&quot;, tab)
  s = string.gsub(s, pat, &quot;%0\1&quot;)
  s = string.gsub(s, &quot; +\1&quot;, &quot;\t&quot;)
  s = string.gsub(s, &quot;\1&quot;, &quot;&quot;)
  return s
end</code></pre>
<p>Эта функция начинает с разложения строки для удаления всех предыдущих символов табуляции. Затем она вычисляет вспомогательный образец для сопоставления с ним всех последовательностей длиной <code>tab</code> символов, и использует этот образец для добавления метки (управляющего символа <code>\1</code>) после каждой последовательности длиной <code>tab</code> символов. Далее функция заменяет все последовательности пробелов, за которыми следует метка, символами табуляции. И наконец, она удаляет все оставшиеся метки (те, что без пробелов перед ними).</p>
<h3 id="Chapter21.xhtml#sigil_toc_id_163">21.6. Специфические приемы</h3>
<p>Сопоставление с образцом — это мощный инструмент для работы со строками. Вы можете выполнить множество сложных действий всего несколькими вызовами <code>string.gsub</code>. Однако, как и любой другой мощный инструмент, ее следует применять аккуратно.</p>
<p>Сопоставление с образцом не заменит полноценный парсер. Для программ на скорую руку, вы можете воспользоваться им для удобной обработки исходного кода, но получить качественный продукт таким образом будет тяжело. В качестве хорошего примера рассмотрим образец, который мы использовали для сопоставления с комментариями в программе С: '<code>/%*.-%*/</code>'. Если в вашей программе есть строковый литерал, содержащий &quot;<code>/</code><code>*</code>&quot;, то вы можете получить неверный результат:</p>
<pre><code>test = [[char s[] = &quot;a /* here&quot;; /* a tricky string */]]
print(string.gsub(test, &quot;/%*.-%*/&quot;, &quot;&lt;COMMENT&gt;&quot;))
  --&gt; char s[] = &quot;a &lt;COMMENT&gt;</code></pre>
<p>Строки с подобным содержимым довольно редки, и для ваших личных целей подобный образец, скорее всего, будет работать. Но вы не должны распространять программу с таким недостатком.</p>
<p>Обычно сопоставление с образцом в Lua довольно эффективно: моему старому Pentium нужно менее 0.3 секунды, чтобы провести сопоставление со всеми словами в тексте размером 4.4 Мб (850К слов). Но вы можете предпринять меры предосторожности. Вы всегда должны делать образец как можно более точным, так как неточные образцы медленнее точных. Крайне простой пример — образец '<code>(.-)%$</code>' для получения всего текста до первого знака доллара. Если в обрабатываемой строке есть знак доллара, то все пройдет гладко; но предположим, что в строке вообще нет ни одного знака доллара. Алгоритм попытается найти соответствие образцу, начав с первой позиции строки. В поисках доллара он пробежит всю строку. Когда строка закончится, алгоритм даст сбой <em>для первой позиции</em> строки. Затем алгоритм выполнит полностью новый поиск, начав со второй позиции строки, и обнаружит, что здесь тоже нет соответствия образцу, и т. д. Это выльется в квадратичную зависимость от времени, занимая более 4 минут на моем старом Pentium для строки из 100К символов. Вы можете легко исправить данную проблему, привязав образец к первой позиции строки при помощи '<code>^(.-)%$</code>'. С этой привязкой образец будет сопоставлен за сотую долю секунды.</p>
<p>Также обращайте внимание на <em>пустые</em> образцы, то есть образцы, которым соответствует пустая строка. Например, если вы попробуете найти имена при помощи образца наподобие '<code>%а*</code>', то вы везде будете находить их повсюду:</p>
<pre><code>i, j = string.find(&quot;;$% **#$hello13&quot;, &quot;%a*&quot;)
print(i,j)    --&gt; 1    0</code></pre>
<p>В этом примере вызов <code>string.find</code> правильно находит пустую последовательность букв в начале строки.</p>
<p>Всегда бессмысленно писать образец, который начинается или заканчивается модификатором '<code>-</code>', поскольку ему будет удовлетворять лишь пустая строка. Этому модификатору обычно требуется что-то вокруг него, чтобы уменьшить область его соответствия. Образцы, включающие в себя '<code>.*</code>', тоже довольно коварны, поскольку эта конструкция может вобрать больше символов, чем вы планировали.</p>
<p>Иногда удобнее использовать сам Lua для построения образцов. Мы уже пользовались данным приемом в нашей функции для преобразования пробелов в символы табуляции. В качестве другого примера давайте рассмотрим, как мы можем найти строки текста длиной, скажем, от 70 символов. Точнее длинной строкой будет последовательность из 70 или более символов, отличных от перевода строки. Мы можем найти соответствие одиночному символу, не являющемуся переводом строки, при помощи класса символов '<code>[^\n]</code>'. Таким образом, мы можем найти соответствие длинной строке посредством образца, который 70 раз повторяет образец для одиночного символа, и после которого может следовать 0 или более этих символов. Вместо написания данного образца вручную, мы можем создать его при помощи <code>string.rep</code>:</p>
<pre><code>pattern = string.rep(&quot;[^\n]&quot;, 70) .. &quot;[^\n]*&quot;</code></pre>
<p>В качестве другого примера предположим, что вы хотите сделать поиск без учета регистра. Как вариант можно заменить каждую букву <em>х</em> в образце на класс '<code>[</code><em>хХ</em><code>]</code>', то есть класс, включающий в себя и строчную, и прописную версии буквы. Мы можем автоматизировать это преобразование при помощи функции:</p>
<pre><code>function nocase (s)
  s = string.gsub(s, &quot;%a&quot;, function (c)
      return &quot;[&quot; .. string.lower(c) .. string.upper(c) .. &quot;]&quot;
    end)
  return s
end

print(nocase(&quot;Hi there!&quot;))    --&gt; [hH][iI] [tT][hH][eE][rR][eE]!</code></pre>
<p>Иногда вам требуется заменить каждое вхождение <code>s1</code> на <code>s2</code>, без учета всяких магических символов. Если обе строки являются литералами, то при их написании вы можете сами добавить все необходимые экраны для магических символов. Но если эти строки являются значениями переменных, то вы можете использовать еще один <code>gsub</code> для вставки экранов за вас:</p>
<pre><code>s1 = string.gsub(s1, &quot;(%W)&quot;, &quot;%%%1&quot;)
s2 = string.gsub(s2, &quot;%%&quot;, &quot;%%%%&quot;)</code></pre>
<p>В строке поиска мы экранируем все небуквенно-цифровые символы (то есть заглавную &quot;<code>W</code>&quot;). В замещающей строке мы экранируем лишь '<code>%</code>'.</p>
<p>Еще одним полезным приемом при сопоставлении с образцом является обработка заданной строки перед основной работой. Предположим, мы хотим перевести в прописные буквы из всех строк внутри кавычек в каком-либо тексте, где строка в кавычках начинается и заканчивается двойными кавычками ('<code>&quot;</code>'), но при этом может содержать экранированные кавычки '<code>\&quot;</code>':</p>
<pre><code>follows a typical string: &quot;This is \&quot;great\&quot;!&quot;.</code></pre>
<p>Одним из решений в подобных случаях является предварительная обработка текста таким образом, чтобы закодировать проблематичную последоватльность во что-то еще. Например, мы могли бы закодировать &quot;<code>\&quot;</code>&quot; как &quot;<code>\1</code>&quot;. Тем не менее, если в исходном тексте уже содержался символ &quot;<code>\1</code>&quot;, то мы в беде. Простым способом выполнить кодирование и избежать данной проблемы является преобразование всех последовательностей &quot; <code>\</code><em>х</em>&quot; в &quot; <code>\</code><em>ddd</em>&quot;, где <em>ddd</em> — это десятичное представление символа <em>х</em>:</p>
<pre><code>function code (s)
  return (string.gsub(s, &quot;\\(.)&quot;, function (x)
      return string.format(&quot;\\%03d&quot;, string.byte(x))
    end))
end</code></pre>
<p>Теперь любая последовательность &quot;<code>\</code><em>ddd</em>&quot; всегда будет результатом кодирования, поскольку любая &quot;<code>\</code><em>ddd</em>&quot; в исходной строке тоже кодируется. Поэтому декодирование является простой задачей:</p>
<pre><code>function decode (s)
  return (string.gsub(s, &quot;\\(%d%d%d)&quot;, function (d)
      return &quot;\\&quot; .. string.char(tonumber(d))
    end))
end</code></pre>
<p>Теперь мы можем завершить нашу задачу. Так как закодированная строка не содержит никаких экранированных кавычек (&quot;<code>\&quot;</code>&quot;), то мы запросто можем найти строки в кавычках при помощи '<code>&quot;.-&quot;</code>':</p>
<pre><code>s = [[follows a typical string: &quot;This is \&quot;great\&quot;!&quot;.]]
s = code(s)
s = string.gsub(s, &#39;&quot;.-&quot;&#39;, string.upper)
s = decode(s)
print(s)    --&gt; follows a typical string: &quot;THIS IS \&quot;GREAT\&quot;!&quot;.</code></pre>
<p>Или в более компактной записи:</p>
<pre><code>print(decode(string.gsub(code(s), &#39;&quot;.-&quot;&#39;, string.upper)))</code></pre>
<h3 id="Chapter21.xhtml#sigil_toc_id_164">21.7. Юникод</h3>
<p>На данный момент строковая библиотека не предлагает явной поддержки Юникода. Однако, выполнять некоторые полезные и простые преобразования строк Юникода в кодировке UTF-8 можно и без дополнительных библиотек.</p>
<p>UTF-8 — это основная кодировка для Юникода в Интернете. Из-за ее совместимости с ASCII эта кодировка идеально подходит для Lua. Этой совместимости достаточно, чтобы обеспечить работу с UTF-8 ряда технологий для обработки строк ASCII без внесения изменений.</p>
<p>UTF-8 представляет каждый символ Юникода различным числом байт. Например, символ '<code>А</code>' он представляет одним байтом равным 65; буква алеф из иврита, у которой в Юникоде код 1488, представлена двухбайтовой последовательностью 215-144. UTF-8 представляет все символы из ASCII как ASCII, то есть одним байтом со значением, меньшим 128. <span style="text-indent: 1.5em;">Все остальные символы представлены последовательностями байт, где первый байт лежит в диапазоне [194, 244], а последующие байты лежат в диапазоне [128, 191]. Точнее, диапазон первого байта для двухбайтовых последовательностей — [194, 223], для трехбайтовых последовательностей — [224, 239] а для четырехбайтовых последовательностей — [240, 244]. Эта конструкция следит за тем, чтобы кодовая последовательность одного символа никогда не встретилась внутри кодовой последовательности другого. Например, байт меньше 128 никогда не встретится в многобайтовой последовательности; он всегда представлен своим ASCII-символом.</span></p>
<p>Так как Lua не использует нуль-символы, он может читать, записывать и хранить строки UTF-8 как любые обычные строки. Строковые литералы тоже могут содержать внутри себя данные в UTF-8. (Разумеется, вы можете редактировать исходный код как файл в UTF-8, если захотите.) Операция конкатенации корректно работает для всех строк в UTF-8. Операции сравнения строк (меньше, чем; меньше или равно и т. п.) сравнивают строки в UTF-8, следуя порядку символов в Юникоде.</p>
<p>Библиотека операционной системы и библиотека ввода-вывода по сути являются интерфейсами к системе, на которой они выполняются, поэтому их поддержка строк в UTF-8 зависит от этой системы. В Linux, например, мы можем использовать UTF-8 для имен файлов, но Windows использует UTF-16. Поэтому для работы с именами файлов в Юникоде в Windows понадобятся либо дополнительные библиотеки, либо внесение изменений в стандартные библиотеки Lua.</p>
<p>Теперь давайте посмотрим, как функции из строковой библиотеки работают со строками в UTF-8.</p>
<p>Функции <code>string.reverse</code>, <code>string.byte</code>, <code>string.char</code>, <code>string.upper</code> и <code>string.lower</code> не работают со строками в UTF-8, поскольку все они полагают, что размер одного символа равен одному байту.</p>
<p>Функции <code>string.format</code> и <code>string.rep</code> работают со строками в UTF-8 без проблем, за исключением опции форматирования '<code>%с</code>', которая считает, что один символ — это один байт. Функции <code>string.len</code> и <code>string.sub</code> корректно работают со строками в UTF-8, но при этом индексы указывают на количество байт (а не символов). Чаще всего это именно то, что вам нужно. Но, как мы скоро увидим, мы также можем посчитать и количество символов.</p>
<p>Для функций сопоставления с образцами их применимость к строкам в UTF-8 зависит от образца. Простые образцы работают без каких-либо проблем в связи с ключевым свойством UTF-8 — код одного символа никогда не может находиться внутри кода другого. Классы и множества символов работают лишь для ASCII-символов. Например, образец '<code>%s</code>' работает для строк в UTF-8, но он будет соответствовать только пробелам ASCII и не будет соответствовать дополнительным пробельным символам в Юникоде, таким как неразрывный пробел (U+00A0), разделитель параграфов (U+2029) или монгольский разделитель гласных (U+180Е).</p>
<p>Некоторые образцы могут удачно использовать особенности UTF-8. Например, если вы хотите посчитать число символов в строке, то вы можете использовать следующее выражение:</p>
<pre><code>#(string.gsub(s, &quot;[\128-\191]&quot;, &quot;&quot;))</code></pre>
<p>Этот <code>gsub</code> убирает продолжающие байты из строки, чтобы остались лишь однобайтовые последовательности и начальные байты многострочных последовательностей: один байт на каждый символ.</p>
<p>Взяв за основу похожие идеи, следующий пример показывает, как можно перебрать все символы в строке в UTF-8:</p>
<pre><code>for c in string.gmatch(s, &quot;.[\128-\191]*&quot;) do
  print(c)
end</code></pre>
<p>Листинг 21.1 иллюстрирует некоторые приемы для работы с UTF-8 строками в Lua. Разумеется, для выполнения этих примеров вам нужна платформа, в которой <code>print</code> поддерживает UTF-8.</p>
<p>К сожалению, больше Lua предложить нечего. Полноценная поддержка Юникода требует огромных таблиц, которые плохо соотносятся с маленьким размером Lua. У Юникода слишком много особенностей. Практически невозможно абстрагировать какое-либо понятие из конкретных языков. Размыто даже понятие того, что является символом, поскольку нет взаимно-однозначного соответствия между закодированными в Юникоде символами и графемами (то есть символами с диакритическими знаками и «полностью игнорируемыми» символами). Другие, казалось бы, фундаментальные понятия, например, того, что является буквой, также разнятся среди языков.</p>
<p>Чего, на мой взгляд, не хватает в Lua, так это функций преобразования последовательностей UTF-8 и комбинаций Юникода между собой и функций для проверки правильности строк в UTF-8. Возможно, они войдут в следующую версию Lua. Для тех, кому нужна поддержка Юникода, похоже лучшим вариантом будет использование внешней библиотеки вроде <code>slnunicode</code>.</p>
<p><strong>Листинг 21.1.</strong> Примеры базовых операций над UTF-8 в Lua</p>
<pre><code>local a = {}
a[#a + 1] = &quot;Nähdään&quot;
a[#a + 1] = &quot;ação&quot;
a[#a + 1] = &quot;ÃøÆËÐ&quot;

local l = table.concat(a, &quot;;&quot;)

print(l, #(string.gsub(l, &quot;[\128-\191]&quot;, &quot;&quot;)))
  --&gt; Nähdään;ação;ÃøÆËÐ 18

for w in string.gmatch(l, &quot;[^;]+&quot;) do
  print(w)
end
  --&gt; Nähdään
  --&gt; ação
  --&gt; ÃøÆËÐ

for c in string.gmatch(a[3], &quot;.[\128-\191]*&quot;) do
  print(c)
end

  --&gt; Ã
  --&gt; ø
  --&gt; Æ
  --&gt; Ë
  --&gt; Ð</code></pre>
<h3 id="Chapter21.xhtml#sigil_toc_id_165">Упражнения</h3>
<p><strong>Упражнение 21.1.</strong> Напишите функцию <code>split</code>, которая получает строку и образец разделителя и возвращает последовательность из частей исходной строки между разделителями:</p>
<pre><code>t = split(&quot;a whole new world&quot;, &quot; &quot;)
-- t = {&quot;a&quot;, &quot;whole&quot;, &quot;new&quot;, &quot;world&quot;}</code></pre>
<p>Как ваша функция обрабатывает пустые строки? (В частности, является ли пустая строка пустой последовательностью или последовательностью с одной пустой строкой?)</p>
<p><strong>Упражнение 21.2.</strong> Образцы '<code>%D</code>' и '<code>[A%d]</code>' эквивалентны. А что насчет образцов '<code>[^%d%u]</code>' и '<code>[%D%U]</code>'?</p>
<p><strong>Упражнение 21.3.</strong> Напишите функцию транслитерации. Эта функция получает строку и заменяет каждый символ в этой строке другим символом в соответствии с таблицей, заданной в качестве второго аргумента. Если таблица отображает '<code>а</code>' в '<code>b</code>', то функция должна заменить каждое вхождение '<code>а</code>' на '<code>b</code>'. Если таблица отображает '<code>а</code>' в false, то функция должна удалить все вхождения символа '<code>а</code>' из строки.</p>
<p><strong>Упражнение 21.4.</strong> Напишите функцию, которая переворачивает строку в UTF-8.</p>
<p><strong>Упражнение 21.5.</strong> Напишите функцию транслитерации для символов UTF-8.</p>
<p><span id="Chapter22.xhtml"></span></p>
<h2>ГЛАВА 22</h2>
<h2 id="Chapter22.xhtml#sigil_toc_id_166">Библиотека ввода-вывода</h2>
<p>Библиотека ввода-вывода предлагает две различные модели для работы с файлами. В простой модели используется <em>текущий входной файл</em> <strong>(current input file)</strong> и <em>текущий выходной файл</em> <strong>(current output file)</strong>, и она производит над ними операции ввода-вывода. Полная модель использует явные дескрипторы файлов; она опирается на объектно-ориентированный подход, который определяет все операции как методы над дескрипторами файлов.</p>
<p>Простая модель удобна для простых вещей; мы применяли ее на протяжении всей книги. Но ее недостаточно для более гибкой работы с файлами, например для одновременного чтения или записи в несколько файлов. Для такой обработки нам нужна полная модель.</p>
<h3 id="Chapter22.xhtml#sigil_toc_id_167">22.1. Простая модель ввода-вывода</h3>
<p>Простая модель выполняет все свои операции над двумя текущими файлами. Библиотека инициализирует текущий входной файл как обрабатываемый стандартный ввод (<code>stdin</code>), а текущий выходной файл как обрабатываемый стандартный вывод (<code>stdout</code>). Таким образом, когда мы выполняем что-то вроде <code>io.read()</code>, мы читаем строку из стандартного ввода.</p>
<p>Мы можем изменить эти текущие файлы при помощи функций <code>io.input</code> и <code>io.output</code>. Вызов наподобие <code>io.input(filename)</code> открывает заданный файл в режиме чтения и устанавливает его как текущий входной файл. Начиная с этого момента, весь ввод будет поступать из этого файла, пока не произойдет другой вызов <code>io.input</code>; функция <code>io.output</code> делает то же самое, но для вывода. В случае ошибки обе функции ее вызывают. Если вы хотите обрабатывать ошибки напрямую, то вы должны использовать полную модель.</p>
<p>Функция <code>write</code> проще, чем <code>read</code>, поэтому мы сперва рассмотрим ее. Функция <code>io.write</code> получает произвольное число строковых аргументов и записывает их в текущий выходной файл. Она преобразует числа в строки, следуя стандартным правилам преобразования; для полного контроля над этим преобразованием используйте функцию <code>string.format</code>:</p>
<pre><code>&gt; io.write(&quot;sin (3) = &quot;, math.sin(3), &quot;\n&quot;)
  --&gt; sin (3) = 0.14112000805987
&gt; io.write(string.format(&quot;sin (3) = %.4f\n&quot;, math.sin(3)))
  --&gt; sin (3) = 0.1411</code></pre>
<p>Избегайте кода вроде <code>io.write(a..b..с)</code>; вызов <code>io.write(a,b,c)</code> дает тот же эффект с меньшими затратами, поскольку при этом конкатенация не нужна.</p>
<p>Как правило, вы должны использовать <code>print</code> для программ на скорую руку или для отладки, а <code>write</code> применять тогда, когда вам нужен полный контроль над выводом:</p>
<pre><code>&gt; print(&quot;hello&quot;, &quot;Lua&quot;); print(&quot;Hi&quot;)
  --&gt; hello Lua
  --&gt; Hi

&gt; io.write(&quot;hello&quot;, &quot;Lua&quot;); io.write(&quot;Hi&quot;, &quot;\n&quot;)
  --&gt; helloLuaHi</code></pre>
<p>В отличие от <code>print</code>, функция <code>write</code> не добавляет к выводу никаких дополнительных символов вроде символов табуляции или переводов строки. Кроме того, <code>write</code> позволяет вам перенаправить ваш вывод, тогда как <code>print</code> всегда использует стандартный вывод. Наконец, <code>print</code> автоматически применяет <code>tostring</code> к своим аргументам; это удобно для отладки, но может скрывать ошибки, если вы не внимательны к выводу.</p>
<p>Функция <code>io.read</code> читает строки из текущего входного файла. Ее аргументы управляют тем, что читать:</p>
<table>
<tbody>
<tr class="odd">
<td><code>*а</code> читает весь файл<br />
<code>*l</code> читает следующую строку (без символа перевода строки)<br />
<code>*L</code> читает следующую строку (с символом перевода строки)<br />
<code>*n</code> читает число<br />
<em>число</em> ограничивает количество читаемых символов</td>
</tr>
</tbody>
</table>
<p>Вызов <code>io.read(&quot;*а&quot;)</code> читает весь текущий входной файл, начиная с текущей позиции. Если мы находимся в конце файла или файл пуст, то вызов возвращает пустую строку.</p>
<p>Поскольку Lua эффективно работает с длинными строками, простой прием написания фильтров на Lua состоит в том, чтобы прочесть весь файл в строку, выполнить обработку этой строки (обычно при помощи <code>gsub</code>) и затем записать строку в вывод:</p>
<pre><code>t = io.read(&quot;*a&quot;)          -- читает из файла
t = string.gsub(t, ...)    -- делает свою работу
io.write(t)                -- пишет в файл</code></pre>
<p>В качестве примера следующий кусок является законченной программой для кодирования содержимого файла в MIME-кодировке <em>quoted-printable</em>. Каждый не ASCII-байт кодируется как <code>=</code><em>хх</em>, где <em>хх</em> — это шестнадцатеричное значение байта. Для целостности кодирования символ '<code>=</code>' также должен быть закодирован:</p>
<pre><code>t = io.read(&quot;*a&quot;)
t = string.gsub(t, &quot;([\128-\255=])&quot;, function (c)
      return string.format(&quot;=%02X&quot;, string.byte(c))
    end)
io.write(t)</code></pre>
<p>Этот образец, использованный в <code>gsub</code>, захватывает все байты от 128 до 255, а также знак равенства.</p>
<p>Вызов <code>io.read (&quot;*l&quot;)</code> возвращает следующую строку из текущего входного файла без символа перевода строки; вызов <code>io.read (&quot;*L&quot;)</code> аналогичен, но он оставляет символ перевода строки (если он был в файле). Когда мы достигаем конца файла, вызов возвращает nil (так как нет следующей строки для возврата). По умолчанию в <code>read</code> используется &quot;<code>*l</code>&quot;. Обычно я использую этот образец, только когда алгоритм естественным образом обрабатывает файл строка за строкой; в противном случае я предпочитаю прочесть весь файл за раз при помощи &quot;<code>*а</code>&quot; или читать его блоками, как мы увидим позже.</p>
<p>В качестве простого примера использования этого образца следующая программа копирует текущий ввод в текущий вывод, нумеруя при этом каждую строку:</p>
<pre><code>for count = 1, math.huge do
  local line = io.read()
  if line == nil then break end
  io.write(string.format(&quot;%6d &quot;, count), line, &quot;\n&quot;)
end</code></pre>
<p>Однако, чтобы построчно перебрать весь файл, лучше использовать итератор <code>io.lines</code>. Например, мы можем написать законченную программу для сортировки строк файла следующим образом:</p>
<pre><code>local lines = {}
-- считывает строки в таблицу &#39;lines&#39;
for line in io.lines() do lines[#lines + 1] = line end
-- сортирует
table.sort(lines)
-- записывает все строки
for _, l in ipairs(lines) do io.write(l, &quot;\n&quot;) end</code></pre>
<p>Вызов <code>io.read(&quot;*n&quot;)</code> читает число из текущего входного файла. Это единственный случай, когда функция <code>read</code> возвращает число, а не строку. Когда программе нужно прочесть слишком много чисел из файла, отсутствие промежуточных строк улучшает ее быстродействие. Опция <code>*n</code> пропускает все пробелы перед числом и поддерживает такие числовые форматы, как -3, +5.2,1000 и -3.4е-23. Если функция не может найти число в текущей позиции (из-за неверного формата или конца файла), то она возвращает nil.</p>
<p>Вы можете вызвать <code>read</code> с несколькими опциями; для каждого аргумента функция вернет соответствующее значение. Допустим, у вас есть файл, содержащий по три числа на каждую строку:</p>
<pre><code>6.0 -3.23 15e12
4.3 234 1000001
...</code></pre>
<p>Теперь вы хотите напечатать максимальное число каждой строки. Вы можете прочесть все три числа за один вызов <code>read</code>:</p>
<pre><code>while true do
  local n1, n2, n3 = io.read(&quot;*n&quot;, &quot;*n&quot;, &quot;*n&quot;)
  if not n1 then break end
  print(math.max(n1, n2, n3))
end</code></pre>
<p>Кроме основных образцов для чтения, вы можете вызвать <code>read</code> с аргументом в виде числа <em>n</em>: в этом случае <code>read</code> пытается прочесть <em>n</em> символов из входного файла. Если она не может прочесть ни одного символа (конец файла), то она возвращает nil; в противном случае возвращается строка с не более чем <em>n</em> символами. В качестве примера данного образца для чтения следующая программа показывает эффективный способ (для Lua, конечно) скопировать файл из <code>stdin</code> в <code>stdout</code>:</p>
<pre><code>while true do
  local block = io.read(2^13)    -- размер буфера равен 8K
  if not block then break end
  io.write(block)
end</code></pre>
<p>Как особый случай, <code>io.read(0)</code> работает как проверка конца файла: она возвращает либо пустую строку, если еще есть, что читать, либо nil, если читать нечего.</p>
<h3 id="Chapter22.xhtml#sigil_toc_id_168">22.2. Полная модель ввода-вывода</h3>
<p>Для большего контроля над вводом-выводом вы можете использовать полную модель. Данная модель основана на понятии <em>дескриптора файла</em> <strong>(file handle)</strong>, который аналогичен потокам (<code>FILE*</code>) в С: он представляет собой открытый файл с текущей позицией.</p>
<p>Чтобы открыть файл, вы используете функцию <code>io.open</code>, которая подобна функции <code>fopen</code> в С. В качестве аргументов она принимает имя файла, который нужно открыть, и <em>строку режима</em> <strong>(mode string)</strong>. Эта строка может содержать '<code>r</code>' для чтения, '<code>w</code>' для записи (которая при этом стирает любое предыдущее содержимое файла) или '<code>a</code>' для добавления к файлу; еще она может содержать необязательный '<code>b</code>' для открытия двоичных файлов. Функция <code>open</code> возвращает новый дескриптор файла. В случае ошибки <code>open</code> возвращает nil, а также сообщение об ошибке и ее код:</p>
<pre><code>print(io.open(&quot;non-existent-file&quot;, &quot;r&quot;))
  --&gt; nil non-existent-file: No such file or directory 2

print(io.open(&quot;/etc/passwd&quot;, &quot;w&quot;))
  --&gt; nil /etc/passwd: Permission denied 13</code></pre>
<p>Интерпретация кодов ошибок зависит от системы.</p>
<p>Типичная идиома для проверки на ошибки:</p>
<pre><code>local f = assert(io.open(filename, mode))</code></pre>
<p>Если <code>open</code> даст сбой, то сообщение об ошибке переходит вторым аргументом в <code>assert</code>, которая затем показывает это сообщение.</p>
<p>После открытия файла вы может читать из него и писать в него при помощи методов <code>read</code> и <code>write</code>. Они аналогичны функциям <code>read</code> и <code>write</code>, но вы вызываете их как методы дескриптора файла, используя двоеточие. Например, чтобы открыть файл и прочесть все из него, вы можете использовать кусок вроде этого:</p>
<pre><code>local f = assert(io.open(filename, &quot;r&quot;))
local t = f:read(&quot;*a&quot;)
f:close()</code></pre>
<p>Библиотека ввода-вывода предлагает дескрипторы для трех предопределенных потоков С: <code>io.stdin</code>, <code>io.stdout</code> и <code>io.stderr</code>. Поэтому вы можете послать сообщение прямо в поток с ошибкой при помощи примерно такого кода:</p>
<pre><code>io.stderr:write(message)</code></pre>
<p>Мы можем смешивать полную модель с простой. Мы получаем дескриптор текущего входного файла посредством вызова <code>io.input()</code> без аргументов. Мы устанавливаем этот дескриптор путем вызова <code>io.input(hanle)</code> (аналогичные вызовы работают и для <code>io.output</code>). Например, если вы хотите временно изменить текущий входной файл, то вы можете написать что-то вроде этого:</p>
<pre><code>local temp = io.input()    -- сохраняет текущий файл
io.input(&quot;newinput&quot;)       -- открывает новый текущий файл
&lt;делает что-нибудь с новым вводом&gt;
io.input():close()         -- закрывает текущий файл
io.input(temp)             -- восстанавливает предыдущий текущий файл</code></pre>
<p>Вместо <code>io.read</code> для чтения из файла мы также можем использовать <code>io.lines</code>. Как мы уже видели в предыдущих примерах, <code>iо.lines</code> возвращает итератор, последовательно читающий из файла.</p>
<p>Первым аргументом <code>io.lines</code> может быть имя файла или дескриптор файла. Если передано имя файла, то <code>io.lines</code> откроет файл в режиме для чтения и закроет файл после достижения конца файла. Если передан дескриптор файла, то <code>io.lines</code> будет использовать данный файл для чтения; в этом случае <code>io.lines</code> не будет закрывать файл по достижении его конца. В случае вызова вообще без аргументов <code>io.lines</code> будет читать данные из текущего входного файла.</p>
<p>Начиная с Lua 5.2, <code>io.lines</code> принимает и те опции, которые принимает <code>io.read</code> после файлового аргумента. В качестве примера следующий код копирует файл в текущий вывод, используя <code>io.lines</code>:</p>
<pre><code>for block in io.lines(filename, 2^13) do
  io.write(block)
end</code></pre>
<h4 id="Chapter22.xhtml#sigil_toc_id_169">Небольшой прием для увеличения быстродействия</h4>
<p>Обычно в Lua быстрее прочесть файл целиком, чем читать его строка за строкой. Однако, иногда мы сталкиваемся с большим файлом (например, десятки или даже сотни мегабайт), читать который целиком было бы нецелесообразно. Если вы хотите получить максимальное быстродействие при работе с такими большими файлами, то быстрее всего будет читать его достаточно большими кусками (например, по 8К). Во избежание возможного разрыва строки, можно просто попросить прочесть еще одну строку:</p>
<pre><code>local lines, rest = f:read(BUFSIZE, &quot;*l&quot;)</code></pre>
<p>Переменная <code>rest</code> получит остаток любой строки, разбитой при чтении куска. Затем мы объединяем кусок и полученный остаток. Таким образом кусок всегда будет завершаться на границе строк.</p>
<p>Пример из листинга 22.1 использует этот прием для реализации <code>wc</code>, программы, которая считает число символов, слов и строк в файле. Обратите внимание на использование <code>io.lines</code> для осуществления итераций и опции &quot;<code>*b</code>&quot; для чтения строки — это доступно, начиная с Lua 5.2.</p>
<p><strong>Листинг 22.1.</strong> Программа <span class="code">wc</span></p>
<pre><code>local BUFSIZE = 2^13          -- 8K
local f = io.input(arg[1])    -- открывает входной файл
local cc, lc, wc = 0, 0, 0    -- счетчики символов, строк и слов
for lines, rest in io.lines(arg[1], BUFSIZE, &quot;*L&quot;) do
  if rest then lines = lines .. rest end
  cc = cc + #lines
  -- подсчитывает слова в куске
  local _, t = string.gsub(lines, &quot;%S+&quot;, &quot;&quot;)
  wc = wc + t
  -- подсчитывает переводы строки в куске
  _,t = string.gsub(lines, &quot;\n&quot;, &quot;\n&quot;)
  lc = lc + t
end
print(lc, wc, cc)</code></pre>
<h4 id="Chapter22.xhtml#sigil_toc_id_170">Бинарные файлы</h4>
<p>Функции <code>io.input</code> и <code>io.output</code> из простой модели всегда по умолчанию открывают файл в текстовом режиме. В UNIX нет никакой разницы между бинарными и текстовыми файлами. Но в некоторых системах, в частности в Windows, бинарные файлы нужно открывать со специальным флагом. Для обработки таких бинарных файлов вы должны использовать <code>io.open</code> с символом '<code>b</code>' в строке режима.</p>
<p>Lua работает с бинарными данными так же, как и с текстом. Строка в Lua может содержать любые байты, и почти все функции в библиотеках могут обрабатывать любые байты. Вы даже можете применять сопоставление с образцом к бинарным данным до тех пор, пока образец не содержит нулевого байта. Если вам нужно сопоставление с этим байтом, то вы можете воспользоваться для этого классом <code>%z</code>.</p>
<p>Обычно бинарные данные читают либо при помощи образца <code>*а</code>, который читает весь файл, либо при помощи образца <em>n</em>, который читает <em>n</em> байт. В качестве простого примера следующая программа переводит текст из формата Windows в формат UNIX (то есть заменяет последовательность символов перевода каретки и перевода строки на символ перевода строки). Она не пользуется стандартными файлами ввода-вывода (<code>stdin-stdout</code>), поскольку они открыты в текстовом режиме. Вместо этого она полагает, что имена входного и выходного файлов переданы программе как аргументы:</p>
<pre><code>local inp = assert(io.open(arg[1], &quot;rb&quot;))
local out = assert(io.open(arg[2], &quot;wb&quot;))

local data = inp:read(&quot;*a&quot;)
data = string.gsub(data, &quot;\r\n&quot;, &quot;\n&quot;)
out:write(data)

assert(out:close())</code></pre>
<p>Вы можете вызвать эту программу при помощи следующей командной строки:</p>
<pre><code>&gt; lua prog.lua file.dos file.unix</code></pre>
<p>В качестве еще одного примера следующая программа печатает все строки, найденные в бинарном файле:</p>
<pre><code>local f = assert(io.open(arg[1], &quot;rb&quot;))
local data = f:read(&quot;*a&quot;)
local validchars = &quot;[%g%s]&quot;
local pattern = &quot;(&quot; .. string.rep(validchars, 6) .. &quot;+)\0&quot;
for w in string.gmatch(data, pattern) do
  print(w)
end</code></pre>
<p>Программа считает, что строка — это завершенная нулем последовательность не менее чем из шести допустимых символов, где допустимым является любой символ, который соответствует образцу <code>validchars</code>. В нашем примере этот образец состоит из печатаемых символов. Мы используем <code>string.rep</code> и конкатенацию для создания образца, которому удовлетворяют последовательности из шести и более допустимых символов, за которыми следует нулевой байт. Круглые скобки в образце захватывают эту строку (без нулевого байта).</p>
<p>В качестве последнего примера следующая программа делает дамп бинарного файла:</p>
<pre><code>local f = assert(io.open(arg[1], &quot;rb&quot;))
local block = 16
for bytes in f:lines(block) do
  for c in string.gmatch(bytes, &quot;.&quot;) do
    io.write(string.format(&quot;%02X &quot;, string.byte(c)))
  end
  io.write(string.rep(&quot; &quot;, block - string.len(bytes)))
  io.write(&quot; &quot;, string.gsub(bytes, &quot;%c&quot;, &quot;.&quot;), &quot;\n&quot;)
end</code></pre>
<p><strong>Листинг 22.2.</strong> Получение дампа посредством программы <span style="color: rgb(165, 42, 42); font-family: &#39;Liberation Mono&#39;, &#39;Courier New&#39;, courier, monospace; font-size: medium; font-weight: 900;">dump</span></p>
<pre><code>6C 6F 63 61 6C 20 66 20 3D 20 61 73 73 65 72 74  local f = assert
28 69 6F 2E 6F 70 65 6E 28 61 72 67 5B 31 5D 2C  (io.open(arg[1],
20 22 72 62 22 29 29 0A 6C 6F 63 61 6C 20 62 6C  &quot;rb&quot;)).local bl
6F 63 6B 20 3D 20 31 36 0A 66 6F 72 20 62 79 74  ock = 16.for byt
65 73 20 69 6E 20 66 3A 6C 69 6E 65 73 28 62 6C  es in f:lines(bl
...
20 22 2C 20 73 74 72 69 6E 67 2E 67 73 75 62 28  &quot;, string.gsub(
62 79 74 65 73 2C 20 22 25 63 22 2C 20 22 2E 22  bytes, &quot;%c&quot;, &quot;.&quot;
29 2C 20 22 5C 6E 22 29 0A 65 6E 64 0A 0A        ), &quot;\n&quot;).end..</code></pre>
<p>Как и раньше, первым аргументом программы является имя входного файла; выходной файл идет на стандартный вывод. Программа читает файл кусками по 16 байт. Для каждого куска выводится шестнадцатеричное представление каждого байта, а затем кусок записывается как текст, заменяя управляющие символы точками.</p>
<p>Листинг 22.2 показывает результат применения этой программы самой к себе (на UNIX-машине).</p>
<h3 id="Chapter22.xhtml#sigil_toc_id_171">22.3. Прочие операции над файлами</h3>
<p>Функция <code>tmpfile</code> возвращает дескриптор временного файла, открытого в режиме чтения-записи. Этот файл будет автоматически удален по завершении программы.</p>
<p>Функция <code>flush</code> применяет к файлу все отложенные операции записи. Подобно <code>write</code>, вы можете вызвать ее либо как функцию <code>io.flush()</code> для сброса текущего выходного файла на диск, либо как метод <code>f:flush()</code> для сброса конкретного файла <code>f</code>.</p>
<p>Метод <code>setvbuf</code> устанавливает режим буферизации потока. Его первым аргументом является строка: &quot;<code>no</code>&quot; означает отсутствие буферизации; &quot;<code>full</code>&quot; означает, что поток записывается лишь тогда, когда буфер заполнен или вы явно сбрасываете файл; &quot;<code>line</code>&quot; означает, что вывод буферизуется до перевода строки или при вводе из некоторых особых файлов (например, из терминала). Для последних двух опций <code>setvbuf</code> допускает необязательный второй аргумент, задающий размер буфера.</p>
<p>В большинстве систем стандартный поток ошибок (<code>io.stderr</code>) не буферизуется, в то время как стандартный выходной поток (<code>io.stdout</code>) буферизуется в построчном режиме. Поэтому если вы записываете незавершенные строки в стандартный вывод (например, индикатор состояния операции), то, чтобы увидеть вывод, вам может понадобиться сброс содержимого буфера.</p>
<p>Метод <code>seek</code> может как возвращать, так и устанавливать текущую позицию внутри файла. Его общей формой является <code>f:seek(</code><em>место</em>,<em>смещение</em><code>)</code>, где <em>место</em> — это строка, задающая, как надо интерпретировать <em>смещение</em>. Ее допустимыми значениями являются &quot;<code>set</code>&quot;, когда смещение трактуется от начала файла, &quot;<code>cur</code>&quot;, когда смещение трактуется от текущей позиции внутри файла, и &quot;<code>end</code>&quot;, когда смещение трактуется с конца файла. Независимо от значения места вызов возвращает новую текущую позицию, измеренную в байтах от начала этого файла.</p>
<p>Значениями по умолчанию являются &quot;<code>cur</code>&quot; для места и <code>0</code> для смещения. Поэтому вызов <code>file:seek()</code> возвращает текущее положение внутри файла, не меняя его; вызов <code>file:seek(&quot;set&quot;)</code> возвращает позицию в начало файла (и возвращает ноль); а вызов <code>file:seek(&quot;end&quot;)</code> устанавливает позицию на конец файла и возвращает его размер. Следующая функция получает размер файла, не меняя текущую позицию внутри него:</p>
<pre><code>function fsize (file)
  local current = file:seek()      -- получает текущую позицию
  local size = file:seek(&quot;end&quot;)    -- получает размер файла
  file:seek(&quot;set&quot;, current)        -- восстанавливает позицию
  return size
end</code></pre>
<p>В случае ошибки все эти функции возвращают nil и сообщение об ошибке.</p>
<h3 id="Chapter22.xhtml#sigil_toc_id_172">Упражнения</h3>
<p><strong>Упражнение 22.1.</strong> Напишите программу, которая читает текстовый файл и перезаписывает его, используя его же строки, отсортированные в алфавитном порядке. При вызове без аргументов она должна читать из стандартного входного файла и записывать в стандартный выходной файл. При вызове с одним аргументом в виде имени файла, она должна читать из этого файла и записывать в стандартный выходной файл. При вызове с двумя аргументами в виде имен файлов она должна читать из первого файла и писать во второй.</p>
<p><strong>Упражнение 22.2.</strong> Измените предыдущую программу так, чтобы она запрашивала подтверждение, если пользователь задает имя существующего файла для ее вывода.</p>
<p><strong>Упражнение 22.3.</strong> Сравните быстродействие программы на Lua, которая копирует стандартный входной файл в стандартный выходной файл следующими способами:</p>
<ul>
<li>побайтно;</li>
<li>построчно;</li>
<li>кусками по 8К;</li>
<li>весь файл за раз.</li>
</ul>
<p>Насколько большим может быть входной файл для последнего варианта?</p>
<p><strong>Упражнение 22.4.</strong> Напишите программу, которая печатает последнюю строку текстового файла. Постарайтесь избежать чтения всего файла, когда файл большой и к нему можно применить <code>seek</code>.</p>
<p><strong>Упражнение 22.5.</strong> Обобщите предыдущую программу так, чтобы она печатала последние <em>n</em> строк текстового файла. Опять же постарайтесь избежать чтения всего файла, когда он большой и к нему можно применить <code>seek</code>.</p>
<p><span id="Chapter23.xhtml"></span></p>
<h2>ГЛАВА 23</h2>
<h2 id="Chapter23.xhtml#sigil_toc_id_173">Библиотека операционной системы</h2>
<p>Библиотека операционной системы включает в себя функции для работы с файлами (не с потоками), получения текущих даты и времени и другие средства, касающиеся операционной системы. Она определена в таблице <code>os</code>. Переносимость Lua сказалась на этой библиотеке: поскольку Lua написана на чистом ANSI С, то эта библиотека включает в себя только функциональность предоставляемую стандартом ANSI. Многие средства ОС, такие как работа с директориями и сокетами, не входят в этот стандарт, и поэтому данная библиотека их не предоставляет. Существуют другие библиотеки Lua, не включенные в основную поставку, которые обеспечивают расширенный доступ к ОС. Примеры таких библиотек: <code>posix</code>, предоставляющая для Lua всю функциональность стандарта POSIX.1, <code>luasocket</code> для работы с сетью и <code>LuaFileSystem</code> для работы с директориями и атрибутами файлов.</p>
<p>Все, что предлагает данная библиотека для работы с файлами, — это функции <code>os.rename</code> для изменения имени файла и <code>os.remove</code> для удаления файла.</p>
<h3 id="Chapter23.xhtml#sigil_toc_id_174">23.1. Дата и время</h3>
<p>Вся функциональность для работы с датами и временем в Lua обеспечивается двумя функциями — <code>time</code> и <code>date</code>.</p>
<p>Функция <code>time</code>, когда она вызвана без аргументов, возвращает текущую дату и время, представленные как число. (В большинстве систем это число секунд, прошедших с определенного начала отсчета.) При вызове с аргументом в виде таблицы, она возвращает число, которое представляет дату и время, описанное этой таблицей. У таких <em>дата-таблиц</em> <strong>(date tables)</strong> есть следующие значимые поля:</p>
<table>
<tbody>
<tr class="odd">
<td><code>year</code> полный год<br />
<code>month</code> 01—12 (месяц)<br />
<code>day</code> 01—31 (день)<br />
<code>hour</code> 00—23 (час)<br />
<code>min</code> 00—59 (минута)<br />
<code>sec</code> 00—59 (секунда)<br />
<code>isdst</code> логическое значение, true при переходе на летнее время</td>
</tr>
</tbody>
</table>
<p>Первые три поля обязательны; для остальных значением по умолчанию, когда оно не предоставлено, является полдень (12:00:00). В UNIX-системе, где началом отсчета является 00:00:00 1 января 1970 г. по универсальному координированному времени, для Рио-де-Жанейро (который на три часа западнее Гринвича) у нас будут следующие результаты:</p>
<pre><code>print(os.time{year=1970, month=1, day=1, hour=0})
  --&gt; 10800
print(os.time{year=1970, month=1, day=1, hour=0, sec=1})
  --&gt; 10801
print(os.time{year=1970, month=1, day=1})
  --&gt; 54000</code></pre>
<p>(Обратите внимание, что 10 800 — это 3 часа в секундах, 54 000 — это 10 800 плюс 12 часов в секундах.)</p>
<p>Функция <code>date</code>, несмотря на свое имя, является своего рода противоположностью функции <code>time</code>: она преобразует число, обозначающее дату и время, обратно в какое-нибудь высокоуровневое представление. Ее первый параметр — это форматирующая строка, описывающая, какое именно представление нам нужно. Второй параметр — это дата и время в виде одного числа; по умолчанию, если его не использовать, он равен текущей дате и времени.</p>
<p>Чтобы получить дата-таблицу, мы воспользуемся форматирующей строкой &quot;<code>*t</code>&quot;. Например, вызов <code>os.date(&quot;*t&quot;,906000490)</code> вернет следующую таблицу:</p>
<pre><code>{year = 1998, month = 9, day = 16, yday = 259, wday = 4,
 hour = 23, min = 48, sec = 10, isdst = false}</code></pre>
<p>Обратите внимание, что, кроме полей, используемых <code>os.time</code>, таблица, созданная <code>os.date</code>, также задает день недели (<code>wday</code>, 1 — это воскресенье) и день года (<code>yday</code>, 1 — это 1-ое января).</p>
<p>Для других форматирующих строк <code>os.date</code> форматирует дату как копию форматирующей строки, где заданные теги заменены информацией о дате и времени. Тег состоит из '<code>%</code>', за которым следует буква, как в следующих примерах:</p>
<pre><code>print(os.date(&quot;a %A in %B&quot;))       --&gt; a Tuesday in May
print(os.date(&quot;%x&quot;, 906000490))    --&gt; 09/16/1998</code></pre>
<p>Все представления соответствуют текущей локали. Например, для бразильской португальской локали результатом <code>%В</code> даст &quot;<code>setembro</code>&quot;, а <code>%х</code> даст &quot;<code>16/09/98</code>&quot;.</p>
<p>Следующая таблица показывает каждый тег, его смысл и значение для 16 сентября 1998 года, 23:48:10 (среда). Для числовых значений таблица также показывает их диапазон допустимых значений:</p>
<table>
<tbody>
<tr class="odd">
<td><code>%a</code> сокращенное название дня недели (например, Wed)<br />
<code>%A</code> полное название дня недели (например, Wednesday)<br />
<code>%b</code> сокращенное название месяца (например, Sep)<br />
<code>%B</code> полное название месяца (например, September)<br />
<code>%c</code> дата и время (например, 09/16/98 23:48:10)<br />
<code>%d</code> день месяца (16) [01–31]<br />
<code>%H</code> час, используя 24-часовое время 23) [00–23]<br />
<code>%I</code> час, используя 12-часовое время (11) [01–12]<br />
<code>%j</code> день года (259) [001–366]<br />
<code>%M</code> минута (48) [00–59]<br />
<code>%m</code> месяц (09) [01–12]<br />
<code>%p</code> либо &quot;am&quot;, либо &quot;pm&quot;<br />
<code>%S</code> секунда (10) [00–60]<br />
<code>%w</code> день недели (3) [0–6 = Sunday–Saturday]<br />
<code>%x</code> дата (например, 09/16/98)<br />
<code>%X</code> время (например, 23:48:10)<br />
<code>%y</code> сокращенный год из двух цифр (98) [00–99]<br />
<code>%Y</code> полный год (1998)<br />
<code>%%</code> символ '%'</td>
</tr>
</tbody>
</table>
<p>Если вы вызовете <code>date</code> без каких-либо аргументов, то будет использован формат <code>%с</code>, то есть полная дата и время в подходящем формате. Обратите внимание, что представления для <code>%х</code>, <code>%X</code> и <code>%с</code> зависят от локали и системы. Если вам нужно фиксированное представление, например <code>mm/dd/yyyy</code>, то используйте явную строку формата вроде &quot;<code>%m/%d/%Y</code>&quot;.</p>
<p>Функция <code>os.clock</code> возвращает число затраченных программой секунд процессорного времени. Обычно она используется для замера производительности фрагмента кода:</p>
<pre><code>local x = os.clock()
local s = 0
for i = 1, 100000 do s = s + i end
print(string.format(&quot;elapsed time: %.2f\n&quot;, os.clock() - x))</code></pre>
<h3 id="Chapter23.xhtml#sigil_toc_id_175">23.2. Прочие системные вызовы</h3>
<p>Функция <code>os.exit</code> завершает выполнение программы. Ее необязательный первый аргумент — это статус программы при выходе из нее. Он может быть числом (успешному выполнению соответствует ноль) или логическим значением (успешному выполнению соответствует true). Если необязательный второй аргумент равен true, то состояние Lua закрывается посредством вызова всех финализаторов и освобождения всей памяти, используемой этим состоянием. (Обычно эта финализация не является обязательной, так как большинство операционных систем освобождает все ресурсы, занятые процессом, при выходе из него.)</p>
<p>Функция <code>оs.getenv</code> возвращает значение переменной окружения. Она принимает имя переменной и возвращает строку с ее значением:</p>
<pre><code>print(os.getenv(&quot;HOME&quot;))    --&gt; /home/lua</code></pre>
<p>Для неопределенных переменных этот вызов возвращает nil.</p>
<p>Функция <code>os.execute</code> выполняет команду операционной системы; она эквивалентна функции <code>system</code> в С. Она принимает строку с командой и возвращает информацию о том, как эта команда была завершена. Первое возвращаемое значение логическое: true означает окончание программы без ошибок. Второе возвращаемое значение — это строка: &quot;<code>exit</code>&quot;, если программа завершилась нормально, и &quot;<code>signal</code>&quot;, если она была прервана сигналом. Третье возвращаемое значение — это статус возврата, если программа завершилась нормально, или номер сигнала, если она завершилась по сигналу. В качестве примера использования и в Windows, и в UNIX вы можете использовать следующую функцию для создания новых директорий:</p>
<pre><code>function createDir (dirname)
  os.execute(&quot;mkdir &quot; .. dirname)
end</code></pre>
<p>Функция <code>os.execute</code> обладает широкими возможностями, но при этом сильно зависит от используемой системы.</p>
<p>Функция <code>os.setlocale</code> задает текущую локаль, используемую программой Lua. Локали определяют поведение, которое зависит от культурных и языковых различий. У функции <code>os.setlocale</code> есть два строковых параметра: имя локали и категория, которая определяет, на какие характеристики эта локаль повлияет. У локалей есть шесть возможных категорий:</p>
<ul>
<li>&quot;<code>collate</code>&quot; управляет алфавитным порядком строк;</li>
<li>&quot;<code>ctype</code>&quot; управляет типами отдельных символов (например, определяет, что является буквой) и преобразованием между строчными и заглавными буквами;</li>
<li>&quot;<code>monetary</code>&quot; не влияет на программы на Lua;</li>
<li>&quot;<code>numeric</code>&quot; управляет тем, как форматируются числа;</li>
<li>&quot;<code>time</code>&quot; управляет тем, как форматируются дата и время (для функции <code>os.date</code>);</li>
<li>&quot;<code>all</code>&quot; управляет всеми перечисленными функциями.</li>
</ul>
<p>Категорией по умолчанию является &quot;<code>all</code>&quot;, то есть если вы вызвали <code>setlocale</code> только с именем локали, то она будет выставлена для всех категорий. Функция <code>setlocale</code> возвращает имя локали и nil в случае сбоя (обычно когда система не поддерживает данную локаль).</p>
<pre><code>print(os.setlocale(&quot;ISO-8859-1&quot;, &quot;collate&quot;)) --&gt; ISO-8859-1</code></pre>
<p>У категории &quot;<code>numeric</code>&quot; есть некоторые тонкости. Поскольку португальский и некоторые латинские языки используют для представления десятичных чисел запятую вместо точки, то локаль меняет способ, которым Lua печатает и считывает эти числа. Но локаль не влияет на то, как Lua разбирает числа внутри программы (одна из многих причин состоит в том, что у выражений вроде <code>print(3,4)</code> уже есть значение в Lua. Если вы пишете на Lua фрагменты кода, то здесь у вас могут быть проблемы:</p>
<pre><code>print(os.setlocale(&quot;pt_BR&quot;))    --&gt; pt_BR
s = &quot;return (&quot; .. 3.4 .. &quot;)&quot;
print(s)                        --&gt; return (3,4)
print(loadstring(s))
  --&gt; nil [string &quot;return (3,4)&quot;]:1: &#39;)&#39; expected near &#39;,&#39;</code></pre>
<p>Во избежание подобных проблем, убедитесь, что ваша программа использует стандартную локаль &quot;С&quot; при создании фрагментов кода.</p>
<h3 id="Chapter23.xhtml#sigil_toc_id_176">Упражнения</h3>
<p><strong>Упражнение 23.1.</strong> Напишите функцию, которая возвращает дату и время спустя ровно месяц от текущей даты (с применением обычного кодирования даты как числа).</p>
<p><strong>Упражнение 23.2.</strong> Напишите функцию, которая получает дату и время в виде числа и возвращает число секунд, прошедших с начала дня той даты.</p>
<p><strong>Упражнение 23.3.</strong> Можете ли вы использовать <code>os.execute</code>, чтобы изменить текущую директорию вашей программы Lua? Почему?</p>
<p><span id="Chapter24.xhtml"></span></p>
<h2>ГЛАВА 24</h2>
<h2 id="Chapter24.xhtml#sigil_toc_id_177">Отладочная библиотека</h2>
<p>Отладочная библиотека не является отладчиком, но она предложит все необходимые примитивы для написания вашего собственного отладчика для Lua. Из соображения быстродействия официальным интерфейсом к этим примитивам является C API. Отладочная библиотека в Lua — это способ получить к ним доступ напрямую из кода Lua.</p>
<p>В отличие от других библиотек, вы не должны использовать отладочную библиотеку слишком часто. Во-первых, часть ее функциональности не отличается быстродействием. Во-вторых, она нарушает некоторые непреложные истины языка, например то, что вы не можете обратиться к локальной переменной вне ее лексической области видимости. Скорее всего вы решите отказаться от использования этой библиотеки в финальной версии продукта, а то и вовсе захотите ее стереть.</p>
<p>Отладочная библиотека состоит из двух видов функций: интроспективные функции и ловушки. <em>Интроспективные функции</em> <strong>(introspective function)</strong> позволяют изучать различные стороны выполняемой программы, такие как стек ее активных функций, текущая выполняемая строка, значения и имена локальных переменных. <em>Ловушки</em> <strong>(hook)</strong> позволяют нам отслеживать выполнение программы.</p>
<p>Важным понятием в отладочной библиотеке является стековый уровень. <em>Стековый уровень</em> <strong>(stack level)</strong> — это число, которое относится к конкретной функции, активной в данный момент: у функции, вызвавшей отладочную библиотеку, уровень 1, у функции, которая вызвала эту функцию, уровень 2 и т. д.</p>
<h3 id="Chapter24.xhtml#sigil_toc_id_178">24.1. Интроспективные средства</h3>
<p>Главной интроспективной функцией в отладочной библиотеке является <code>debug.getinfo</code>. Ее первый параметр может быть функцией или стековым уровнем. При вызове <code>debug.getinfo(foo)</code> для какой-то функции <code>fоо</code> вы получите таблицу с некоторыми данными об этой функции. Эта таблица может иметь следующие поля:</p>
<ul>
<li><code>source</code>: где была определена функция. Если эта функция была определена в строке (посредством <code>loadstring</code>), то значением <code>source</code> будет эта строка. Если функция была определена в файле, то значение <code>source</code> — имя этого файла с префиксом '<code>@</code>';</li>
<li><code>short_src</code>: короткая версия <code>source</code> (до 60 символов), полезна для сообщений об ошибках;</li>
<li><code>linedefined</code>: номер первой строки в <code>source</code>, где функция была определена;</li>
<li><code>lastlinedefined</code>: номер последней строки в <code>source</code>, где функция была определена;</li>
<li><code>what</code>: что это за функция. Возможные значения: &quot;<code>Lua</code>&quot;, если это обычная функция Lua, &quot;<code>С</code>&quot;, если это функция С, или &quot;<code>main</code>&quot;, если это главная часть куска Lua;</li>
<li><code>name</code>: подходящее для функции имя;</li>
<li><code>namewhat</code>: что означает предыдущее поле. Возможные значения: &quot;<code>global</code>&quot;, &quot;<code>local</code>&quot;, &quot;<code>method</code>&quot;, &quot;<code>field</code>&quot; и &quot;&quot; (пустая строка). Пустая строка означает, что Lua не нашел имени для функции;</li>
<li><code>nups</code>: количество верхних значений для этой функции;</li>
<li><code>activelines</code>: таблица, представляющая множество активных строк функции. <em>Активная строка</em> <strong>(active line)</strong> — это строка с каким-то кодом, в отличие от пустых строк и строк, состоящих только из комментариев. (Типичное использование данной информации — это установка точек прерывания <strong>(breakpoint)</strong>. Большинство отладчиков не позволяет задавать точки прерывания не на активных строках, так как они были бы недостижимы.)</li>
<li><code>func</code>: сама функция; об этом позже.</li>
</ul>
<p>Когда <code>foo</code> является функцией С, у Lua о ней почти нет никаких данных. Для таких функций значимы лишь поля <code>what</code>, <code>name</code> и <code>namewhat</code>.</p>
<p>Когда вы вызываете <code>debug.getinfo(n)</code> для какого-то числа <em>n</em>, вы получаете данные о функции, активной на этом уровне стека. Например, если <em>n</em> равно 1, то вы получаете данные о функции, совершающей вызов. (Когда <em>n</em> равно 0, вы получаете данные о самой функции <code>getinfo</code>, т.е. функцию C.) Если <em>n</em> больше числа активных функций в стеке, то <code>debug.getinfo</code> возвращает nil. Когда вы опрашиваете активную функцию, вызывая <code>debug.getinfo</code> с числовым аргументом, у итоговой таблицы будет одно дополнительное поле с именем <code>сurrentline</code>, содержащее номер строки, на которой находится функция в данный момент. Кроме того, <code>func</code> содержит функцию, которая активна на этом уровне.</p>
<p>Поле <code>name</code> непростое. Как вы помните, из-за того, что функции в Lua являются значениями первого класса, функция может вообще не иметь имени или иметь несколько имен. Lua пытается найти имя функции путем просмотра кода, вызвавшем эту функцию, чтобы увидеть, как он ее вызвал. Этот метод работает лишь при вызове <code>getinfo</code> с числовым аргументом, то есть когда мы запрашиваем информацию о конкретном вызове.</p>
<p>Функция <code>getinfo</code> обладает низкой производительностью. Lua содержит отладочную информацию в форме, которая не ухудшает быстродействие программы; эффективный поиск информации здесь вторичен. Чтобы получить большее быстродействие, у <code>getinfo</code> есть необязательный второй параметр, который ограничивает круг поиска необходимой информации. Таким образом, данная функция не тратит лишнее время на сбор лишней информации. Формат данного параметра является строкой, где каждая буква служит для выбора группы полей согласно следующей таблице:</p>
<table>
<tbody>
<tr class="odd">
<td>'<code>n</code>' <code>name</code>, <code>namewhat</code>'<code>f</code>' <code>func</code>'<code>S</code>' <code>source</code>, <code>short_src</code>, <code>what</code>, <code>linedefined</code>, <code>lastlinedefined</code>'<code>l</code>' <code>currentline</code>'<code>L</code>' <code>activelines</code>'<code>u</code>' <code>nup</code></td>
</tr>
</tbody>
</table>
<p>Следующая функция иллюстрирует использование <code>debug.getinfo</code>. Она распечатывает примитивную обратную трассировку активного стека:</p>
<pre><code>function traceback ()
  for level = 1, math.huge do
    local info = debug.getinfo(level, &quot;Sl&quot;)
    if not info then break end
    if info.what == &quot;C&quot; then    -- функция C?
      print(level, &quot;C function&quot;)
    else                        -- функция Lua
      print(string.format(&quot;[%s]:%d&quot;, info.short_src,
                                     info.currentline))
    end
  end
end</code></pre>
<p>Эту функцию легко можно улучшить, добавив больше данных из <code>getinfo</code>. В действительности в отладочной библиотеке уже есть ее улучшенная версия — функция <code>traceback</code>. В отличие от нашей функции, <code>debug.traceback</code> не печатает свой результат; вместо этого она возвращает (обычно длинную) строку с обратной трассировкой.</p>
<h4 id="Chapter24.xhtml#sigil_toc_id_179">Доступ к локальным переменным</h4>
<p>Мы можем изучать локальные переменные любой активной функции при помощи функции <code>debug.getlocal</code>. У этой функции два параметра: стековый уровень опрашиваемой функции и индекс переменной. Она возвращает два значения: имя переменной и ее текущее значение. Если индекс переменной больше числа активных переменных, то <code>getlocal</code> возвращает nil. Если указан недопустимый стековый уровень, то <code>getlocal</code> вызывает ошибку. (Для проверки допустимости уровня стека мы можем воспользоваться <code>debug.getinfо</code>.)</p>
<p>Lua нумерует локальные переменные в порядке их появления внутри функции, считая лишь переменные, которые являются активными в текущей области видимости функции. Например, рассмотрим следующую функцию:</p>
<pre><code>function foo (a, b)
  local x
  do local c = a - b end
  local a = 1
  while true do
    local name, value = debug.getlocal(1, a)
    if not name then break end
    print(name, value)
    a = a + 1
  end
end</code></pre>
<p>Вызов <code>foo(10,20)</code> напечатает следующее:</p>
<pre><code>a    10
b    20
x    nil
a    4</code></pre>
<p>Переменная с индексом 1 — это <code>а</code> (первый параметр), с индексом 2 — это <code>b</code>, 3 — это <code>х</code>, 4 — это другая <code>а</code>. В момент вызова <code>getlocal</code> переменная <code>с</code> уже вышла из области видимости, в то время как <code>name</code> и <code>value</code> еще в нее не вошли. (Вспомните, что локальная переменная видна лишь <em>после</em> инициализирующего ее кода.)</p>
<p>Начиная с Lua 5.2, отрицательные индексы возвращают информацию о дополнительных аргументах функции: индекс -1 соответствует первому дополнительному аргументу. В этом случае именем переменной всегда будет &quot;<code>(*vararg)</code>&quot;.</p>
<p>Вы также можете изменять значения локальных переменных при помощи функции <code>debug.setlocal</code>. Ее первые два параметра — это уровень в стеке и индекс переменной, как и в <code>getlocal</code>. Ее третий <span>параметр — это новое значение для переменной. Функция возвращает имя переменной или nil, если индекс переменной вне области видимости.</span></p>
<h4 id="Chapter24.xhtml#sigil_toc_id_180">Доступ к нелокальным переменным</h4>
<p>Отладочная библиотека также позволяет обращаться к нелокальным переменным, используемым функцией Lua, при помощи <code>getupvalue</code>. В отличие от локальных переменных, нелокальные переменные, используемые функцией, существуют, даже когда функция не активна (в конце концов, в этом суть замыканий). Поэтому первый аргумент для <code>getupvalue</code> — это не уровень в стеке, а функция (точнее, замыкание). Второй аргумент — это индекс переменной. Lua нумерует нелокальные переменные в том порядке, в котором они впервые встречаются в функции, но этот порядок не важен, поскольку функция не может обратиться сразу к двум нелокальным переменным с одним и тем же именем.</p>
<p>Вы также можете обновлять нелокальные переменные при помощи <code>debug.setupvalue</code>. У нее, как вы уже догадались, три параметра: замыкание, имя переменной и новое значение. Как и <code>setlocal</code>, она возвращает имя переменной или nil, если индекс переменной вне допустимого диапазона.</p>
<p>Листинг 24.1 показывает, как мы можем получить доступ к значению любой из этих переменных по ее имени. Параметр <code>level</code> сообщает, где именно эта функция должна искать; увеличение на единицу нужно, чтобы не включать вызов к самой функции <code>getvarvalue</code>. Функция <code>getvarvalue</code> сначала проверяет локальную переменную. Если переменных с заданным именем несколько, то она использует переменную с наибольшим индексом; таким образом, она всегда должна пройти весь цикл. Если функция не может найти ни одной переменной с таким именем, то она проверяет нелокальные переменные. Для этого при помощи <code>debug.getinfo</code> она получает вызывающее замыкание, а затем перебирает все его нелокальные переменные. Наконец, если функции не удается найти нелокальную переменную с заданным именем, то она переходит к глобальной переменной: <code>getvarvalue</code> вызывает себя рекурсивно для доступа к подходящей переменной <code>_ENV</code>, а затем ищет заданное имя в этом окружении.</p>
<p><strong>Листинг 24.1.</strong> Получение значения переменной</p>
<pre><code>function getvarvalue (name, level)
  local value
  local found = false

  level = (level or 1) + 1

  -- пробует локальные переменные
  for i = 1, math.huge do
    local n, v = debug.getlocal(level, i)
    if not n then break end
    if n == name then
      value = v
      found = true
    end
  end
  if found then return value end

  -- пробует нелокальные переменные
  local func = debug.getinfo(level, &quot;f&quot;).func
  for i = 1, math.huge do
    local n, v = debug.getupvalue(func, i)
    if not n then break end
    if n == name then return v end
  end

  -- не найдено; получает значение из окружения
  local env = getvarvalue(&quot;_ENV&quot;, level)
  return env[name]
end</code></pre>
<h4 id="Chapter24.xhtml#sigil_toc_id_181">Доступ к другим сопрограммам</h4>
<p>Все интроспективные функции из отладочной библиотеки могут принимать в качестве первого аргумента сопрограмму, чтобы мы могли изучить сопрограмму извне. Давайте рассмотрим следующий пример:</p>
<pre><code>co = coroutine.create(function ()
  local x = 10
  coroutine.yield()
  error(&quot;some error&quot;)
end)

coroutine.resume(co)
print(debug.traceback(co))</code></pre>
<p>Вызов <code>traceback</code> обработает сопрограмму <code>co</code>, и результат будет примерно таким:</p>
<pre><code>stack traceback:
         [C]: in function &#39;yield&#39;
         temp:3: in function &lt;temp:1&gt;</code></pre>
<p>Данная трассировка не затрагивает вызов <code>resume</code>, поскольку эта сопрограмма и главная программа выполняются в разных стеках.</p>
<p>Когда сопрограмма вызывает ошибку, она не раскручивает стек. Это значит, что после ошибки мы можем его изучить. В продолжение нашего примера, если мы вновь возобновим сопрограмму, это приведет к ошибке:</p>
<pre><code>print(coroutine.resume(co))    --&gt; false    temp:4: some error</code></pre>
<p>Теперь если мы распечатаем трассировку стека, то получим что-то вроде:</p>
<pre><code>stack traceback:
         [C]: in function &#39;error&#39;
         temp:4: in function &lt;temp:1&gt;</code></pre>
<p>При этом мы можем изучать локальные переменные из сопрограммы даже после ошибки:</p>
<pre><code>print(debug.getlocal(co, 1, 1))    --&gt; x 10</code></pre>
<h3 id="Chapter24.xhtml#sigil_toc_id_182">24.2. Ловушки</h3>
<p>Механизм <em>ловушек</em> <strong>(hook)</strong> из отладочной библиотеки позволяет нам зарегистрировать функцию, которая будет вызвана при наступлении определенных событий во время выполнения программы. Существует четыре вида событий, которые могут заставить сработать ловушки:</p>
<ul>
<li><em>call</em> <strong>(событие вызова)</strong> происходит каждый раз, когда Lua вызывает функцию;</li>
<li><em>return</em> <strong>(событие возврата)</strong> происходит каждый раз при возврате из функции;</li>
<li><em>line</em> <strong>(событие строки)</strong> происходит, когда Lua начинает выполнение следующей строки кода;</li>
<li><em>count</em> <strong>(событие счетчика)</strong> происходит после заданного количества команд.</li>
</ul>
<p>Lua вызывает ловушки с единственным аргументом — строкой, описывающей событие, которое привело в вызову: &quot;<code>call</code>&quot; (или &quot;<code>tail call</code>&quot;), &quot;<code>return</code>&quot;, &quot;<code>line</code>&quot; или &quot;<code>count</code>&quot;. Для события строки также передается второй аргумент — новый номер строки. Для получения дополнительной информации внутри ловушки следует использовать <code>debug.getinfо</code>.</p>
<p>Чтобы зарегистрировать ловушку, мы вызываем функцию <code>debug.sethook</code> с двумя или тремя аргументами: первый аргумент — это функция ловушки; второй аргумент — это фильтрующая строка, которая описывает, какие именно события мы хотим отслеживать; и необязательный третий аргумент — это число, задающее с какой частотой мы хотим получать события счетчика. Чтобы отслеживать события вызова, возврата и строки, мы добавляем их первые буквы ('<code>c</code>', '<code>r</code>' или '<code>l</code>') к фильтрующей строке. Для отслеживания событий счетчика мы просто передаем счетчик как третий аргумент. Для отключения всех ловушек нужно вызвать <code>sethook</code> без аргументов.</p>
<p>В качестве простого примера следующий код устанавливает примитивный трассировщик, который печатает каждую строку кода, выполняемую интерпретатором:</p>
<pre><code>debug.sethook(print, &quot;l&quot;)</code></pre>
<p>Этот вызов устанавливает <code>print</code> как функцию ловушки и приказывает Lua вызывать ее только при событиях строки. Более проработанный трассировщик может использовать <code>getinfo</code>, чтобы добавить к трассировке имя текущего файла:</p>
<pre><code>function trace (event, line)
  local s = debug.getinfo(2).short_src
  print(s .. &quot;:&quot; .. line)
end

debug.sethook(trace, &quot;l&quot;)</code></pre>
<p>Для ловушек удобна функция <code>debug.debug</code>. Эта простая функция печатает приглашение ввода, которое выполняет любые команды Lua. Она примерно эквивалентна следующему коду:</p>
<pre><code>function debug1 ()
  while true do
    io.write(&quot;debug&gt; &quot;)
    local line = io.read()
    if line == &quot;cont&quot; then break end
    assert(load(line))()
  end
end</code></pre>
<p>Когда пользователь вводит «команду» <code>cont</code>, эта функция завершается. Стандартная реализация очень проста и выполняет команды в глобальном окружении, вне области видимости отлаживаемого кода. Упражнение 24.5 обсуждает более удачную реализацию.</p>
<h3 id="Chapter24.xhtml#sigil_toc_id_183">24.3. Профилирование</h3>
<p>Несмотря на свое имя, отладочная библиотека годится и для других задач. Часто такой задачей является профилирование. Для профилирования с учетом времени лучше использовать интерфейс С, так как затраты Lua на вызов каждой ловушки довольно велики и могут свести на нет любые замеры. Тем не менее, для профилирования на основе подсчета вызовов код Lua вполне подходит. В этом разделе мы разработаем элементарный профилировщик, который подсчитывает, сколько раз была вызвана функция во время выполнения программы.</p>
<p>Главными структурами данных нашей программы будут две таблицы: одна связывает функции с их счетчиками вызовов, а другая связывает функции с их именами. Индексами в обеих таблицах будут сами функции.</p>
<pre><code>local Counters = {}
local Names = {}</code></pre>
<p>Мы могли бы извлечь имена функций и после профилирования, но не забывайте, что мы получим лучшие результаты, если будем извлекать имена функций, пока они активны, поскольку в этом случае Lua может просматривать код, который вызывает эту функцию, чтобы найти ее имя.</p>
<p>Теперь мы определим функцию ловушки. Ее задачей является получить вызванную функцию и увеличить соответствующий счетчик; при этом она собирает имена функций:</p>
<pre><code>local function hook ()
  local f = debug.getinfo(2, &quot;f&quot;).func
  local count = Counters[f]
  if count == nil then -- first time &#39;f&#39; is called?
    Counters[f] = 1
    Names[f] = debug.getinfo(2, &quot;Sn&quot;)
  else -- only increment the counter
    Counters[f] = count + 1
  end
end</code></pre>
<p>Следующим шагом является запуск программы с этой ловушкой. Мы будем считать, что главный кусок программы находится в файле, и что пользователь в качестве аргумента передает профилировщику имя этого файла, например так:</p>
<pre><code>% lua profiler main-prog</code></pre>
<p>С этой схемой профилировщик может взять имя файла из <code>arg[1]</code>, включить ловушку и выполнить файл:</p>
<pre><code>local f = assert(loadfile(arg[1]))
debug.sethook(hook, &quot;c&quot;)    -- включает ловушку для вызовов
f()                         -- выполняет главную программу
debug.sethook()             -- выключает эту ловушку</code></pre>
<p>Последний шаг — это показ результатов. Функция <code>getname</code> из листинга 24.2 выдает для каждой функции ее имя. Из-за того, что имена функций в Lua несколько непостоянны, мы добавим к каждой функции ее местоположение, заданное в виде пары <em>файл</em><code>:</code><em>номер_строки</em>. Если у функции нет имени, то мы печатаем лишь ее местоположение. Если это функция С, то мы используем только ее имя (так как у нее нет местоположения). После данного определения мы печатаем каждую функцию с ее счетчиком:</p>
<pre><code>for func, count in pairs(Counters) do
  print(getname(func), count)
end</code></pre>
<p><strong>Листинг 24.2.</strong> Получение имени функции</p>
<pre><code>function getname (func)
  local n = Names[func]
  if n.what == &quot;C&quot; then
    return n.name
  end
  local lc = string.format(&quot;[%s]:%d&quot;, n.short_src, n.linedefined)
  if n.what ~= &quot;main&quot; and n.namewhat ~= &quot;&quot; then
    return string.format(&quot;%s (%s)&quot;, lc, n.name)
  else
    return lc
  end
end</code></pre>
<p>Если мы применим наш профилировщик к примеру с цепью Маркова, который мы разработали в разделе 10.3, то получим результат вроде этого:</p>
<pre><code>[markov.lua]:4 884723
write 10000
[markov.lua]:0 1
read 31103
sub 884722
[markov.lua]:1 (allwords)    1
[markov.lua]:20 (prefix)     894723
find 915824
[markov.lua]:26 (insert)     884723
random 10000
sethook 1
insert 884723</code></pre>
<p>Данный результат указывает на то, что анонимная функция в строке 4 (которая является нашим итератором, определенным внутри <code>allwords</code>) была вызвана 884 723 раз, функция <code>write(io.write)</code> была вызвана 10 000 раз и т. д.</p>
<p>Есть несколько улучшений, которые могут быть внесены в этот профилировщик, например, сортировка вывода, улучшенная печать имен функций и более красивый формат вывода. Тем не менее, этот базовый профилировщик уже и так полезен и может быть использован как основа более продвинутых инструментов.</p>
<h3 id="Chapter24.xhtml#sigil_toc_id_184">Упражнения</h3>
<p><strong>Упражнение 24.1.</strong> Почему рекурсия в функции <code>getvarvalue</code> (листинг 24.1) обязательно остановится?</p>
<p><strong>Упражнение 24.2.</strong> Приспособьте функцию <code>getvarvalue</code> (листинг 24.1) для работы с различными сопрограммами (подобно другим функциям из отладочной библиотеки).</p>
<p><strong>Упражнение 24.3.</strong> Напишите функцию <code>setvarvalue</code>, похожую на <code>getvarvalue</code> (листинг 24.1).</p>
<p><strong>Упражнение 24.4.</strong> Напишите модификацию <code>getvarvalue</code> (листинг 24.1) под именем <code>getallvars</code>, которая возвращает таблицу со всеми переменными, которые видны в вызывающей функции. (Ввозвращаемая таблица не должна включать в себя переменные окружения; вместо этого она должна наследовать их из исходного окружения).</p>
<p><strong>Упражнение 24.5.</strong> Напишите улучшенную версию <code>debug.debug</code>, которая выполняет заданные команды, как если бы они были выполнены в области видимости вызывающей функции. (Подсказка: выполняйте команды в пустом окружении и используйте метаметод <code>__index</code> с прикрепленной функцией <code>getvarvalue</code> для всех обращений к переменным.)</p>
<p><strong>Упражнение 24.6.</strong> Улучшите предыдущий пример, добавив обновление переменных.</p>
<p><strong>Упражнение 24.7.</strong> Реализуйте некоторые из предложенных улучшений для базового профилировщика из раздела 24.3.</p>
<p><strong>Упражнение 24.8</strong>. Напишите библиотеку для точек прерывания <strong>(breakpoint)</strong>. Она должна предлагать как минимум две функции:</p>
<pre><code>setbreakpoint(function, line)    --&gt; возвращает handle
removebreakpoint(handle)</code></pre>
<p>Точка прерывания задается функцией и строкой внутри этой функции. Когда программа сталкивается с точкой прерывания, эта библиотека должна вызывать <code>debug.debug</code>. <span style="text-indent: 1.5em;">(Подсказка: для базовой реализации используйте ловушку строки, которая проверяет, есть ли в ней точка прерывания; для улучшения быстродействия при отслеживании выполнения программы используйте ловушку вызова и включайте ловушку строки лишь тогда, когда программа выполняет заданную функцию.)</span></p>
<p><span id="Part4.xhtml"></span></p>
<div style="text-align: center; padding: 0pt; margin: 0pt;">
<h1>Часть IV</h1>
<h1 id="Part4.xhtml#sigil_toc_id_185" class="part">C API</h1>
<svg xmlns="http://www.w3.org/2000/svg" height="75%" preserveaspectratio="xMidYMid meet" version="1.1" viewbox="0 0 1400 1300" width="100%" xlink="http://www.w3.org/1999/xlink">

</svg>
</div>
<p><span id="Chapter25.xhtml"></span></p>
<h2>ГЛАВА 25</h2>
<h2 id="Chapter25.xhtml#sigil_toc_id_186">Обзор С API</h2>
<p>Lua — это <em>встраиваемый язык</em>. Это значит, что Lua — не автономный пакет, а библиотека, которую мы можем скомпоновать с другими приложениями для внедрения в них средств Lua.</p>
<p>Вероятно, вы задаетесь вопросом: если Lua — это не автономная программа, то как получилось, что мы до сих пор использовали ее отдельно на протяжении всей книги? Ответом на эту загадку является интерпретатор Lua (выполнимый файл <code>lua</code>). Это крошечное приложение (менее чем из пятисот строк кода), которое использует библиотеку Lua для реализации автономного интерпретатора. Автомноный интерпретатор обеспечивает взаимодействие с пользователем, принимая файлы и строки для последующей передачи их библиотеке Lua, которая и делает всю основную работу (такую как настоящее выполнение кода на Lua).</p>
<p>Возможность использования в качестве библиотеки для расширения приложения — это то, что делает Lua <em>расширяющим языком</em>. В то же время программа, которая использует Lua, может регистрировать новые функции в его окружении; такие функции реализуют на C (или другом языке), тем самым добавляя средства, которые не могут быть написаны непосредственно на Lua. Это то, что делает Lua <em>расширяемым языком</em>.</p>
<p>Эти два взгляда на Lua (как на расширяющий язык и как на расширяемый язык) соответствуют двум видам взаимодействия между С и Lua. В первом случае управление у С, a Lua — библиотека. Код С при данном виде взаимодействия мы называем <em>прикладным кодом</em>. Во втором случае управление у Lua, а С — библиотека. Здесь код С называется <em>библиотечным кодом</em>. И прикладной, и библиотечный код использует один и тот же API для взаимодействия с Lua — так называемый С API.</p>
<p>С API — это набор функций, которые позволяют коду С взаимодействовать с Lua. (<span class="underline">Примечание</span>: Далее в этом тексте термин «функция» на самом деле означает «функция или макрос». API реализует некоторые средства в виде макросов.) Он включает в себя функции для чтения и записи глобальных переменных Lua, для вызова функций Lua, для выполнения фрагментов кода на Lua, для регистрации функций С, чтобы позже их можно было вызвать из кода Lua и т.д. Практически все, что код Lua может сделать, может быть также сделано и на С посредством С API.</p>
<p>С API следует принципу работы с С, который заметно отличается от принципа работы с Lua. При программировании на С мы должне заботиться о проверке типов, о восстановлении после ошибок, об ошибках выделения памяти и о некоторых источниках трудностей. Большинство функций API не проверяет правильность своих аргументов; это ваша задача — убедиться в том, что аргументы корректны перед вызовом функции. (<span class="underline">Примечание</span>: Вы можете компилировать код с макросом <code>LUA_USE_APICHECK</code>, который задействует некоторые проверки; эта опция особенно полезна при отладке вашего кода С. Тем не менее, некоторые ошибки, вроде недопустимых указателей, в C просто не могут быть обнаружены.) Если вы допускаете ошибки, то можете получить такие не особо информативные сообщения об ошибках, как «segmentation fault». Более того, С API делает упор на гибкость и простоту, зачастую за счет легкости использования. Типичные задачи могут потребовать нескольких вызовов API. Это может быть утомительным, но зато дает вам полный контроль над происходящим.</p>
<p>Целью данной главы, как ясно из ее названия, является обзор того, что вам потребуется при при использовании Lua из С. Не пытайтесь сейчас понять все детали происходящего. Мы остановимся на них позже. Однако, не забывайте, что вы всегда можете найти более подробную информацию о специфических функциях в справочном руководстве по Lua. Более того, вы можете найти некоторые примеры использования API в самой поставке Lua. Автономный интерпретатор Lua (<code>lua.с</code>) предоставляет примеры прикладного кода, в то время как стандартные библиотеки (<code>lmathlib.c</code>, <code>lstrlib.c</code> и т.д.) снабжены примерами библиотечного кода.</p>
<p>С этого момента вы выступаете в роли программистов на С. Когда я говорю «вы», то имею в виду вас, как программирующего на С или пытающегося быть программистом на C.</p>
<p>Важным компонентом во взаимодействии между Lua и С является вездесущий виртуальный <em>стек</em>. Почти все функции API работают со значениями в этом стеке. Весь обмен данными между Lua и С происходит через этот стек. Более того, вы также можете использовать его для хранения промежуточных результатов. Он помогает разобраться с двумя принципиальными отличиями между Lua и С: первое отличие заключается в том, что в Lua есть сборка мусора, в то время как С требуется явное высвобождение памяти; второе <span>отличие возникает из-за огромной пропасти между динамической типизацией в Lua и статической типизацией в С. Мы обсудим стек более подробно в разделе 25.2.</span></p>
<h3 id="Chapter25.xhtml#sigil_toc_id_187">25.1. Первый пример</h3>
<p>Мы начнем этот обзор с простого примера прикладного приложения: автономного интерпретатора Lua. Мы можем написать примитивный автономный интерпретатор Lua, как в листинге 25.1. Заголовочный файл <code>lua.h</code> определяет основные функции, предоставляемые Lua. Он включает в себя функции для создания нового окружения Lua, для вызова функций Lua (таких как <code>lua_pcall</code>), для чтения и записи глобальных переменных в окружении Lua, для регистрации новых функций для вызова из Lua и т.д. Все, что определено в файле <code>lua.h</code>, имеет префикс <code>lua_</code>.</p>
<p><strong>Листинг 25.1.</strong> Простой автономный интерпретатор Lua</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;lua.h&quot;
#include &quot;lauxlib.h&quot;
#include &quot;lualib.h&quot;

int main (void) {
  char buff[256];
  int error;
  lua_State *L = luaL_newstate();                  /* открывает Lua */
  luaL_openlibs(L);             /* открывает стандартные библиотеки */

  while (fgets(buff, sizeof(buff), stdin) != NULL) {
    error = luaL_loadstring(L, buff) || lua_pcall(L, 0, 0, 0);
    if (error) {
      fprintf(stderr, &quot;%s\n&quot;, lua_tostring(L, -1));
      lua_pop(L, 1);    /* выталкивает сообщение об ошибке из стека */
    }
  }

  lua_close(L);
  return 0;
}</code></pre>
<p>Заголовочный файл <code>lauxlib.h</code> определяет функции, предоставленные <em>вспомогательной библиотекой</em> (<code>auxlib</code>). Все их определения начинаются с <code>luaL_</code> (например, <code>luaL_loadstring</code>). Вспомогательная библиотека использует базовый API, предоставляемый <code>lua.h</code> для обеспечения абстракций более высокого уровня, в частности абстракций, используемых стандартными библиотеками. Базовый API стремится к экономичности и независимости, в то время как вспомогательная библиотека стремится к практичности для распространенных задач. Разумеется, для вашей программы тоже очень легко можно создавать другие абстракции, которые ей понадобятся. Имейте в виду, что у вспомогательной библиотеки нет доступа ко внутренним компонентам Lua. Всю работу она выполняет посредством официального базового API. Все, что может он, может и ваша программа.</p>
<p>Библиотека Lua вообще не определяет никаких глобальных переменных. Она хранит все свое состояние в динамической структуре <code>lua_State</code>; все функции внутри Lua получают указатель на эту структуру в качестве аргумента. Эта реализация делает Lua реентерабельным <strong>(с возможностью повторного входа в приложение)</strong> и готовым к использованию в многонитевых приложениях.</p>
<p>Как следует из ее имени, функция <code>luaL_newstate</code> создает новое состояние Lua. Когда <code>luaL_newstate</code> создает новое состояние, то его окружение не содержит никаких встроенных функций, даже <code>print</code>. Чтобы сохранить размер Lua небольшим, все стандартные библиотеки представлены как отдельные пакеты, поэтому вы не обязаны их использовать, если они вам не нужны. Заголовочный файл <code>lualib.h</code> определяет функции для открытия библиотек. Функция <code>luaL_openlibs</code> открывает все стандартные библиотеки.</p>
<p>После создания состояния и наполнения его стандартными библиотеками пора приступить к обработке данных, вводимых пользователем. Для каждой строки, которую вводит пользователь, программа сначала вызывает <code>luaL_loadstring</code> для компиляции этого кода. Если ошибок нет, то этот вызов возвращает ноль и заталкивает получившуюся функцию в стек. (Помните, что мы обсудим этот «волшебный» стек в деталях в следующем разделе.) После этого программа вызывает <code>lua_pcall</code>, которая выталкивает функцию из стека и выполняет ее в защищенном режиме. Как и <code>luaL_loadstring</code>, функция <code>lua_pcall</code> возвращает ноль, если нет ошибок. В случае ошибки обе функции заталкивают в стек сообщение об ошибке; мы получим это сообщение при помощи <code>lua_tostring</code>, и после того, как мы его напечатаем, мы удалим его из стека при помощи <code>lua_рор</code>.</p>
<p>Обратите внимание, что в случае ошибки программа просто печатает сообщение об ошибке в стандартный поток для ошибок. Настоящая обработка ошибок в С может быть довольно сложной, и то, как ее следует выполнять, зависит от типа вашего приложения. Ядро Lua никогда ничего не печатает ни в какой выходной поток; оно сообщает об ошибках посредством возвращения сообщений о них. Каждое приложение может обрабатывать эти сообщения наиболее подходящим для него способом. Чтобы данные рассуждения стали понятнее, мы на время прибегнем к простому обработчику ошибок, который печатает сообщение об ошибке, закрывает состояние Lua и производит выход из всего приложения:</p>
<pre><code>#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void error (lua_State *L, const char *fmt, ...) {
  va_list argp;
  va_start(argp, fmt);
  vfprintf(stderr, fmt, argp);
  va_end(argp);
  lua_close(L);
  exit(EXIT_FAILURE);
}</code></pre>
<p>Позже мы еще вернемся к обработке ошибок в прикладном коде.</p>
<p>Поскольку вы можете компилировать Lua и как код на С, и как код на C++, <code>lua.h</code> не включает в себя этот типичный код для поправок, который бывает в некоторых других библиотеках С:</p>
<pre><code>#ifdef __cplusplus
extern &quot;C&quot; {
#endif
...
#ifdef __cplusplus
}
#endif</code></pre>
<p>Если вы компилируете Lua как код С (наиболее частый случай) и используете его в C++, вы можете включать <code>lua.hpp</code> вместо <code>lua.h</code>. Он определен следующим образом:</p>
<pre><code>extern &quot;C&quot; {
#include &quot;lua.h&quot;
}</code></pre>
<h3 id="Chapter25.xhtml#sigil_toc_id_188">25.2. Стек</h3>
<p>При обмене значениями между Lua и С мы сталкиваемся с двумя сложностями: несоответствие между статической и динамической системами типизации и несоответствие между автоматическим и ручным управлением памятью.</p>
<p>В Lua, когда мы пишем <code>а[k]=v</code>, переменные <code>k</code> и <code>v</code> могут иметь самые разные типы, даже <code>а</code> может иметь другой тип из-за применения метатаблиц. Однако, если мы хотим предложить эту операцию в С, то каждая отдельно взятая функция <code>settable</code> должна иметь фиксированный тип. Нам понадобятся десятки разных функций для этой простой операции (по одной функции на каждую комбинацию из типов трех аргументов).</p>
<p>Мы можем решить данную проблему, введя нечто вроде типа union из C — назовем его <code>lua_Value</code>, который может представлять все значения в Lua. Тогда мы могли бы объявить <code>settable</code> как</p>
<pre><code>void lua_settable (lua_Value a, lua_Value k, lua_Value v);</code></pre>
<p>Однако, у этого решения есть два недостатка. Во-первых, может быть довольно сложно адаптировать столь комплексный тип данных под другие языки; мы разрабатывали Lua так, чтобы он легко взаимодействовал не только с C/C++, но также и с Java, Fortran, C# и другими языками. Во-вторых, Lua осуществляет сборку мусора: если мы храним таблицу Lua в переменной С, то движок Lua о таком использовании никак знать не может; он мог бы (ошибочно) предположить, что эта таблица является мусором, и удалить ее.</p>
<p>Таким образом, Lua API не определяет типы подобные <code>lua_Value</code>. Вместо этого он использует абстрактный стек для обмена значениями между Lua и С. Каждый слот в этом стеке может содержать любое значение Lua. Каждый раз, когда вам нужно получить значение от Lua (например, значение глобальной переменной), вы вызываете Lua, и он заталкивает нужное значение в стек. Когда вы хотите передать значение в Lua, то вы сперва заталкиваете его в стек, и лишь затем вызываете Lua (который вытолкнет это значение из стека). Нам по-прежнему нужна одна функция для заталкивания каждого типа С в стек и другая для получения каждого типа C из стека, но зато мы избежали комбинаторный взрыв. Более того, поскольку этот стек живет внутри Lua, то сборщик мусора знает, какие значения использует С.</p>
<p>Практически все функции в API используют стек. Как мы уже видели в нашем первом примере, <code>luaL_loadstring</code> оставляет свой результат в стеке (либо как скомпилированный кусок, либо как сообщение об ошибке); <code>lua_pcall</code> получает функцию, которую необходимо вызвать из стека, и оставляет в нем сообщение об ошибке, если она произойдет.</p>
<p>Lua работает со стеком строго в соответствии с принципом LIFO <strong>(Last In, First Out — последним вошел, первым вышел)</strong>. Когда вы вызываете Lua, то он меняет лишь верхнюю часть стека. У кода С больше свободы; в частности, он может просматривать любой элемент внутри стека и даже вставлять и удалять элементы на любой произвольной позиции.</p>
<h4 id="Chapter25.xhtml#sigil_toc_id_189">Заталкивание элементов</h4>
<p>В API содержится по одной функции заталкивания для каждого типа С, который может быть представлен в Lua: <code>lua_pushnil</code> для константы nil, <code>lua_pushboolean</code> для логических значений (целые числа в С), <code>lua_pushnumber</code> для чисел с плавающей точкой двойной точности, <code>lua_pushinteger</code> для целых чисел со знаком, <code>lua_pushunsigned</code> для целых чисел без знака, <code>lua_pushlstring</code> для произвольных строк (указатель на <code>char</code> плюс длина) и <code>lua_pushstring</code> для строк, которые завершаются нуль-символом:</p>
<pre><code>void lua_pushnil      (lua_State *L);
void lua_pushboolean  (lua_State *L, int bool);
void lua_pushnumber   (lua_State *L, lua_Number n);
void lua_pushinteger  (lua_State *L, lua_Integer n);
void lua_pushunsigned (lua_State *L, lua_Unsigned n);
void lua_pushlstring  (lua_State *L, const char *s, size_t len);
void lua_pushstring   (lua_State *L, const char *s);</code></pre>
<p>Также есть функции для заталкивания в стек функций С и значений пользовательских данных; мы обсудим их позже.</p>
<p>Тип <code>lua_Number</code> — это числовой тип в Lua. По умолчанию он равен double, но в некоторых дистрибутивах он может быть заменен на float или даже на long integer для адаптации под компьютеры с сильно ограниченными ресурсами. Тип <code>lua_Integer</code> — это целочисленный тип со знаком, достаточно большой, чтобы хранить в себе размер больших строк. Обычно он определен как тип <code>ptrdiff_t</code>. Тип <code>lua_Unsigned</code> (который появился в Lua 5.2) — это 32-битовый беззнаковый целочисленный тип в С; он используется библиотекой для побитовых операций и соответственными функциями.</p>
<p>Строки в Lua не завершаются нуль-символом; они могут содержать произвольные бинарные данные. Соответственно, их длина должна быть задана явно. Основной функцией для заталкивания строки в стек является <code>lua_pushlstring</code>, для которой требуется явно указывать длину в качестве аргумента. Для строк, завершенных нуль-символом, вы также можете использовать <code>lua_pushstring</code>, которая для вычисления длины строки использует <code>strlen</code>. Lua никогда не хранит указатели на внешние строки (или на любой другой внешний объект, за исключением функций С, которые всегда статические). Для любой строки, которую необходимо хранить, Lua или делает копию, или повторно использует существующую. Соответственно, вы можете освободить или изменить ваш буфер, как только из этих функций вернется управление.</p>
<p>Когда вы заталкивате элемент в стек, то ваша обязанность — проследить, чтобы в стеке для него было достаточно места. Помните о том, что сейчас вы программист на С; Lua вас баловать не станет. Когда Lua начинает выполнение и в любой момент, когда Lua вызывает С, в стеке есть как минимум 20 свободных слотов. (Заголовочный файл <code>lua.h</code> определяет эту константу как <code>LUA_MINSTACK</code>.) Этого места более чем достаточно для большинства задач, поэтому, как правило, об этом можно даже не думать. Однако, для некоторых задач требуется больше места в стеке, в частности если у вас есть цикл, который заталкивает элементы в стек. В этих случаях вы можете вызвать функцию <code>lua_checkstack</code>, которая проверяет, достаточно ли в стеке места для ваших нужд:</p>
<pre><code>int lua_checkstack (lua_State *L, int sz);</code></pre>
<h4 id="Chapter25.xhtml#sigil_toc_id_190">Обращение к элементам</h4>
<p>Для обращения к элементам в стеке API использует <em>индексы</em>. Первый помещенный в стек элемент имеет индекс 1, следующий — индекс 2, и так до самой вершины. Мы также можем обращаться к элементам стека, приняв вершину стека за отправную точку и используя отрицательные индексы. В этом случае -1 соответствует элементу на вершине стека (то есть помещенному в стек последним), -2 соответствует предыдущему элементу и т. д. Например, вызов <code>lua_tostring(L,-1)</code> возвращает значение на вершине стека как строку. Как мы увидим, в одних случаях стек удобнее индексировать с его основания (то есть используя положительные индексы), а в других более естественно использовать отрицательные индексы.</p>
<p>Для проверки того, является ли элемент значением заданного типа, API предлагает семейство функций <code>lua_is*</code>, где <code>*</code> может быть любым типом Lua. Соответственно, есть функции <code>lua_isnumber</code>, <code>lua_isstring</code>, <code>lua_istable</code> и т. д. У всех этих функций один и тот же прототип:</p>
<pre><code>int lua_is* (lua_State *L, int index);</code></pre>
<p>В действительности <code>lua_isnumber</code> не проверяет, есть ли у значения этот конкретный тип, а проверяет, может ли значение быть преобразовано в этот тип; <code>lua_isstring</code> ведет себя аналогично: в частности, для <code>lua_isstring</code> подходит любое число.</p>
<p>Также существует функция <code>lua_type</code>, которая возвращает тип элемента в стеке. Каждый тип представлен константой, определенной в заголовочном файле <code>lua.h</code>: <code>LUA_TNIL</code>, <code>LUA_TBOOLEAN</code>, <code>LUA_TNUMBER</code>, <code>LUA_TSTRING</code>, <code>LUA_TTABLE</code>, <code>LUA__TTHREAD</code>, <code>LUA_TUSERDATA</code> и <code>LUA_TFUNCTION</code>. Обычно мы используем эту функцию совместно с оператором switch. Также она оказывается полезной, когда нам нужно проверить значение на принадлежность к числам или строкам без приведения типов.</p>
<p>Для получения значений из стека применяются функции <code>lua_to*</code>:</p>
<pre><code>int          lua_toboolean  (lua_State *L, int index);
const char  *lua_tolstring  (lua_State *L, int index, size_t *len);
lua_Number   lua_tonumber   (lua_State *L, int index);
lua_Integer  lua_tointeger  (lua_State *L, int index);
lua_Unsigned lua_tounsigned (lua_State *L, int idx);</code></pre>
<p>Функция <code>lua_toboolean</code> преобразует любое значение Lua в логическое значение С (0 или 1), следуя правилам Lua для выражений условия: nil и false ложны, все остальные значения истинны.</p>
<p>Допустимо вызывать любую из <code>lua_to*</code> функций, даже когда заданный элемент не обладает подходящим типом. Функция <code>lua_toboolean</code> работает для любого типа; <code>lua_tolstring</code> возвращает <code>NULL</code> для нестроковых значений. Однако, у числовых функций нет возможности сообщить о неправильном типе, поэтому в случае ошибки они просто возвращают ноль. Обычно для проверки типа вам следует вызывать <code>lua_isnumber</code>, но в Lua 5.2 ввели следующие новые функции:</p>
<pre><code>lua_Number   lua_tonumberx   (lua_State *L, int idx, int *isnum);
lua_Integer  lua_tointegerx  (lua_State *L, int idx, int *isnum);
lua_Unsigned lua_tounsignedx (lua_State *L, int idx, int *isnum);</code></pre>
<p>Выходной параметр <code>isnum</code> возвращает булево значение, сообщающее о том, было ли значение Lua числом. (Если вам это значение не нужно, то вы можете в качестве последнего параметра передать <code>NULL</code>. Старые функции <code>lua_to*</code> теперь реализованы как макросы на основе этих функций.)</p>
<p>Функция <code>lua_tolstring</code> возвращает указатель на внутреннюю копию строки и хранит длину строки в позиции, заданной <code>len</code>. Вы не можете изменять эту внутреннюю копию (выставленный <code>const</code> напомнит вам об этом). Lua следит за тем, чтобы этот указатель был действителен до тех пор, пока соответствующее строковое значение находится в стеке. Когда функция С, вызванная из Lua, возвращает управление, Lua очищает ее стек; поэтому, как правило, вы никогда не должны хранить указатели на строки Lua вне функции, получившей их.</p>
<p>Любая строка, которую возвращает <code>lua_tolstring</code>, всегда содержит в конце дополнительный ноль, но она может содержать внутри себя и другие ноли. Настоящая длина строки возвращается через третий аргумент <code>len</code>. В частности, если предположить, что значение на вершине стека является строкой, то следующие функции <code>assert</code> всегда действительны:</p>
<pre><code>size_t l;
const char *s = lua_tolstring(L, -1, &amp;l);    /* любая строка Lua */
assert(s[l] == &#39;\0&#39;);
assert(strlen(s) &lt;= l);</code></pre>
<p>Вы можете вызвать <code>lua_tolstring</code> с <code>NULL</code> в качестве третьего аргумента, если вам не нужна эта длина. А еще лучше воспользоваться макросом <code>lua_tostring</code>, который просто вызывает <code>lua_tolstring</code> с третьим аргументом, равным <code>NULL</code>.</p>
<p>Чтобы проиллюстрировать применение этих функций листинг 25.2 содержит полезную вспомогательную функцию, которая печатает все содержимое стека. Эта функция обходит весь стек от основания до вершины, печатая каждый элемент в соответствии с его типом. Стоки печатаются в кавычках, для чисел используется формат '<code>%g</code>'; для других значений (функции, таблицы и т.п.) печатается только их тип. (Функция <code>lua_typename</code> преобразует код типа в название типа.)</p>
<p><strong>Листинг 25.2.</strong> Печать содержимого стека</p>
<pre><code>static void stackDump (lua_State *L) {
  int i;
  int top = lua_gettop(L); /* глубина стека */
  for (i = 1; i &lt;= top; i++) { /* повторяет для каждого уровня */
    int t = lua_type(L, i);
    switch (t) {
      case LUA_TSTRING: { /* строки */
        printf(&quot;&#39;%s&#39;&quot;, lua_tostring(L, i));
        break;
      }
      case LUA_TBOOLEAN: { /* булевы значения */
        printf(lua_toboolean(L, i) ? &quot;true&quot; : &quot;false&quot;);
        break;
      }
      case LUA_TNUMBER: { /* числа */
        printf(&quot;%g&quot;, lua_tonumber(L, i));
        break;
      }
      default: { /* другие значения */
        printf(&quot;%s&quot;, lua_typename(L, t));
        break;
      }
    }
    printf(&quot; &quot;); /* помещает разделитель */
  }
  printf(&quot;\n&quot;); /* конец листинга */
}</code></pre>
<h4 id="Chapter25.xhtml#sigil_toc_id_191">Другие стековые операции</h4>
<p>Кроме предыдущих функций, служащих для обмена данными между С и стеком, данный API также предоставляет следующие операции для общей работы со стеком:</p>
<pre><code>int  lua_gettop    (lua_State *L);
void lua_settop    (lua_State *L, int index);
void lua_pushvalue (lua_State *L, int index);
void lua_remove    (lua_State *L, int index);
void lua_insert    (lua_State *L, int index);
void lua_replace   (lua_State *L, int index);
void lua_copy      (lua_State *L, int fromidx, int toidx);</code></pre>
<p>Функция <code>lua_gettop</code> возвращает число элементов в стеке, которое также является индексом верхнего элемента. Функция <code>lua_settop</code> устанавливает вершину (то есть количество элементов в стеке) на заданное значение. Если предыдущая вершина была выше новой, то функция отбрасывает с вершины эти лишние значения. В противном случае она заталкивает в стек необходимое количество nil для получения заданного размера. В частности, <code>lua_settop(L,0)</code> очищает весь стек. В функции <code>lua_settop</code> вы также можете использовать отрицательные индексы. Используя данное средство, API предоставляет следующий макрос, который выталкивает из стека <code>n</code> элементов:</p>
<pre><code>#define lua_pop(L,n) lua_settop(L, -(n) - 1)</code></pre>
<p>Функция <code>lua_pushvalue</code> заталкивает в стек копию элемента с заданным индексом; <code>lua_remove</code> удаляет элемент с заданным индексом, сдвигая вниз все элементы поверх данной позиции, чтобы заполнить разрыв; <code>lua_insert</code> перемещает элемент с вершины стека в заданную позицию, сдвигая вверх все элементы над данной позицией, чтобы освободить место; <code>lua_replace</code> выталкивает значение с вершины стека и устанавливает его как значение элемента с заданным индексом, ничего при этом не перемещая; наконец, <code>lua_copy</code> копирует значение одного индекса в значение другого, не изменяя исходное значение. Обратите внимание, что следующие операции влияют лишь на пустой стек:</p>
<pre><code>lua_settop(L, -1); /* устанавливает текущее значение вершины стека */
lua_insert(L, -1); /* помещает элемент на вершину стека */
lua_copy(L, x, x); /* копирует элемент на его собственную позицию */</code></pre>
<p>Программа в листинге 25.3 использует <code>stackDump</code> (определенную в листинге 25.2) для иллюстрации этих операций над стеком.</p>
<p><strong>Листинг 25.3.</strong> Пример операций над стеком</p>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;lua.h&quot;
#include &quot;lauxlib.h&quot;

static void stackDump (lua_State *L) {
  &lt;как в листинге 25.2&gt;
  }

int main (void) {
  lua_State *L = luaL_newstate();

  lua_pushboolean(L, 1);
  lua_pushnumber(L, 10);
  lua_pushnil(L);
  lua_pushstring(L, &quot;hello&quot;);

  stackDump(L);
                   /* true   10    nil    &#39;hello&#39; */
  lua_pushvalue(L, -4); stackDump(L);
                   /* true   10    nil    &#39;hello&#39;   true */
  lua_replace(L, 3); stackDump(L);
                   /* true   10    true   &#39;hello&#39; */
  lua_settop(L, 6); stackDump(L);
                   /* true   10    true   &#39;hello&#39;   nil   nil */
  lua_remove(L, -3); stackDump(L);
                   /* true   10    true    nil      nil */
  lua_settop(L, -5); stackDump(L);
                   /* true */

  lua_close(L);
  return 0;
}</code></pre>
<h3 id="Chapter25.xhtml#sigil_toc_id_192">25.3. Обработка ошибок в C API</h3>
<p>Все структуры в Lua являются динамическими: они растут по мере необходимости и уменьшаются в размере, когда это осуществимо. Это означает, что в Lua постоянно присутствует возможность сбоя при выделении памяти. С этим может столкнуться практически каждая операция. Более того, многие операции могут вызвать и другие ошибки; например, обращение к глобальной переменной может привести к срабатыванию метаметода <code>__index</code>, который при этом может выбросить ошибку. Наконец, операции, которые выделяют память, со временем приводят к срабатыванию сборщика мусора, который может вызвать финализаторы, которые также могут выбросить ошибки. Короче говоря, подавляющее большинство функций в Lua API может привести к ошибкам.</p>
<p>Вместо использования кодов ошибок для каждой операции в своем API, Lua использует исключения для уведомления об ошибках. В отличие от C++ или Java, язык С не содержит механизм обработки исключений. Чтобы обойти данное ограничение, Lua использует функцию <code>setjmp</code> из С, которая позволяет получить механизм, похожий на обработку исключений. Поэтому большинство функций API может выбросить ошибку (то есть вызвать <code>longjmp</code>) вместо возврата управления.</p>
<p>Когда мы пишем библиотечный код (то есть функции C, которые будут вызваны из Lua), использование <code>longjmp</code> почти так же удобно, как и использование настоящих средств обработки исключений, поскольку Lua отлавливает любую возникающую ошибку. Когда мы пишем прикладной код (то есть код С, который вызывает Lua), то мы должны обеспечить способ для перехвата подобных ошибок.</p>
<h4 id="Chapter25.xhtml#sigil_toc_id_193">Обработка ошибок в прикладном коде</h4>
<p>Когда ваше приложение вызывает функции из Lua API, оно подвержено ошибкам. Как мы только что обсуждали, Lua обычно сообщает об этих ошибках посредством функции <code>longjmp</code>. Однако, если нет соответствующего вызова <code>setjmp</code>, то интерпретатор не может выполнить и <code>longjmp</code>. В этом случае любая ошибка в API приводит к тому, что Lua вызывает паническую функцию <strong>(panic function)</strong>, и если управление из этой функции возвращается, то происходит выход из приложения. Вы можете задать свою паническую функцию при помощи <code>lua_atpanic</code>, но такая функция мало что может сделать.</p>
<p>Чтобы правильно обрабатывать ошибки в вашем прикладном коде, вы должны вызывать ваш код через Lua, так как в этом случае он может установить подходящий контекст для перехвата ошибок (то есть он выполнит ваш код в контексте <code>setjmp</code>). Точно так же, как мы можем запускать код Lua в защищенном режиме при помощи <code>pcall</code>, мы можем выполнять код С посредством <code>lua_pcall</code>. Точнее, мы запаковываем код С в функцию и вызываем эту функцию через Lua, используя <code>lua_pcall</code>. (Мы подробно обсудим, как вызывать функции С из Lua в главе 27.) С такой настройкой ваш код С будет выполнен в защищенном режиме. Даже в случае ошибки выделения памяти <code>lua_pcall</code> возвращает соответствующий код ошибки, оставляя интерпретатор в рабочем состоянии.</p>
<h4 id="Chapter25.xhtml#sigil_toc_id_194">Обработка ошибок в библиотечном коде</h4>
<p>Lua — это <em>безопасный</em> язык. Это значит, что не зависимо от того, что вы пишите на Lua, и насколько неправильно вы это пишите, вы всегда можете понять поведение программы, не выходя за рамки самого Lua. Более того, ошибки тоже обнаруживаются и объясняются в рамках Lua. Для контраста сравните с С, где поведение многих неправильно написанных программ может быть объяснено лишь в рамках используемого оборудования (например, места ошибок в C заданы как адреса команд).</p>
<p>Когда вы добавляете функцию С к Lua, вы нарушаете эту безопасность. Например, такая функция, как <code>роке</code>, которая записывает произвольный байт по произвольному адресу памяти, может привести ко всем видам повреждения данных в памяти. Вы должны стремиться к тому, чтобы ваши дополнительные компоненты были безопасны для Lua и обеспечивали хорошую обработку ошибок.</p>
<p>Как мы ранее обсуждали, программы С должны задавать свою обработку ошибок посредством <code>lua_pcall</code>. Тем не менее, когда вы пишете библиотечные функции для Lua, им обычно не требуется обрабатывать ошибки. Ошибки, выброшенные библиотечной функцией, будут пойманы либо при помощи <code>pcall</code> в Lua, либо при помощи <code>lua_pcall</code> в прикладном коде. Поэтому, когда функция в библиотеке С обнаруживает ошибку, она может просто вызвать <code>lua_error</code> (или, что еще лучше, — <code>luaL_error</code>, которая форматирует сообщение об ошибке и затем вызывает <code>lua_error</code>). Функция <code>lua_error</code> очищает все, что нужно очистить в Lua, и перепрыгивает обратно к защищенному вызову, с которого начиналось то выполнение, передавая при этом сообщение об ошибке.</p>
<h3 id="Chapter25.xhtml#sigil_toc_id_195">Упражнения</h3>
<p><strong>Упражнение 25.1.</strong> Скомпилируйте и запустите простой автономный интерпретатор Lua (листинг 25.1).</p>
<p><strong>Упражнение 25.2.</strong> Предположим, что стек пустой. Каким будет его содержимое после следующей последовательности вызовов?</p>
<pre><code>lua_pushnumber(L, 3.5);
lua_pushstring(L, &quot;hello&quot;);
lua_pushnil(L);
lua_pushvalue(L, -2);
lua_remove(L, 1);
lua_insert(L, -2);</code></pre>
<p><strong>Упражнение 25.3.</strong> Используйте простой автономный интерпретатор Lua (листинг 25.1) и функцию <code>stackDump</code> (листинг 25.2), чтобы проверить ваш ответ к предыдущему упражнению.</p>
<p><span id="Chapter26.xhtml"></span></p>
<h2>ГЛАВА 26</h2>
<h2 id="Chapter26.xhtml#sigil_toc_id_196">Расширение вашего приложения</h2>
<p>Важной областью применения Lua является его использование в качестве <em>конфигурационного</em> языка. В этой главе мы покажем, как можно использовать Lua для конфигурирования программы, начав с простого примера, и развивая его для выполнения все более сложных задач.</p>
<h3 id="Chapter26.xhtml#sigil_toc_id_197">26.1. Основы</h3>
<p>В качестве нашей первой задачи давайте представим простой конфигурационный сценарий: у вашей программы С есть окно, и вы хотите иметь возможность задавать начальный размер окна. Ясно, что для такой простой задачи существуют и более простые решения, чем Lua, например, переменные окружения или файлы с парами имя-значение. Но даже используя простой текстовый файл, вам как-то нужно его разбирать; поэтому вы решаете использовать конфигурационный файл Lua (то есть простой текстовый файл, который является программой Lua). В простейшей форме этот текстовый файл может содержать, например, следующие строки:</p>
<pre><code>-- задает размер окна
width = 200
height = 300</code></pre>
<p>Теперь вы должны использовать Lua API, чтобы заставить Lua разобрать этот файл, и затем получить значения глобальных переменных <code>width</code> и <code>height</code>. Функция <code>load</code> из листинга 26.1 выполняет эту работу. Эта функция предполагает, что вы уже создали состояние Lua, следуя увиденному в предыдущей главе. Она вызывает <code>luaL_loadfile</code> для загрузки куска из файла <code>fname</code> и затем вызывает <code>lua_pcall</code> для запуска скомпилированного куска. В случае ошибок (например, синтаксических ошибок в вашем конфигурационном файле) эти функции заталкивают сообщение об ошибке в стек и возвращают ненулевой код ошибки; затем наша программа использует <code>lua_tostring</code> с индексом -1 для получения сообщения с вершины стека. (Мы определили функцию <code>error</code> в разделе 25.1.)</p>
<p><strong>Листинг 26.1.</strong> Получение пользовательской информации из конфигурационного файла</p>
<pre><code>void load (lua_State *L, const char *fname, int *w, int *h) {
  if (luaL_loadfile(L, fname) || lua_pcall(L, 0, 0, 0))
    error(L, &quot;cannot run config. file: %s&quot;, lua_tostring(L, -1));
  lua_getglobal(L, &quot;width&quot;);
  lua_getglobal(L, &quot;height&quot;);
  if (!lua_isnumber(L, -2))
    error(L, &quot;&#39;width&#39; should be a number\n&quot;);
  if (!lua_isnumber(L, -1))
    error(L, &quot;&#39;height&#39; should be a number\n&quot;);
  *w = lua_tointeger(L, -2);
  *h = lua_tointeger(L, -1);
}</code></pre>
<p>После выполнения этого куска программе нужно получить значения глобальных переменных. Для этого она дважды вызывает <code>lua_getglobal</code>, чьим единственным параметром (кроме вездесущего <code>lua_state</code>) является имя переменной. Каждый такой вызов заталкивает соответствующее глобальное значение в стек, поэтому ширина окна будет по индексу -2, а высота по индексу -1 (на вершине). (Поскольку стек ранее был пуст, вы также можете индексировать с основания стека, то есть использовать 1 для первого значения и 2 для второго. Однако, индексируя с вершины, вашему коду не нужно проверять, что стек пуст.) Далее наш пример использует <code>lua_isnumber</code>, чтобы проверить каждое значение на соответствие числу. Затем она вызывает <code>lua_tointeger</code> для преобразования таких значений в целые числа, назначая их на свои соответственные позиции.</p>
<p>Стоило ли использовать Lua для этой задачи? Как я сказал ранее, для такой простой задачи простой файл, в котором только два числа, вероятно использовать проще, чем файл Lua. Но даже в этом случае применение Lua дает некоторые преимущества. Во-первых, Lua обрабатывает за вас все синтаксические детали; ваш конфигурационный файл может даже содержать комментарии! Во-вторых, у пользователя появляется возможность выполнить с его помощью сложное конфигурирование. Например, этот скрипт может запросить у пользователя какую-то информацию или взять значение из переменной окружения для выбора подходящего размера:</p>
<pre><code>-- конфигурационный файл
if getenv(&quot;DISPLAY&quot;) == &quot;:0.0&quot; then
  width = 300; height = 300
else
  width = 200; height = 200
end</code></pre>
<p>Даже в таких простых конфигурационных сценариях трудно предвидеть, что может понадобиться пользователям; но пока скрипт определяет эти две переменные, ваша программа на С будет работать без изменений.</p>
<p>Окончательным доводом в пользу применения Lua будет то, что теперь с его помощью можно легко добавлять новые конфигурационные средства к вашей программе; эта легкость формирует подход, который приводит к более гибким программам.</p>
<h3 id="Chapter26.xhtml#sigil_toc_id_198">26.2. Работа с таблицами</h3>
<p>Давайте приспособим этот подход: теперь мы также хотим кофигурировать цвет фона для этого окна. Допустим, окончательная спефикация цвета составлена из трех чисел, каждое из которых является цветовым компонентом RGB. Обычно в С эти числа являются целыми и лежат в некотором диапазоне, например [0, 255]. В Lua, поскольку все числа являются вещественными, мы можем использовать более естественный диапазон [0, 1].</p>
<p>Наивным подходом было бы попросить пользователя задавать каждый компонент в отдельной глобальной переменной:</p>
<pre><code>-- конфигурационный файл
width = 200
height = 300
background_red = 0.30
background_green = 0.10
background_blue = 0</code></pre>
<p>У такого подхода два недостатка: он слишком громоздкий (настоящим программам могут понадобиться десятки цветов для фона окна, основного текста окна, фона меню и т. п.) и нет способа заранее определить распространенные цвета, чтобы пользователь мог потом просто написать <code>background=WHITE</code>. Во избежание этих недостатков, для представления цвета мы воспользуемся таблицей:</p>
<pre><code>background = {r=0.30, g=0.10, b=0}</code></pre>
<p>Применение таблиц придает вашему скрипту более понятную структуру; теперь пользователю (или приложению) станет легко предопределять цвета для дальнейшего использования в конфигурационном файле:</p>
<pre><code>BLUE = {r=0, g=0, b=1.0}
&lt;определения других цветов&gt;
background = BLUE</code></pre>
<p>Для получения этих значений в С мы можем поступить следующим образом:</p>
<pre><code>lua_getglobal(L, &quot;background&quot;);
if (!lua_istable(L, -1))
error(L, &quot;&#39;background&#39; is not a table&quot;);

red = getcolorfield(L, &quot;r&quot;);
green = getcolorfield(L, &quot;g&quot;);
blue = getcolorfield(L, &quot;b&quot;);</code></pre>
<p>Сначала мы получаем значение глобальной переменной <code>background</code> и убеждаемся в том, что это таблица, а затем используем <code>getcolorfield</code> для получения каждого компонента цвета.</p>
<p>Конечно, функция <code>getcolorfield</code> — это не часть API; мы должны ее определить. Мы вновь сталкиваемся с проблемой полиморфизма: может быть потенциально много версий функций <code>getcolorfield</code>, отличающихся типом ключа, типом значения, обработкой ошибок и т.д. Lua API предлагает всего одну функцию — <code>lua_gettable</code>, которая работает для всех типов. Она берет позицию таблицы в стеке, выталкивает ключ из стека и заталкивает в стек соответствующее значение. Наша закрытая <code>getcolorfield</code>, определенная в листинге 26.2, считает, что таблица находится на вершине стека, поэтому после заталкивания ключа в стек посредством <code>lua_pushstring</code> таблица будет находиться по индексу -2. Перед возвратом управления функция <code>getcolorfield</code> выталкивает из стека полученное значение, оставляя стек в том же состоянии, в котором он был перед этим вызовом.</p>
<p><strong>Листинг 26.2.</strong> Отдельная реализация <span class="code">getcolorfield</span></p>
<pre><code>#define MAX_COLOR 255

/* допустим, что таблица находится на вершине стека */
int getcolorfield (lua_State *L, const char *key) {
  int result;
  lua_pushstring(L, key); /* выталкивает key */
  lua_gettable(L, -2); /* получает background[key] */
  if (!lua_isnumber(L, -1))
    error(L, &quot;invalid component in background color&quot;);
  result = (int)(lua_tonumber(L, -1) * MAX_COLOR);
  lua_pop(L, 1); /* удаляет число */
  return result;
}</code></pre>
<p>Поскольку индексирование таблицы при помощи строкового ключа очень распространено, Lua 5.1 ввел специализированную версию <code>lua_gettable</code> для этого случая: <code>lua_getfield</code>. Используя эту функцию, мы можем переписать следующие две строки:</p>
<pre><code>lua_pushstring(L, key);
lua_gettable(L, -2); /* получает background[key] */</code></pre>
<p>как</p>
<pre><code>lua_getfield(L, -1, key);</code></pre>
<p>(Поскольку мы не заталкиваем строку в стек, индекс таблицы по-прежнему равен -1 в момент вызова <code>lua_getfield</code>.)</p>
<p>Мы расширим наш пример еще немного и введем названия цветов для пользователя. Пользователь по-прежнему сможет использовать таблицы цветов, но он также сможет использовать предопределенные названия цветов для наиболее распространенных цветов. Для реализации данной возможности нам понадобится таблица цветов в нашей программе С:</p>
<pre><code>struct ColorTable {
  char *name;
  unsigned char red, green, blue;
} colortable[] = {
  {&quot;WHITE&quot;, MAX_COLOR, MAX_COLOR, MAX_COLOR},
  {&quot;RED&quot;, MAX_COLOR, 0, 0},
  {&quot;GREEN&quot;, 0, MAX_COLOR, 0},
  {&quot;BLUE&quot;, 0, 0, MAX_COLOR},
  &lt;другие цвета&gt;
  {NULL, 0, 0, 0} /* граничная метка */
};</code></pre>
<p>Наша реализация создаст глобальные переменные с названиями цветов и проинициализирует эти переменные при помощи цветовых таблиц. Результат такой же, как если бы пользователь добавил следующие строки в свой скрипт:</p>
<pre><code>WHITE = {r=1.0, g=1.0, b=1.0}
RED   = {r=1.0, g=0, b=0}
&lt;другие цвета&gt;</code></pre>
<p>Для задания полей таблицы мы определим вспомогательную функцию <code>setcolorfield</code>; она заталкивает в стек индекс и значение поля, а затем вызывает <code>lua_settable</code>:</p>
<pre><code>/* предполагает, что таблица находится на вершине стека */
void setcolorfield (lua_State *L, const char *index, int value) {
lua_pushstring(L, index); /* key */
lua_pushnumber(L, (double)value / MAX_COLOR); /* value */
lua_settable(L, -3);
}</code></pre>
<p>Подобно другим функциям API <code>lua_settable</code> работает для множества различных типов, поэтому она берет все свои операнды из стека. Она берет индекс таблицы в качестве аргумента и выталкивает ключ и значение. Функция <code>setcolorfield</code> предполагает, что перед вызовом таблица находится на вершине стека (индекс -1); после заталкивания индекса и значения в стек таблица будет находиться по индексу -3.</p>
<p>Lua 5.1 также ввел специализированную версию <code>lua_settable</code> для строковых ключей под названием <code>lua_setfield</code>. Используя эту новую функцию, мы можем переписать наше предыдущее определение <code>setcolorfield</code> следующим образом:</p>
<pre><code>void setcolorfield (lua_State *L, const char *index, int value) {
  lua_pushnumber(L, (double)value / MAX_COLOR);
  lua_setfield(L, -2, index);
}</code></pre>
<p>Следующая функция, <code>setcolor</code>, определяет один цвет. Она создает таблицу, устанавливает соответствующие поля и присваивает эту таблицу соответствующей глобальной переменной:</p>
<pre><code>void setcolor (lua_State *L, struct ColorTable *ct) {
  lua_newtable(L);                     /* создает таблицу */
  setcolorfield(L, &quot;r&quot;, ct-&gt;red);      /* table.r = ct-&gt;r */
  setcolorfield(L, &quot;g&quot;, ct-&gt;green);    /* table.g = ct-&gt;g */
  setcolorfield(L, &quot;b&quot;, ct-&gt;blue);     /* table.b = ct-&gt;b */
  lua_setglobal(L, ct-&gt;name);          /* &#39;name&#39; = table */
}</code></pre>
<p>Функция <code>lua_newtable</code> создает пустую таблицу и заталкивает ее в стек; вызовы <code>setcolorfield</code> задают поля этой таблицы; наконец, <code>lua_setglobal</code> выталкивает таблицу из стека и устанавливает ее как значение глобальной переменной с заданным именем.</p>
<p>Используя вышеуказанные функции, следующий цикл регистрирует все цвета для конфигурационного скрипта:</p>
<pre><code>int i = 0;
while (colortable[i].name != NULL)
  setcolor(L, &amp;colortable[i++]);</code></pre>
<p>Помните, что приложение должно выполнить этот цикл до запуска скрипта.</p>
<p><strong>Листинг 26.3.</strong> Цвета как строки или таблицы</p>
<pre><code>lua_getglobal(L, &quot;background&quot;);
if (lua_isstring(L, -1)) { /* значение является строкой? */
  const char *name = lua_tostring(L, -1); /* получает строку */
  int i; /* ищет в таблице цветов */
  for (i = 0; colortable[i].name != NULL; i++) {
    if (strcmp(colorname, colortable[i].name) == 0)
      break;
  }
if (colortable[i].name == NULL) /* строка не найдена? */
  error(L, &quot;invalid color name (%s)&quot;, colorname);
else { /* использует colortable[i] */
  red = colortable[i].red;
  green = colortable[i].green;
  blue = colortable[i].blue;
  }
} else if (lua_istable(L, -1)) {
  red = getcolorfield(L, &quot;r&quot;);
  green = getcolorfield(L, &quot;g&quot;);
  blue = getcolorfield(L, &quot;b&quot;);
} else
    error(L, &quot;invalid value for &#39;background&#39;&quot;);</code></pre>
<p>Листинг 26.3 показывает другой вариант реализации именованных цветов. Вместо глобальных переменных пользователь может обозначать имена цветов при помощи строк, записывая настройки в виде <code>background=&quot;BLUE</code>&quot;. Таким образом, <code>background</code> может быть как таблицей, так и строкой. При подобном подходе приложению не нужно что-либо делать перед запуском пользовательского скрипта. Вместо этого для получения цвета нужно выполнить немного больше работы. Когда скрипт получает значение переменной <code>background</code>, он должен проверить, является ли тип этого значения строкой, а затем отыскать эту строку в таблице цветов.</p>
<p>Какой вариант лучше? В программах С использование строк для обозначения опций не является хорошей практикой, поскольку компилятор не может обнаружить опечатки. Однако, в Lua сообщение об ошибке в названии цвета вероятно дойдет до того, кто пишет эту конфигурационную «программу». Различие между программистом и пользователем несколько размыто; разница между ошибкой во время компиляции и ошибкой во время выполнения не столь велика.</p>
<p>Со строками значение <code>background</code> могло бы быть строкой с опечаткой; в этом случае приложение может добавить эту информацию к сообщению об ошибке. Приложение может также сравнивать строки независимо от регистра букв, так что пользователь может написать &quot;<code>white</code>&quot;, &quot;<code>WHITE</code>&quot; или даже &quot;<code>White</code>&quot;. Более того, если пользовательский скрипт небольшой, а цветов много, то было бы странно регистрировать сотни цветов (и создавать сотни таблиц и глобальных переменных), чтобы пользователь выбрал лишь некоторые из них. Со строками вы избежите данных издержек.</p>
<h3 id="Chapter26.xhtml#sigil_toc_id_199">26.3. Вызовы функций Lua</h3>
<p>Сильной стороной Lua является то, что конфигурационный файл может определять функции для вызова приложением. Например, вы можете написать приложение для построения графика функции и использовать Lua, чтобы задать эту функцию.</p>
<p>Протокол API для вызова функций прост: во-первых, вы заталкиваете функцию для вызова; во-вторых, вы заталкиваете аргументы для вызова; затем вы используете <code>lua_pcall</code> для действительного вызова функции; и, наконец, вы получаете результаты из стека.</p>
<p>В качестве примера допустим, что у нашего конфигурационного файла есть функция вроде этой:</p>
<pre><code>function f (x, y)
  return (x^2 * math.sin(y)) / (1 - x)
end</code></pre>
<p>Вы хотите на С вычислить <code>z=f(х,у)</code> для заданных <code>х</code> и <code>у</code>. При условии, что вы уже открыли библиотеку Lua и выполнили конфигурационный файл, функция <code>f</code> в листинге 26.4 инкапсулирует этот вызов.</p>
<p><strong>Листинг 26.4.</strong> Вызов функции Lua из С</p>
<pre><code>/* вызывает функцию &#39;f&#39;, определенную в Lua */
double f (lua_State *L, double x, double y) {
  int isnum;
  double z;

  /* заталкивает функции и аргументы */
  lua_getglobal(L, &quot;f&quot;); /* функция для вызова */
  lua_pushnumber(L, x);  /* заталкивает 1-ый аргумент */
  lua_pushnumber(L, y);  /* заталкивает 2-ой аргумент */

  /* производит вызов (2 аргумента, 1 результат) */
  if (lua_pcall(L, 2, 1, 0) != LUA_OK)
    error(L, &quot;error running function &#39;f&#39;: %s&quot;,
  lua_tostring(L, -1));

  /* возвращает результат */
  z = lua_tonumberx(L, -1, &amp;isnum);
  if (!isnum)
    error(L, &quot;function &#39;f&#39; must return a number&quot;);
  lua_pop(L, 1); /* выталкивает возвращенное значение */
  return z;
}</code></pre>
<p>Второй и третий аргументы <code>lua_pcall</code> — это число аргументов, которые вы передаете, и число результатов, которые вы хотите получить, соответственно. Четвертый аргумент представляет собой функцию для обработки ошибок; скоро мы это обсудим. Как и в случае с присваиваниями в Lua, вызов <code>lua_pcall</code> приводит действительное число возвращенных значений к заданному вами числу, при необходимости заталкивая значения nil или отбрасывая лишние. Перед заталкиванием результатов <code>lua_pcall</code> удаляет из стека функцию и ее аргументы. Когда функция возвращает несколько значений, первое значение заталкивается первым; например, если возвращаются три значения, то первое будет по индексу -3, а последнее по индексу -1.</p>
<p>В случае возникновения ошибки во время своего выполнения <code>lua_pcall</code> возвращает код ошибки; кроме того, она заталкивает сообщение об ошибке в стек (но по-прежнему выталкивает функцию и ее аргументы). Однако, перед заталкиванием сообщения <code>lua_pcall</code> вызывает функцию обработки сообщения, если она была задана. Для задания функции обработки сообщения используйте последний аргумент <code>lua_pcall</code>. Ноль означает, что функции обработки нет, т.е. окончательное сообщение об ошибке является при этом исходным. В противном случае этот аргумент должен быть индексом в стеке, по которому размещена функция обработки сообщения. В таких случаях обработчик должен быть помещен в стек до вызываемой функции и ее аргументов.</p>
<p>Для нормальных ошибок <code>lua_pcall</code> возвращает код ошибки <code>LUA_ERRRUN</code>. Два особых вида ошибок заслуживают отдельных кодов, поскольку они никогда не запускают обработчик сообщений. Первый вид — это ошибки выделения памяти. Для подобных ошибок <code>lua_pcall</code> всегда возвращает <code>LUA_ERRMEM</code>. Второй вид — это ошибки при выполнении самого обработчика сообщений. В этом случае нет никакого смысла заново вызывать обработчик сообщений, поэтому <code>lua_pcall</code> немедленно возвращает управление с кодом <code>LUA_ERRERR</code>. Lua 5.2 выделяет третий вид ошибок: когда финализатор выбрасывает ошибку, <code>lua_pcall</code> возвращает код <code>LUA_ERRGCMM</code> (ошибка в метаметоде сборщика мусора). Этот код обозначает, что ошибка не связана непосредственно с самим вызовом.</p>
<h3 id="Chapter26.xhtml#sigil_toc_id_200">26.4. Обобщенный вызов функции</h3>
<p>В качестве более сложного примера мы построим обертку для вызова функций Lua, используя средства <code>vararg</code> в С. Наша оберточная функция, давайте назовем ее <code>call_va</code>, принимает имя функции, которую нужно вызвать, строку, описывающую типы аргументов и результатов, затем список аргументов и, наконец, список указателей на переменные для хранения результатов; она берет на себя все тонкости API. При помощи этой функции мы можем легко переписать наш предыдущий пример следующим образом:</p>
<pre><code>call_va(L, &quot;f&quot;, &quot;dd&gt;d&quot;, x, y, &amp;z);</code></pre>
<p>Строка &quot;<code>dd&gt;d</code>&quot; означает «два аргумента типа double и один результат типа double». Этот дескриптор может использовать буквы '<code>d</code>' для типа double, '<code>i</code>' для целых чисел и '<code>s</code>' для строк; '<code>&gt;</code>' отделяет аргументы от результатов. Если функция ничего не возвращает, то '<code>&gt;</code>' необязателен.</p>
<p>Листинг 26.5 показывает реализацию функции <code>call_va</code>. Несмотря на ее общий вид, она идет тем же путем, что и наш первый пример: заталкивает функцию, заталкивает аргументы (листинг 26.6), производит вызов и получает результаты (листинг 26.7). Большая часть кода не нуждается в пояснении, но есть некоторые тонкости. Во-первых, ей не нужно проверять, что <code>func</code> является функцией; если это не так, то <code>lua_pcall</code> вызовет ошибку. Во-вторых, поскольку она заталкивает произвольное число аргументов, она должна проверять наличие свободного места на стеке. В-третьих, поскольку функция может вернуть строки, то <code>call_va</code> не может вытолкнуть результаты из стека. Это должна делать вызывающая функция после того, как она прекратит использовать получаемые время от времени строковые результаты (или после копирования их в соответственные буферы).</p>
<p><strong>Листинг 26.5.</strong> Обобщенный вызов функции</p>
<pre><code>#include &lt;stdarg.h&gt;

void call_va (lua_State *L, const char *func, const char *sig, ...) {
  va_list vl;
  int narg, nres; /* число аргументов и результатов */

  va_start(vl, sig);
  lua_getglobal(L, func); /* заталкивает функцию */

  &lt;аргументы для заталкивания (листинг 26.6)&gt;

  nres = strlen(sig); /* число ожидаемых результатов */

  if (lua_pcall(L, narg, nres, 0) != 0) /* do the call */
    error(L, &quot;error calling &#39;%s&#39;: %s&quot;, func, lua_tostring(L, -1));

  &lt;возвращенные результаты (листинг 26.7)&gt;

  va_end(vl);
}</code></pre>
<p><strong>Листинг 26.6.</strong> Выталкивание аргументов для обобщенного вызова функции</p>
<pre><code>for (narg = 0; *sig; narg++) { /* повторяет для каждого аргумента */

  /* проверяет пространство стека */
  luaL_checkstack(L, 1, &quot;too many arguments&quot;);

  switch (*sig++) {

    case &#39;d&#39;: /* аргумент типа double */
      lua_pushnumber(L, va_arg(vl, double));
      break;

    case &#39;i&#39;: /* аргумент типа int */
      lua_pushinteger(L, va_arg(vl, int));
      break;

    case &#39;s&#39;: /* аргумент типа string */
      lua_pushstring(L, va_arg(vl, char *));
      break;

    case &#39;&gt;&#39;: /* конец аргументов */
      goto endargs;

    default:
      error(L, &quot;invalid option (%c)&quot;, *(sig - 1));
  }

}
endargs:</code></pre>
<p><strong>Листинг 26.7.</strong> Получение результатов для обобщенного вызова функции</p>
<pre><code>nres = -nres; /* стековый индекс первого результата */
while (*sig) { /* повторяет для каждого результата */
  switch (*sig++) {

    case &#39;d&#39;: { /* результат типа double */
      int isnum;
      double n = lua_tonumberx(L, nres, &amp;isnum);
      if (!isnum)
        error(L, &quot;wrong result type&quot;);
      *va_arg(vl, double *) = n;
      break;
    }

    case &#39;i&#39;: { /* результат типа int */
      int isnum;
      int n = lua_tointegerx(L, nres, &amp;isnum);
      if (!isnum)
        error(L, &quot;wrong result type&quot;);
      *va_arg(vl, int *) = n;
      break;
    }

    case &#39;s&#39;: { /* результат типа string */
      const char *s = lua_tostring(L, nres);
      if (s == NULL)
        error(L, &quot;wrong result type&quot;);
      *va_arg(vl, const char **) = s;
      break;
    }

    default:
      error(L, &quot;invalid option (%c)&quot;, *(sig - 1));
  }

nres++;
}</code></pre>
<h3 id="Chapter26.xhtml#sigil_toc_id_201">Упражнения</h3>
<p><strong>Упражнение 26.1.</strong> Напишите программу С, которая читает файл Lua, содержащий определение полностью числовой функции <code>f</code>, и строит график этой функции. (Вам не нужно делать что-нибудь этакое; программа может строить график, выводя результаты при помощи астериксов ASCII ('<code>*</code>'), как мы делали в разделе 8.1.)</p>
<p><strong>Упражнение 26.2.</strong> Измените функцию <code>call_va</code> (листинг 26.5) для обработки булевых значений.</p>
<p><strong>Упражнение 26.3.</strong> Допустим, есть программа, которой необходимо следить за несколькими погодными станциями. Внутри, для представления каждой станции, она использует 4-байтовую строку, и есть конфигурационный файл, который отображает каждую такую строку в URL соответствующей станции. Конфигурационный файл Lua мог бы выполнять это отображение несколькими способами:</p>
<ul>
<li>набор глобальных переменных, по одной для каждой станции;</li>
<li>одна таблица, отображающая строковые коды в URL'ы;</li>
<li>одна функция, отображающая строковые коды в URL'ы.</li>
</ul>
<p>Обсудите плюсы и минусы каждого способа, принимая во внимание общее число станций, закономерности URL'ов (т.е. может существовать правило построения URL'ов из кодов), типы пользователей и т.д.</p>
<p><span id="Chapter27.xhtml"></span></p>
<h2>ГЛАВА 27</h2>
<h2 id="Chapter27.xhtml#sigil_toc_id_202">Вызываем С из Lua</h2>
<p>Когда мы говорим, что Lua может вызывать функции С, это не значит, что Lua может вызвать любую функцию С. (<span class="underline">Примечание</span>: Есть пакеты, которые позволяют Lua вызывать любую функцию C, но они не переносимы и не безопасны.) Как мы видели в предыдущей главе, когда С вызывает функцию Lua, ей необходимо следовать простому протоколу для передачи аргументов и получения результатов. Аналогично, при вызове функции C из Lua она должна следовать похожему протоколу. Более того, чтобы Lua мог вызвать функцию С, мы должны зарегистрировать эту функцию, то есть должны надлежащим образом передать Lua ее адрес.</p>
<p>Когда Lua вызывает функцию С, Lua использует ту же разновидность стека, какую С использует для вызова функций Lua. Функция С получает свои аргументы из стека и заталкивает свои результаты в стек.</p>
<p>Важным понятием здесь является то, что стек не является глобальной структурой; у каждой функции есть свой собственный закрытый локальный стек. Когда Lua вызывает функцию С, первый аргумент всегда будет находиться по индексу 1 этого локального стека. Даже когда функция С вызывает код Lua, который вновь вызывает эту же (или другую) функцию C, каждый из этих вызовов видит лишь свой собственный закрытый стек с первым аргументом по индексу 1.</p>
<h3 id="Chapter27.xhtml#sigil_toc_id_203">27.1. Функции С</h3>
<p>В качестве первого примера давайте рассмотрим, как реализовать упрощенную версию функции, которая возвращает синус заданного числа:</p>
<pre><code>static int l_sin (lua_State *L) {
  double d = lua_tonumber(L, 1); /* получает аргумент */
  lua_pushnumber(L, sin(d)); /* заталкивает результат */
  return 1; /* число результатов */
}</code></pre>
<p>Любая функция, зарегистрированная в Lua, должна иметь один и тот же прототип, определенный в файле <code>lua.h</code> как <code>lua_CFunction</code>:</p>
<pre><code>typedef int (*lua_CFunction) (lua_State *L);</code></pre>
<p>С точки зрения С, функция С получает в качестве своего единственного аргумента состояние Lua и возвращает целое число, равное количеству значений, которое она возвращает в стек. Поэтому функции не нужно очищать стек перед заталкиванием в него своих результатов. После возвращения функцией результатов Lua автоматически сохраняет их и очищает весь ее стек.</p>
<p>Перед тем, как мы сможем использовать эту функцию из Lua, мы должны ее зарегистрировать. Мы творим это небольшое волшебство при помощи <code>lua_</code><code>pu</code><code>shc</code><code>function</code>: она получает указатель на функцию С и создает значение типа &quot;<code>function</code>&quot;, которое представляет эту функцию внутри Lua. После регистрации функция С ведет себя внутри Lua как любая другая функция.</p>
<p>Чтобы на скорую руку проверить <code>l_sin</code>, нужно поместить ее код непосредственно в наш базовый интерпретатор (листинг 25.1) и добавить следующие строки прямо после вызова <code>luaL_openlibs</code>:</p>
<pre><code>lua_pushcfunction(L, l_sin);
lua_setglobal(L, &quot;mysin&quot;);</code></pre>
<p>Первая строка заталкивает в стек значение типа &quot;<code>function</code>&quot;, а вторая присваивает его значение глобальной переменной <code>mysin</code>. После этих изменений вы можете использовать эту новую функцию <code>mysin</code> в ваших скриптах Lua. (В следующем разделе мы рассмотрим более подходящие способы компоновки новых функций С с Lua.)</p>
<p>В более профессионально оформленной функции вычисления синуса мы должны проверять тип ее аргумента. Здесь нам поможет вспомогательная библиотека. Функция <code>luaL_checknumber</code> проверяет, действительно ли заданный аргумент является числом: в случае ошибки она выбрасывает о ней информативное сообщение; иначе она возвращает само число. Изменения в нашей функции минимальны:</p>
<pre><code>static int l_sin (lua_State *L) {
  double d = luaL_checknumber(L, 1);
  lua_pushnumber(L, sin(d));
  return 1; /* число результатов */
}</code></pre>
<p>С определением выше, если вы вызовите <code>mysin('а')</code>, то получите следующее сообщение:</p>
<pre><code>bad argument #1 to &#39;mysin&#39; (number expected, got string)</code></pre>
<p>Обратите внимание, как <code>luaL_checknumber</code> автоматически заполняет сообщение номером аргумента (<code>#1</code>), именем функции (&quot;<code>mysin</code>&quot;), ожидаемым типом параметра (<code>number</code>) и настоящим типом параметра (<code>string</code>).</p>
<p>В качестве более сложного примера давайте напишем функцию, которая возвращает содержимое заданной директории. Lua не предоставляет эту функцию в своих стандартных библиотеках, поскольку в ANSI С нет подходящей функции для этой работы. Здесь мы будем считать, что у нас POSIX-совместимая система. Наша функция (назовем ее <code>dir</code> в Lua и <code>l_dir</code> в С) получает в качестве аргумента строку с путем к директории и возвращает массив с данными этой директории. Например, вызов <code>dir(&quot;/home/lua&quot;)</code> может вернуть таблицу <code>{&quot;sre&quot;,&quot;bin&quot;,&quot;lib&quot;}</code>. В случае ошибки функция возвращает nil вместе со строкой с сообщением об ошибке. Полный код этой функции приведен в листинге 27.1. Обратите внимание на использование функции <code>luaL_checkstring</code> из вспомогательной библиотеки, которая является экивалентом <code>luaL_checknumber</code> для строк.</p>
<p>(В экстремальных условиях данная реализация <code>l_dir</code> может вызвать небольшую утечку памяти. Три функции Lua, которые она вызывает, — <code>lua_newtable</code>, <code>lua_pushstring</code> и <code>lua_settable</code>, могут дать сбой из-за нехватки памяти. Если какая-либо из этих функций даст сбой, это вызовет ошибку и прервет выполнение <code>l_dir</code>, в результате чего <code>closedir</code> не будет вызвана. Как мы обсудили ранее, для большинства программ это не является большой проблемой: если у программы заканчивается память, то лучшее, что можно сделать, — это завершить ее выполнение. Тем не менее, в главе 30 мы увидим альтернативную реализацию функции для работы с директориями, в которой данная проблема устранена.)</p>
<p><strong>Листинг 27.1.</strong> Функция для чтения содержимого директории</p>
<pre><code>#include &lt;dirent.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#include &quot;lua.h&quot;
#include &quot;lauxlib.h&quot;

static int l_dir (lua_State *L) {
  DIR *dir;
  struct dirent *entry;
  int i;
  const char *path = luaL_checkstring(L, 1);

  /* open directory */
  dir = opendir(path);
  if (dir == NULL) { /* error opening the directory? */
    lua_pushnil(L); /* return nil... */
    lua_pushstring(L, strerror(errno)); /* and error message */
    return 2; /* number of results */
  }

  /* create result table */
  lua_newtable(L);
  i = 1;
  while ((entry = readdir(dir)) != NULL) {
    lua_pushnumber(L, i++); /* push key */
    lua_pushstring(L, entry-&gt;d_name); /* push value */
    lua_settable(L, -3);
  }
  closedir(dir);
  return 1; /* table is already on top */
}</code></pre>
<h3 id="Chapter27.xhtml#sigil_toc_id_204">27.2. Продолжения</h3>
<p>При помощи <code>lua_pcall</code> и <code>lua_call</code> функция С, вызванная из Lua, может, в свою очередь, вызвать функцию Lua. Так делают некоторые функции из стандартной библиотеки: <code>table.sort</code> может вызвать функцию упорядочивания; <code>string.gsub</code> может вызвать функцию замены; <code>pcall</code> и <code>xpcall</code> вызывают функции в защищенном режиме. Если вспомнить, что главный код Lua был сам, в свою очередь, вызван из С (основной программы), то мы получаем примерно такую последовательность: С (основная программа) вызывает Lua (скрипт), который вызывает С (библиотека), который вызывает Lua (обратный вызов).</p>
<p>Обычно Lua обрабатывает эти последовательности вызовов без проблем; в конце концов, эта интеграция с C и является «визитной карточкой» языка. Тем не менее, есть одна ситуация, в которой подобное переплетение может вызвать затруднения: сопрограммы.</p>
<p>У каждой сопрограммы в Lua есть свой собственный стек, который хранит информацию об ожидающих вызовах этой сопрограммы. Точнее, стек хранит адрес возврата, параметры и локальные переменные каждого вызова. Для вызовов функций Lua интерпретатор использует подходящую структуру данных для реализации стека — <em>гибкий стек</em> <strong>(soft stack)</strong>. Однако, для вызовов функций С интерпретатор также должен использовать стек С. В конце концов, адрес возврата и локальные переменные функции С живут в стеке С.</p>
<p>У интерпретатора запросто может быть несколько гибких стеков, но у среды выполнения ANSI C есть лишь один внутренний стек. Поэтому сопрограммы в Lua не могут приостановить выполнение функции С: если в цепочке вызовов, начиная с <code>resume</code> и заканчивая соответственной <code>yield</code> есть функция С, то Lua не может сохранить состояние этой функции, чтобы восстановить его при следующем возобновлении. Рассмотрим следующий пример в Lua 5.1:</p>
<pre><code>co = coroutine.wrap(function (a)
                      return pcall(function (x)
                                     coroutine.yield(x[1])
                                     return x[3]
                                   end, a)
                    end)
print(co({10, 3, -8, 15}))
  --&gt; false    attempt to yield across metamethod/C-call boundary</code></pre>
<p>Функция <code>pcall</code> — это функция С; поэтому Lua не может приостановить ее, поскольку в ANSI С нет способа приостановить функцию С и возобновить ее позже.</p>
<p>Lua 5.2 преодолел данные трудности при помощи <em>продолжений</em> <strong>(continuation)</strong>. Lua 5.2 реализует уступку управления посредством <code>longjmp</code> тем же образом, которым он реализует ошибки. Функция <code>longjmp</code> просто отбрасывает всю информацию о функциях С в стеке C, что делает невозможным возобновление данных функций. Тем не менее, функция <code>foo</code> на C может задать продолжающую функцию <code>foo-c</code>, которая является другой функцией С, чтобы вызвать ее, когда понадобится возобновить <code>foo</code>. То есть когда интерпретатор обнаружит, что он должен возобновить <code>foo</code>, а <code>longjmp</code> выбросила запись о <code>foo</code> из стека С, то вместо этого он вызовет <code>foo-c</code>.</p>
<p>Чтобы стало понятнее, давайте рассмотрим пример: реализацию <code>pcall</code>. В Lua 5.1. у этой функции был следующий код:</p>
<pre><code>static int luaB_pcall (lua_State *L) {
  int status;
  luaL_checkany(L, 1); /* по крайней мере один параметр */
  status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
  lua_pushboolean(L, (status == 0)); /* status */
  lua_insert(L, 1); /* status является первым результатом */
  return lua_gettop(L); /* возвращает status + все результаты */
}</code></pre>
<p>Если функция, вызванная посредством <code>lua_pcall</code>, уступила управление, то возобновить <code>luaB_pcall</code> позже будет невозможно. Поэтому интерпретатор выдавал ошибку всякий раз, когда мы пытались уступить управление внутри защищенного вызова. Lua 5.2 реализует <code>pcall</code> примерно так, как показано в листинге 27.21.(<span class="underline">Примечание</span>: Настоящий код немного сложнее, чем показано здесь, поскольку у него есть некоторые общие части с <code>xpcall</code> и проверка на переполнение стека перед заталкиванием в него дополнительного результата в форме булевого значения.). Есть три отличия от версии Lua 5.1: во-первых, новая версия заменила вызов <code>lua_pcall</code> на вызов <code>lua_pcallk</code>; во-вторых, она объединила все, что делается после этого вызова в новую вспомогательную функцию <code>finishpcall</code>; третье отличие — это функция <code>pcallcont</code>, последний аргумент <code>lua_pcallk</code>, которая является продолжающей функцией.</p>
<p>Если нет никаких уступок управления, то <code>lua_pcallk</code> работает в точности как <code>lua_pcall</code>. Если есть какая-нибудь уступка управления, то все становится немного иначе. Если функция, вызванная <code>lua_pcall</code> пытается уступить управление, то Lua 5.2 вызывает ошибку, как и Lua 5.1. Однако, когда функция, вызванная <code>lua_pcallk</code>, уступает управление, то никаких ошибок нет: Lua вызывает <code>longjmp</code> и выбрасывает запись для <code>luaB_pcall</code> из стека С, но сохраняет в гибком стеке ссылку на продолжающую функцию <code>pcallcont</code>. Позже, когда интерпретатор обнаруживает, что он должен вернуться к <code>1иаВ_рса11</code> (что невозможно), он вместо этого вызывает продолжающую функцию <code>pcallcont</code>.</p>
<p>В отличие от <code>luaВ_рса11</code>, продолжающая функция <code>pcallcont</code> не может получить значение, возвращаемое <code>lua_pcallk</code>. Поэтому Lua предоставляет специальную функцию для возвращения статуса вызова: <code>lua_getctx</code>. Когда она вызвана из обычной функции Lua (что в нашем случае не происходит), <code>lua_getctx</code> возвращает <code>LUA_OK</code>. Когда она вызвана из продолжающей функции, она возвращает <code>lua_yield</code>. Продолжающая функция также может быть вызвана при некоторых ошибках; в этом случае <code>lua_getctx</code> возвращает код ошибки, который является тем самым значением, возвращаемым <code>lua_callk</code>.</p>
<p><strong>Листинг 27.2.</strong> Реализация <span class="code">pcall</span> с продолжениями</p>
<pre><code>static int finishpcall (lua_State *L, int status) {
  lua_pushboolean(L, status); /* первый результат (status) */
  lua_insert(L, 1); /* помещает первый результат в первый слот */
  return lua_gettop(L);
}

static int pcallcont (lua_State *L) {
  int status = lua_getctx(L, NULL);
  return finishpcall(L, (status == LUA_YIELD));
}

static int luaB_pcall (lua_State *L) {
  int status;
  luaL_checkany(L, 1);
  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0,
                      0, pcallcont);
  return finishpcall(L, (status == LUA_OK));
}</code></pre>
<p>Кроме статуса вызова, <code>lua_getctx</code> также может вернуть <em>контекстную информацию</em> <strong>(context information)</strong>. Пятый параметр для <code>lua_pcallk</code> — это произвольное целое число, которое можно получить через второй параметр <code>lua_getctx</code>, который является указателем на целое число. Это целочисленное значение позволяет исходной функции передавать какую-либо произвольную информацию своему продолжению напрямую. Она может передавать дополнительную информацию через стек Lua. (Наш пример не задействует эту возможность.)</p>
<p>Система продолжений Lua 5.2 — это гениальный механизм для поддержки уступки управления, но это не панацея. Некоторым функциям С может понадобиться передать слишком много контекста своим продолжениям. Примеры включают в себя <code>table.sort</code>, которая использует стек С для рекурсии, и <code>string.gsub</code>, которая должна следить за захватами и буфером для своих промежуточных результатов. Хотя их возможно переписать с поддержкой уступок управления, выигрыш от этого не стоит дополнительной сложности.</p>
<h3 id="Chapter27.xhtml#sigil_toc_id_205">27.3. Модули С</h3>
<p>Модуль Lua — это кусок кода, который определяет некоторые функции Lua и хранит их в подходящих местах, обычно как записи в таблице. Модуль С для Lua ведет себя похожим образом. Кроме определения своих функций С, он также должен определить специальную функцию, которая исполняет роль главного куска в библиотеке Lua. Эта функция должна регистрировать все функции С из модуля и хранить их в подходящих для этого местах, обычно как записи в таблице. Подобно главному кусоку Lua, эта функция также должна инициализировать все, что в модуле требует инициализации.</p>
<p>Lua получает функции С посредством данного процесса регистрации. Как только функция С представлена и сохранена в Lua, Lua вызывает ее через прямую ссылку на ее адрес (который мы передаем Lua, когда регистрируем эту функцию). Другими словами, Lua не зависит от имени функции, расположения пакета или правил видимости, чтобы вызвать ее, когда она зарегистрирована. <span>Обычно модуль С имеет одну единственную открытую (</span><code>extern</code><span>) функцию, которая является функцией для открытия этой библиотеки. Все остальные функции могут быть закрытыми — объявленными в C как статические (</span><code>static</code><span>)</span></p>
<p>Когда вы расширяете Lua с помощью функций С, разработка вашего кода в качестве модуля С будет хорошей идей, даже если вы хотите зарегистрировать лишь одну функцию: рано или поздно (обычно рано) вам понадобятся и другие функции. Как обычно, вспомогательная библиотека предлагает для этого вспомогательную функцию. Макрос <code>luaL_newlib</code> берет список функций С вместе с их соответствующими именами и регистрирует их всех внутри новой таблицы. В качестве примера предположим, что мы хотим создать библиотеку с функцией <code>l_dir</code>, которую мы определили ранее. Во-первых, мы должны определить библиотечные функции:</p>
<pre><code>static int l_dir (lua_State *L) {
  &lt;как прежде&gt;
}</code></pre>
<p>Далее мы объявляем массив со всеми функциями в модуле вместе с их соответственными именами. Этот массив содержит элементы типа <code>luaL_Reg</code>, который является структурой из двух полей: имени функции (строка) и указателя на функцию.</p>
<pre><code>static const struct luaL_Reg mylib [] = {
  {&quot;dir&quot;, l_dir},
  {NULL, NULL} /* sentinel */
};</code></pre>
<p>В нашем примере есть только одна функция (<code>l_dir</code>) для объявления. Последней парой в массиве всегда является <code>{NULL,NULL}</code> для обозначения его конца. Наконец, мы объявляем главную функцию, используя <code>luaL_newlib</code>:</p>
<pre><code>int luaopen_mylib (lua_State *L) {
  luaL_newlib(L, mylib);
  return 1;
}</code></pre>
<p>Вызов <code>luaL_newlib</code> создает новую таблицу и заполняет ее парами имя-функция из массива <code>mylib</code>. При возвращении <code>luaL_newlib</code> оставляет в стеке новую таблицу, в которой она открывала библиотеку. Функция <code>luaopen_mylib</code> затем возвращает 1, чтобы вернуть эту таблицу в Lua.</p>
<p>После завершения библиотеки мы должны скомпоновать ее с интерпретатором. Наиболее удобный способ добиться этого состоит в использовании средств динамической компоновки, если ваш интерпретатор Lua поддерживает эти средства. В этом случае вы должны создать динамическую библиотеку с вашим кодом (<code>mylib.dll</code> в Windows, <code>mylib.sob</code> в Linux) и поместить ее где-нибудь в пути С. После этих шагов вы можете загрузить вашу библиотеку непосредственно из Lua при помощи <code>require</code>:</p>
<pre><code>local mylib = require &quot;mylib&quot;</code></pre>
<p>Этот вызов компонует динамическую библиотеку <code>mylib</code> с Lua, находит функцию <code>luaopen_mylib</code>, регистрирует ее как функцию С и вызывает ее, открывая тем самым модуль. (Это поведение объясняет, почему <code>luaopen_mylib</code> должна иметь тот же самый прототип, что и любая другая функция С.)</p>
<p>Динамический компоновщик должен знать имя функции <code>luaopen_mylib</code>, чтобы найти ее. Он всегда будет искать <code>luaopen_</code> с присоединенным именем модуля. Поэтому если ваш модуль называется <code>mylib</code>, эта функция должна называться <code>luaopen_mylib</code>.</p>
<p>Если ваш интерпретатор не поддерживает динамическую компоновку, то вам нужно заново скомпилировать Lua с вашей новой библиотекой. Кроме этой перекомпиляции вам понадобится какой-нибудь способ сообщить интерпретатору, что он должен открывать эту библиотеку при открытии нового состояния. Простой способ это сделать — добавить <code>luopen_mylib</code> в список стандартных библиотек для открытия с помощью <code>luaL_openlibs</code> в файл <code>linit.с</code>.</p>
<h3 id="Chapter27.xhtml#sigil_toc_id_206">Упражнения</h3>
<p><strong>Упражнение 27.1.</strong> Напишите на С функцию <code>summation</code>, которая вычисляет сумму на основе переменного количества числовых аргументов:</p>
<pre><code>print(summation())                 --&gt; 0
print(summation(2.3, 5.4))         --&gt; 7.7
print(summation(2.3, 5.4, -34))    --&gt; -26.3
print(summation(2.3, 5.4, {}))
  --&gt; stdin:1: bad argument #3 to &#39;summation&#39;
                 (number expected, got table)</code></pre>
<p><strong>Упражнение 27.2.</strong> Реализуйте функцию, эквивалентную <code>table.pack</code> из стандартной библиотеки.</p>
<p><strong>Упражнение 27.3.</strong> Напишите функцию, которая получает произвольное число параметров и возвращает их в обратном порядке:</p>
<pre><code>print(reverse(1, &quot;hello&quot;, 20))    --&gt; 20    hello    1</code></pre>
<p><strong>Упражнение 27.4.</strong> Напишите функцию <code>foreach</code>, которая принимает таблицу и функцию, а затем вызывает данную функцию для каждой пары ключ-значение в этой таблице:</p>
<pre><code>foreach({x = 10, y = 20}, print)
  --&gt; x    10
  --&gt; y    20</code></pre>
<p>(Подсказка: проверьте функцию <code>lua_next</code> в справочнике по Lua.)</p>
<p><strong>Упражнение 27.5.</strong> Перепишите функцию <code>foreach</code> из предыдущего упражнения так, чтобы вызываемая функция могла уступать управление.</p>
<p><strong>Упражнение 27.6.</strong> Создайте модуль С со всеми функциями из предыдущих упражнений.</p>
<p><span id="Chapter28.xhtml"></span></p>
<h2>ГЛАВА 28</h2>
<h2 id="Chapter28.xhtml#sigil_toc_id_207">Приемы написания функций С</h2>
<p>И официальный API, и вспомогательная библиотека предоставляют несколько механизмов для помощи в написании функций С. В этой главе мы рассмотрим механизмы для обработки массивов, обработки строк и сохранения значений Lua в С.</p>
<h3 id="Chapter28.xhtml#sigil_toc_id_208">28.1. Обработка массивов</h3>
<p>В Lua «массив» — это всего лишь название для таблицы, используемой характерным образом. Мы можем обрабатывать массивы, используя те же функции, что мы использовали для обработки таблиц, то есть <code>lua_settable</code> и <code>lua_gettable</code>. Однако, API предоставляет особые функции для обработки массивов. Первой причиной пользоваться этими дополнительными функциями является производительность: обращение к массиву посреди внутреннего цикла алгоритма (например, для сортировки) втречается довольно часто, так что любое увеличение быстродействия этой операции может значительно повлиять на быстродействие алгоритма в целом. Другой причиной является удобство: целочисленные ключи достаточно распространены, чтобы как и строковые заслужить особое обращение.</p>
<p>API предоставляет две функции для работы с массивами:</p>
<pre><code>void lua_rawgeti (lua_State *L, int index, int key);
void lua_rawseti (lua_State *L, int index, int key);</code></pre>
<p>Описание функций <code>lua_rawgeti</code> и <code>lua_rawseti</code> несколько смущает, так как оно включает два индекса: <code>index</code> указывает, где в стеке находится таблица; <code>key</code> указывает, где в этой таблице находится элемент. Вызов <code>lua_rawgeti(L,t,key)</code> эквивалентен следующей последовательности, когда <code>t</code> является положительным числом (иначе вы должны компенсировать появление нового элемента в стеке):</p>
<pre><code>lua_pushnumber(L, key);
lua_rawget(L, t);</code></pre>
<p>Вызов <code>lua_rawseti(L,t,key)</code> (опять же для положительного <code>t</code>) эквивалентен данной последовательности:</p>
<pre><code>lua_pushnumber(L, key);
lua_insert(L, -2); /* помещает &#39;key&#39; под предыдущим значением */
lua_rawset(L, t);</code></pre>
<p>Обратите внимание, что обе эти функции используют операции с прямым доступом. Они быстрее, и, кроме того, таблицы, используемые как массивы, редко используют метаметоды.</p>
<p><strong>Листинг 28.1.</strong> Функция <span class="code">mар</span> на С</p>
<pre><code>int l_map (lua_State *L) {
  int i, n;

  /* 1-ый аргумент должен быть таблицей (t) */
  luaL_checktype(L, 1, LUA_TTABLE);

  /* 2-ой аргумент должен быть функцией (f) */
  luaL_checktype(L, 2, LUA_TFUNCTION);

  n = luaL_len(L, 1); /* получает размер таблицы */

  for (i = 1; i &lt;= n; i++) {
    lua_pushvalue(L, 2); /* push f */
    lua_rawgeti(L, 1, i); /* push t[i] */
    lua_call(L, 1, 1); /* call f(t[i]) */
    lua_rawseti(L, 1, i); /* t[i] = result */
  }

  return 0; /* без результатов */
}</code></pre>
<p>В качестве конкретного примера использования этих функций листинг 28.1 реализует функцию отображения: она применяет заданную функцию ко всем элементам массива, заменяя каждый элемент результатом вызова. Этот пример также вводит три новые функции: <code>luaL_checktype</code>, <code>luaL_len</code> и <code>lua_pcall</code>.</p>
<p>Функция <code>luaL_checktype</code> (из файла <code>lauxlib.h</code>) проверяет, что заданный аргумент имеет заданный тип; в противном случае она выбрасывает ошибку.</p>
<p>Элементарная функция <code>lua_len</code> (не использованная в примере выше) эквивалентна операции '<code>#</code>'. Из-за метаметодов эта операция может вернуть объект любого вида, а не только числа; поэтому <code>lua_len</code> возвращает свой результат в стек. Функция <code>luaL_len</code> (использованная в примере и взятая из вспомогательной библиотеки) вызывает ошибку, если длина не является числом, в противном случае она возвращает длину как целое число C.</p>
<p>Функция <code>lua_call</code> выполняет незащищенный вызов. Она похожа на <code>lua_pcall</code>, но передает ошибки дальше, а не возвращает их код. Когда вы пишете главный код приложения, то вы не должны использовать <code>lua_call</code>, поскольку вам требуется ловить любые ошибки. Однако, когда вы пишете функции, использовать <code>lua_call</code> — неплохая идея; если ошибка возникнет, то мы просто оставим ее кому-нибудь, кто о ней позаботится.</p>
<h3 id="Chapter28.xhtml#sigil_toc_id_209">28.2. Обработка строк</h3>
<p>Когда функция С получает строковый аргумент из Lua, то существуют только два правила, которые она должна соблюдать: не выталкивать строку из стека во время обращения к ней и никогда не модифицировать эту строку.</p>
<p>Ситуация становится сложнее, когда функции С нужно создать строку, чтобы вернуть ее Lua. Теперь код С должен беспокоиться о выделении-высвобождении буфера, переполнениях буфера и т.п. Тем не менее, Lua API предоставляет некоторые функции, чтобы помочь с этими задачами.</p>
<p>Стандартный API обеспечивает поддержку двух самых базовых строковых операций: извлечение подстроки и конкатенация строк. При извлечении подстроки помните, что базовая операция <code>lua_pushlstring</code> получает длину строки как дополнительный аргумент. Поэтому если вы хотите передать Lua подстроку строки <code>s</code>, расположенную от позиции <code>i</code> до позиции <code>j</code> (включительно), то вам всего лишь нужно сделать это:</p>
<pre><code>lua_pushlstring(L, s + i, j - i + 1);</code></pre>
<p>В качестве примера допустим, что вам нужна функция, которая разбивает строку по заданному разделителю (одному символу) и возвращает таблицу с подстроками. Например, вызов <code>split(&quot;hi:ho:there&quot;, &quot;:&quot;)</code> должен вернуть таблицу <code>{&quot;hi&quot;, &quot;ho&quot;, &quot;there&quot;}</code>. Листинг 28.2 показывает простую реализацию этой функции. Ей не нужны дополнительные буферы и она не накладывает никаких ограничений на размер строк, которые она может обрабатывать. Обо всех буферах заботится Lua.</p>
<p><strong>Листинг 28.2.</strong> Разбиение строки</p>
<pre><code>static int l_split (lua_State *L) {
  const char *s = luaL_checkstring(L, 1);   /* субъект */
  const char *sep = luaL_checkstring(L, 2); /* разделитель */
  const char *e;
  int i = 1;

  lua_newtable(L);                          /* итоговая таблица */

  /* повторяет для каждого разделителя */
  while ((e = strchr(s, *sep)) != NULL) {
    lua_pushlstring(L, s, e-s);             /* заталкивает подстроку */
    lua_rawseti(L, -2, i++);                /* вставляет ее в таблицу */
    s = e + 1;                              /* пропускает разделитель */
  }

  /* insert last substring */
  lua_pushstring(L, s);
  lua_rawseti(L, -2, i);

  return 1;                                 /* возвращает эту таблицу */
}</code></pre>
<p>Для конкатенации строк Lua предоставляет в свом API характерную функцию под названием <code>lua_concat</code>. Она эквивалентна операции конкатенации <code>..</code> в Lua; она преобразует числа в строки и при необходимости вызывает метаметоды. Более того, она может за раз объединить более двух строк. Вызов <code>lua_concat(L, n)</code> соединит (и вытолкнет) <code>n</code> значений на вершине стека и заталкнет в нее результат.</p>
<p>Другой полезной функцией является <code>lua_pushfstring</code>:</p>
<pre><code>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</code></pre>
<p>Она несколько похожа на функцию <code>sprintf</code> из C тем, что создает строку по форматирующей строке и некоторым дополнительным аргументам. Однако, в отличие от <code>sprintf</code>, вам не нужно предоставлять буфер. Lua динамически создаст строку для вас настолько большой, насколько это необходимо. Эта функция заталкивает получившуюся строку в стек и возвращает указатель на нее. Вам не нужно беспокоиться о переполнении буфера.</p>
<p>На данный момент эта функция поддерживает только директивы для вставки следующих элементов (<span class="underline">Примечание</span>: Директива <code>%p</code> для указателей появились в Lua 5.2.):</p>
<table>
<tbody>
<tr class="odd">
<td><code>%s</code> строка, завершенная нуль-символом<br />
<code>%d</code> целое число (integer)<br />
<code>%f</code> число Lua (double)<br />
<code>%p</code> указатель<br />
<code>%c</code> целое число (integer) как символ<br />
<code>%%</code> символ '%'</td>
</tr>
</tbody>
</table>
<p>Никакие модификаторы, такие как ширина или точность, ей не поддерживаются.</p>
<p>И <code>lua_concat</code>, и <code>lua_pushfstring</code> полезны, когда мы хотим соединить только несколько строк. Однако, если нам нужно соединить много строк (или символов) вместе, то делать это по одному за раз может быть довольно неэффективно, как мы видели в разделе 11.6. В этом случае мы можем использовать буферные средства, предоставленные вспомогательной библиотекой.</p>
<p>При более простом варианте применения буферные средства работают с двумя функциями: одна дает вам буфер любого размера, куда вы можете писать свою строку; другая преобразует буфер в строку Lua (<span class="underline">Примечание</span>: Эти две функции появились в Lua 5.2). Листинг 28.3 демонстрирует использование этих функций при помощи реализации функции <code>string.upper</code> прямо из исходного файла <code>lstrlib.c</code>. Первым шагом для использования буфера из вспомогательной библиотеки является объявление переменной с типом <code>luaL_Buffer</code>. Следующим шагом является вызов <code>luaL_buffinitsize</code> для получения указателя на буфер с заданным размером; затем вы можете свободно использовать этот буфер для создания своей строки. Последний шаг — это вызов <code>luaL_pushresultsize</code> для преобразования содержимого буфера в новую строку Lua на вершине стека. Размер в этом втором вызове — это окончательный размер строки. (Часто, как в нашем примере, этот размер равен размеру буфера, но он может быть меньше. Если вы не знаете точный размер получающейся строки, но знаете, что ее размер ограничен, то вы можете обезопасить себя, выделив буфер большего размера.)</p>
<p><strong>Листинг 28.3.</strong> Функция <span class="code">string.upper</span></p>
<pre><code>static int str_upper (lua_State *L) {
size_t l;
size_t i;
luaL_Buffer b;
const char *s = luaL_checklstring(L, 1, &amp;l);
char *p = luaL_buffinitsize(L, &amp;b, l);
for (i = 0; i &lt; l; i++)
  p[i] = toupper(uchar(s[i]));
luaL_pushresultsize(&amp;b, l);
return 1;
}</code></pre>
<p>Обратите внимание, что функция <code>luaL_pushresultsize</code> не получает состояние Lua в качестве своего первого аргумента. После инициализации буфер хранит ссылку на состояние, поэтому нам не нужно передавать его при вызове остальных функций для работы с буферами.</p>
<p>Мы также можем использовать эти буферы не зная максимальной длины получаемой строки. Листинг 28.4 показывает упрощенную реализацию функции <code>table.concat</code>. В этой функции мы сперва вызываем <code>luaL_buffinit</code> для инициализации буфера. Затем мы добавляем в буфер элементы один за другим, в этом случае используя функцию <code>luaL_addvalue</code>. Наконец, <code>luaL_pushresult</code> освобождает буфер и помещает итоговую строку на вершину стека.</p>
<p><strong>Листинг 28.4.</strong> Упрощенная реализация <span class="code">table.concat</span></p>
<pre><code>static int tconcat (lua_State *L) {
  luaL_Buffer b;
  int i, n;
  luaL_checktype(L, 1, LUA_TTABLE);
  n = luaL_len(L, 1);
  luaL_buffinit(L, &amp;b);
  for (i = 1; i &lt;= n; i++) {
    lua_rawgeti(L, 1, i); /* get string from table */
    luaL_addvalue(b); /* add it to the buffer */
  }
  luaL_pushresult(&amp;b);
  return 1;
}</code></pre>
<p>Вспомогательная библиотека предоставляет несколько функций для добавления значений к буферу: функция <code>luaL_addvalue</code> добавляет строку Lua, которая находится на вершине стека; функция <code>luaL_addlstring</code> добавляет строки с заданной длиной; функция <code>luaL_addstring</code> добавляет строку, завершенную нуль-символом, и функция <code>luaL_addchar</code> добавляет одиночные символы. Эти функции имеют следующие прототипы:</p>
<pre><code>void luaL_buffinit   (lua_State *L, luaL_Buffer *B);
void luaL_addvalue   (luaL_Buffer *B);
void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);
void luaL_addstring  (luaL_Buffer *B, const char *s);
void luaL_addchar    (luaL_Buffer *B, char c);
void luaL_pushresult (luaL_Buffer *B);</code></pre>
<p>Когда вы используете буфер библиотеки <code>auxlib</code>, вам нужно учитывать один момент. После инициализации буфера он хранит некоторые промежуточные результаты в стеке Lua. Поэтому вы не можете предполагать, что вершина стека останется там, где она была перед тем, как вы начали использовать буфер. Более того, хотя вы можете использовать стек для других задач во время пользования буфером, счетчик заталкиваний-выталкиваний при каждом пользовании должен быть сбалансирован всякий раз, когда вы обращаетесь к буферу. Исключением из этого правила является функция <code>luaL_addvalue</code>, которая предполагает, что строка, которую надо добавить к буферу, была помещена на вершину стека.</p>
<h3 id="Chapter28.xhtml#sigil_toc_id_210">28.3. Хранение состояния в функциях С</h3>
<p>Часто функциям С нужно хранить какие-нибудь нелокальные данные, то есть данные, которые переживут вызвавшую их функцию. В С мы обычно используем глобальные (<code>extern</code>) или статические (<code>static</code>) переменные для этой цели. Однако, когда вы пишете библиотечные функции для Lua, то использование глобальных или статических переменных — не очень хороший подход. Во-первых, вы не можете хранить произвольное значение Lua в переменной С. Во-вторых, библиотека, которая использует такие переменные, не будет корректно работать с несколькими состояниями Lua.</p>
<p>У функции Lua есть два основных места хранения нелокальных данных: глобальные переменные и нелокальные переменные. С API также предоставляет два основных места для хранения нелокальных данных: реестр и верхние значения.</p>
<p><em>Реестр</em> — это глобальная таблица, к которой может обратиться только код С.(<span class="underline">Примечание</span>: На самом деле к реестру можно обратиться и из Lua при помощи функции из отладочной библиотеки <code>debug.getregistry</code>.) Обычно реестр используется для хранения данных, которые будут использоваться сразу несколькими модулями. Если вам нужно сохранять данные только для вашего модуля или функции, то вы должны использовать верхние значения.</p>
<h4 id="Chapter28.xhtml#sigil_toc_id_211">Реестр</h4>
<p>Реестр всегда расположен по <em>псевдоиндексу</em>, чье значение определяется <code>LUA_REGISTRYINDEX</code>. Псевдоиндекс похож на индекс в стеке, за исключением того, что связанные с ним значения находятся не в стеке. Большинство функций в Lua API, которые принимают индексы в качестве аргументов, также принимают и псевдоиндексы — за исключением тех функций, которые управляют стеком, например, <code>lua_remove</code> и <code>lua_insert</code>. Например, чтобы получить значение, хранящееся в реесте с ключом &quot;<code>Key</code>&quot;, мы можем использовать следующий вызов:</p>
<pre><code>lua_getfield(L, LUA_REGISTRYINDEX, &quot;Key&quot;);</code></pre>
<p>Реестр — это обычная таблица Lua. Соответственно, вы можете индексировать ее любым значением Lua, кроме nil. Однако, поскольку у всех модулей С один и тот же реестр, во избежание конфликтов вы должны с осторожностью выбирать значения для использования в качестве ключей. Строковые ключи особенно удобны, когда вы хотите разрешить другим независимым библиотекам обращаться к вашим данным, поскольку все, что им нужно знать, — это имя ключа. Для таких ключей не существует полностью безопасного метода выбора ключей, но есть некоторые хорошие правила, например, не использовать распространенные имена и начинать ваши имена с имени библиотеки или чего-то вроде этого. (Префиксы вроде <code>lua</code> или <code>lualib</code> не рекомендуются.)</p>
<p>Вы никогда не должны использовать числа в качестве ключей реестра, поскольку подобные ключи зарезервированы для <em>системы ссылок</em> <strong>(reference system)</strong>. Эта система состоит из пары функций во вспомогательной библиотеке, которые позволяют вам хранить значения в таблице, не беспокоясь о создании уникальных имен. Функция <code>luaL_ref</code> создает новые ссылки:</p>
<pre><code>int r = luaL_ref(L, LUA_REGISTRYINDEX);</code></pre>
<p>Данный вызов выталкивает значение из стека, сохраняет его в таблице с новым целочисленным ключом и возвращает этот ключ. Такой ключ мы называем <em>ссылкой</em> <strong>(reference)</strong>.</p>
<p>Как следует из названия, мы пользуемся ссылками в основном тогда, когда нам нужно хранить ссылку на значение Lua внутри структуры С. Как мы уже видели, мы никогда не должны хранить указатели на строки Lua вне функции С, которая их возвратила. Более того, Lua даже не предлагает указатели на другие объекты, такие как таблицы или функции. Поэтому мы не можем ссылаться на объекты Lua через указатели. Вместо этого, когда нам требуются такие указатели, мы создаем ссылки и храним их в С.</p>
<p>Чтобы затолкать значение, связанное с ссылкой <code>r</code>, в стек, мы просто пишем следующее:</p>
<pre><code>lua_rawgeti(L, LUA_REGISTRYINDEX, r);</code></pre>
<p>Наконец, чтобы высвободить и значение, и ссылку, мы вызываем <code>luaL_unref</code>:</p>
<pre><code>luaL_unref(L, LUA_REGISTRYINDEX, r);</code></pre>
<p>После этого вызова новый вызов <code>luaL_ref</code> может снова вернуть эту ссылку.</p>
<p>Система ссылок трактует nil как особый случай. Каждый раз, когда мы вызываем <code>luaL_ref</code> для значения nil, вместо создания новой ссылки она возвращает ссылку на константу <code>lua_refnil</code>. Следующий вызов ничего не делает:</p>
<pre><code>luaL_unref(L, LUA_REGISTRYINDEX, LUA_REFNIL);</code></pre>
<p>А этот вызов заталкивает nil, как и ожидалось:</p>
<pre><code>lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_REFNIL);</code></pre>
<p>Система ссылок также определяет константу <code>LUA_NOREF</code>, которая является целым числом, отличным от любой действующей ссылки. Она удобна, чтобы помечать ссылки как недействительные.</p>
<p>Другим безопасным методом создания ключей в реестре является использование в качестве ключа адреса статической переменной в вашем коде: компоновщик позаботится о том, чтобы этот адрес будет уникальным среди всех библиотек. Для использования данного варианта вам понадобится функция <code>lua_pushlightuserdata</code>, которая заталкивает в стек Lua значение, представляющее указатель С. Следующий код показывает, как хранить и возвращать строку из реестра при помощи этого метода:</p>
<pre><code>/* переменная с уникальным адресом */
static char Key = &#39;k&#39;;

/* хранит строку */
lua_pushlightuserdata(L, (void *)&amp;Key); /* заталкивает адресс */
lua_pushstring(L, myStr); /* заталкивает значение */
lua_settable(L, LUA_REGISTRYINDEX); /* registry[&amp;Key] = myStr */

/* возвращает строку */
lua_pushlightuserdata(L, (void *)&amp;Key); /* заталкивает адрес */
lua_gettable(L, LUA_REGISTRYINDEX); /* возвращает значение */
myStr = lua_tostring(L, -1); /* преобразует его в строку */</code></pre>
<p>Мы обсудим облегченные пользовательские данные <strong>(light userdata)</strong> более подробно в разделе 29.5.</p>
<p>Чтобы упростить использование адресов переменных в качестве уникальных ключей, Lua 5.2 вводит две новые функции: <code>lua_rawgetp</code> и <code>lua_rawsetp</code>. Они похожи на <code>lua_rawgeti и</code> <code>lua_rawseti</code>, но вместо целых чисел они используют как ключи указатели C (переведенные в облегченные пользовательские данные). С ними мы можем переписать предыдущий код следующим образом:</p>
<pre><code>static char Key = &#39;k&#39;;

/* хранит строку */
lua_pushstring(L, myStr);
lua_rawsetp(L, LUA_REGISTRYINDEX, (void *)&amp;Key);

/* возвращает строку */
lua_rawgetp(L, LUA_REGISTRYINDEX, (void *)&amp;Key);
myStr = lua_tostring(L, -1);</code></pre>
<p>Обе функции используют прямой доступ. Так как у реестра нет метатаблицы, прямой доступ ведет себя так же, как и обычный доступ, но немного эффективнее.</p>
<h4 id="Chapter28.xhtml#sigil_toc_id_212">Верхние значения</h4>
<p>В то время как реестр предлагает глобальные переменные, механизм <em>верхних значений</em> <strong>(upvalue)</strong> реализует аналог статических переменных в С, которые видны только внутри конкретной функции. Каждый раз, когда вы создаете новую функцию С в Lua, вы можете связать с ней любое количество верхних значений; каждое верхнее значение может хранить одно значение Lua. Потом при вызове функции она получает свободный доступ к любому из ее верхних значений, используя псевдоиндексы.</p>
<p>Мы называем эту связь функции С со своими верхними значениями <em>замыканием</em> <strong>(closure)</strong>. Замыкание С примерно соответствует замыканию Lua. В частности, вы можете создавать разные замыкания, используя один и тот же код функции, но с разными верхними значениями.</p>
<p>В качестве простого примера давайте напишем функцию <code>newCounter</code> на С. (<span class="underline">Примечание</span>: Мы определили эту же функцию на Lua в разделе 6.1.) Эта функция является фабрикой: она возвращает новую функцию <code>counter</code> при каждом своем вызове. Хотя у всех этих функций один и тот же код С, каждая из них хранит свой собственный счетчик. Эта функция-фабрика выглядит следующим образом;</p>
<pre><code>static int counter (lua_State *L); /* предваряющее объявление */

  int newCounter (lua_State *L) {
  lua_pushinteger(L, 0);
  lua_pushcclosure(L, &amp;counter, 1);
  return 1;
}</code></pre>
<p>Главной функцией здесь является <code>lua_pushcclosure</code>, которая создает новое замыкание. Ее вторым аргументом является базовая функция (в примере это <code>counter</code>), а третьим — число верхних значений (в примере это 1). Перед созданием нового замыкания мы должны затолкать в стек начальные значения для их верхних значений. В нашем примере мы заталкиваем 0 как начальное значение для единственного верхнего значения. Как и ожидалось, <code>lua_pushcclosure</code> оставляет новое замыкание в стеке, поэтому замыкание уже готово к возвращению как результат <code>newCounter</code>.</p>
<p>Теперь давайте рассмотрим определение <code>counter</code>:</p>
<pre><code>static int counter (lua_State *L) {
  int val = lua_tointeger(L, lua_upvalueindex(1));
  lua_pushinteger(L, ++val);           /* новое значение */
  lua_pushvalue(L, -1);                /* дублирует его */
  lua_replace(L, lua_upvalueindex(1)); /* обновляет верхнее значение */
  return 1;                            /* возвращает новое значение */
}</code></pre>
<p>Здесь ключевым элементом является макрос <code>lua_upvalueindex</code>, который производит псевдоиндекс верхнего значения. В частности, выражение <code>lua_upvalueindex(1)</code> возвращает псевдоиндекс первого верхнего значения выполняющейся функции. Опять же, этот псевдоиндекс выглядит как любой другой индекс стека, за исключением того, что он не живет в стеке. Поэтому вызов <code>lua_tointeger</code> возвращает текущее значение первого (и единственного) верхнего значения как число. Затем функция <code>counter</code> заталкивает в стек новое значение <code>++val</code>, делает его копию и использует одну из копий, чтобы заменить значение верхнего значения. Наконец, она возвращает другую копию как свое возвращаемое значение.</p>
<p>В качестве более сложного примера мы реализуем при помощи верхних значений кортежи. <em>Кортеж</em> <strong>(tuple)</strong> — это разновидность постоянной записи с анонимными полями; вы можете получить конкретное поле по числовому индексу или можете получить все поля разом. В нашей реализации мы представим кортежи как функции, которые запоминают свои значения в своих верхних значениях. При вызове с числовым аргументом эта функция вернет то конкретное поле. При вызове без аргументов она вернет все свои поля. Следующий код иллюстрирует использование кортежей:</p>
<pre><code>x = tuple.new(10, &quot;hi&quot;, {}, 3)
print(x(1))    --&gt; 10
print(x(2))    --&gt; hi
print(x())     --&gt; 10   hi   table: 0x8087878   3</code></pre>
<p>В языке С мы представляем все кортежи при помощи одной и той же функции <code>t_tuple</code>, продемонстрированной в листинге 28.5. Поскольку мы можем вызвать кортеж как с числовым аргументом, так и вообще без аргументов, функция <code>t_tuple</code> использует <code>luaL_optint</code> для получения необязательного аргумента. Функция <code>luaL_optint</code> похожа на <code>luaL_checkint</code>, но она не жалуется на отсутствие аргумента — она возвращает заданное значение по умолчанию (в примере это 0).</p>
<p><strong>Листинг 28.5.</strong> Реализация кортежей</p>
<pre><code>int t_tuple (lua_State *L) {
  int op = luaL_optint(L, 1, 0);
  if (op == 0) { /* нет аргументов? */
    int i;
    /* заталкивает каждое допустимое верхнее значение в стек */
    for (i = 1; !lua_isnone(L, lua_upvalueindex(i)); i++)
      lua_pushvalue(L, lua_upvalueindex(i));
    return i - 1; /* число значений в стеке */
  }
  else { /* получает поле &#39;op&#39; */
    luaL_argcheck(L, 0 &lt; op, 1, &quot;index out of range&quot;);
    if (lua_isnone(L, lua_upvalueindex(op)))
      return 0; /* такого поля нет */
    lua_pushvalue(L, lua_upvalueindex(op));
    return 1;
  }
}

int t_new (lua_State *L) {
  lua_pushcclosure(L, t_tuple, lua_gettop(L));
  return 1;
}

static const struct luaL_Reg tuplelib [] = {
  {&quot;new&quot;, t_new},
  {NULL, NULL}
};

int luaopen_tuple (lua_State *L) {
  luaL_newlib(L, tuplelib);
  return 1;
}</code></pre>
<p>Когда мы индексируем несуществующее верхнее значение, то результатом является псевдозначение типа <code>LUA_TNONE</code>. (Когда мы обращаемся к индексу стека, находящемуся над вершиной стека, то мы также получаем псевдозначение типа <code>LUA_TNONE</code>.) Поэтому наша функция <code>t_tupie</code> использует <code>lua_isnone</code> для проверки, что у нее есть заданное верхнее значение. Однако, мы никогда не должны вызывать <code>lua_upvalueindex</code> с отрицательным индексом, поэтому нам следует проверять данное условие, когда пользователь передает индекс. Функция <code>luaL_argcheck</code> проверяет любое заданное условие, вызывая ошибку, если потребуется.</p>
<p>Функция для создания кортежей, <code>t_new</code> (тоже в листинге 28.5), тривиальна: поскольку все ее аргументы уже в стеке, ей всего лишь нужно вызвать <code>lua_pushcclosure</code> для создания замыкания из <code>t_tuple</code> со всеми своими аргументами в качестве верхних значений. Наконец, массив <code>tuplelib</code> и функция <code>luaopen_tuple</code> (тоже в листинге 28.5) являются стандартным кодом для создания библиотеки <code>tuple</code> с единственной функцией <code>new</code>.</p>
<h4 id="Chapter28.xhtml#sigil_toc_id_213">Общие верхние значения</h4>
<p>Зачастую нам нужно предоставить всем функциям библиотеки общий доступ к нескольким значениям или переменным. Хотя мы можем использовать реестр для этой цели, мы также можем использовать верхние значения.</p>
<p>В отличие от замыканий Lua, замыкания С не могут иметь общие верхние значения. У каждого замыкания имеются свои собственные независимые верхние значения. Однако, мы можем настроить верхние значения разных функций, чтобы они ссылались на общую таблицу, тогда эта таблица становится общим окружением, в котором у всех этих функций будет совместный доступ к данным.</p>
<p>В Lua 5.2 предлагает функцию, которая облегчает задачу совместного использования верхнего значения между всеми функциями библиотеки. Мы открывали библиотеки С при помощи <code>luaL_newlib</code>. Lua реализует эту функцию в качестве следующего макроса:</p>
<pre><code>#define luaL_newlib(L,l) \
     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))</code></pre>
<p>Макрос <code>luaL_newlibtable</code> просто создает таблицу для этой библиотеки. (Мы также могли бы использовать <code>lua_newtable</code>, но этот макрос использует <code>lua_createtable</code> для создания таблицы заранее определенного размера, оптимального для количества функций в данной библиотеке.) Функция <code>luaL_setfuncs</code> добавляет функции из списка <code>l</code> в эту новую таблицу, которая находится на вершине стека.</p>
<p>Здесь нас интересует третий параметр функции <code>luaL_setfuncs</code>. Он сообщает, сколько верхних значений будут иметь новые функции в библиотеке. Начальные значения для этих верхних значений должны находиться в стеке, как и в случае с <code>lua_pushcclosure</code>. Таким образом, для создания библиотеки, где все функции будут совместно использовать общую таблицу как свое единственное верхнее значение, мы можем использовать следующий код:</p>
<pre><code>/* создает библиотечную таблицу (&#39;lib&#39; — это ее список функций) */
luaL_newlibtable(L, lib);
/* создает общее верхнее значение */
lua_newtable(L);
/* добавляет функции к списку &#39;lib&#39; для новой библиотеки,
   совместно используя прежнюю таблицу как верхнее значение */
luaL_setfuncs(L, lib, 1);</code></pre>
<p>Последний вызов также удаляет общую таблицу из стека, оставляя там только новую библиотеку.</p>
<h3 id="Chapter28.xhtml#sigil_toc_id_214">Упражнения</h3>
<p><strong>Упражнение 28.1.</strong> Реализуйте на C функцию фильтрации (<code>filter</code>). Она должна получать список и предикат, а затем возвращать новый список со всеми элементами из заданного списка, которые удовлетворяют заданному предикату:</p>
<pre><code>t = filter({1, 3, 20, -4, 5}, function (x) return x &lt; 5 end)
  -- t = {1, 3, -4}</code></pre>
<p>(Предикат — это всего лишь функция, которая проверяет какое-либо условие и возвращает логическое значение.)</p>
<p><strong>Упражнение 28.2.</strong> Измените функцию <code>l_split</code> (из листинга 28.2) так, чтобы она могла работать со строками, содержащими нуль-символы. (Кроме прочих изменений, она также должна использовать <code>memchr</code> вместо <code>strchr</code>.)</p>
<p><strong>Упражнение 28.3.</strong> Заново реализуйте функцию <code>transliterate</code> (упражнение 21.3) на С.</p>
<p><strong>Упражнение 28.4.</strong> Реализуйте библиотеку с измененной функцией <code>transliterate</code> так, чтобы таблица транслитерации не передавалась как аргумент, а хранилась самой библиотекой. Ваша библиотека должна предоставить следующие функции:</p>
<pre><code>lib.settrans (table)    -- устанавливает таблицу транслитерации
lib.gettrans ()         -- получает таблицу транслитерации
lib.tranliterate(s)     -- транслитерирует &#39;s&#39; в соответствии с
                           текущей таблицей</code></pre>
<p>Используйте реестр для хранения таблицы транслитерации.</p>
<p><strong>Упражнение 28.5.</strong> Повторите предыдущее упражнение, используя для хранения таблицы транслитерации верхнее значение.</p>
<p><strong>Упражнение 28.6.</strong> Считаете ли вы хорошим стилем разработки хранить таблицу транслитерации как часть состояния библиотеки, а не передавать ее как параметр в <code>transliterate</code>?</p>
<p><span id="Chapter29.xhtml"></span></p>
<h2>ГЛАВА 29</h2>
<h2 id="Chapter29.xhtml#sigil_toc_id_215">Задаваемые пользователем типы в С</h2>
<p>В предыдущей главе мы увидели, как расширить Lua при помощи новых функций, написанных на С. Теперь мы увидим, как расширить Lua при помощи новых типов, написанных на С. Мы начнем с небольшого примера; на протяжении всей главы мы будем расширять его при помощи метаметодов и прочих вкусняшек.</p>
<p>Наш пример для запуска довольно прост: массив логических значений. Такая простая структура выбрана потому, что ей не требуются какие-то сложные алгоритмы, поэтому мы сможем сосредоточиться на аспектах API. Тем не менее, этот пример полезен сам по себе. Разумеется, в Lua мы можем использовать таблицы для реализации массивов логических значений. Но реализация на С, где мы храним каждую запись в одном единственном бите, использует менее 3% от памяти, используемой для таблицы.</p>
<p>Для нашей реализации нам понадобятся следующие определения:</p>
<pre><code>#include &lt;limits.h&gt;

#define BITS_PER_WORD (CHAR_BIT*sizeof(unsigned int))
#define I_WORD(i)     ((unsigned int)(i) / BITS_PER_WORD)
#define I_BIT(i)      (1 &lt;&lt; ((unsigned int)(i) % BITS_PER_WORD))</code></pre>
<p><code>BITS_PER_WORD</code> — это количество бит в беззнаковом целом числе. Макрос <code>I_WORD</code> вычисляет слово, которое хранит бит по заданному индексу, а макрос <code>I_BIT</code> вычисляет битовую маску для обращения к соответственному биту данного слова.</p>
<p>Мы будем представлять наши массивы при помощи следующей структуры:</p>
<pre><code>typedef struct NumArray {
  int size;
  unsigned int values[1]; /* переменная часть */
} NumArray;</code></pre>
<p>Мы объявляем массив <code>values</code> с размером в 1 лишь в качестве заполнителя, поскольку стандарт C 89 не допускает массивы с размером 0; мы выставим его настоящий размер, когда выделим для него память. Следующее выражение вычисляет итоговый размер массива с <code>n</code> элементами:</p>
<pre><code>sizeof(NumArray) + I_WORD(n - 1)*sizeof(unsigned int)</code></pre>
<p>(Мы вычли единицу из <code>n</code>, поскольку начальная структура уже содержит место под один элемент.)</p>
<h3 id="Chapter29.xhtml#sigil_toc_id_216">29.1. Пользовательские данные (<span class="code">userdata</span>)</h3>
<p>Наша первая задача — понять, как представить структуру <code>NumArray</code> в Lua. Специально для этого Lua предоставляет базовый тип: <em>пользовательские данные</em> <strong>(userdata)</strong>. Данный тип соответствует области необрабатываемой памяти в Lua без каких-либо встроенных для нее операций, в которой мы можем хранить что-угодно.</p>
<p>Функция <code>lua_newuserdata</code> выделяет блок памяти заданного размера, заталкивает соответственные пользовательские данные в стек и возвращает адрес этого блока:</p>
<pre><code>void *lua_newuserdata (lua_State *L, size_t size);</code></pre>
<p>Если по какой-то причине вам нужно выделить память иным способом, то можно очень легко создать пользовательские данные размером с указатель и хранить там указатель на настоящий блок памяти. Мы увидим примеры данной техники в главе 30.</p>
<p>С помощью <code>lua_newuserdata</code> функция для создания новых массивов логических значений выглядит следующим образом:</p>
<pre><code>static int newarray (lua_State *L) {
  int i;
  size_t nbytes;
  NumArray *a;

  int n = luaL_checkint(L, 1);
  luaL_argcheck(L, n &gt;= 1, 1, &quot;invalid size&quot;);
  nbytes = sizeof(NumArray) + I_WORD(n - 1)*sizeof(unsigned int);
  a = (NumArray *)lua_newuserdata(L, nbytes);

  a-&gt;size = n;
  for (i = 0; i &lt;= I_WORD(n - 1); i++)
    a-&gt;values[i] = 0; /* инициализирует массив */

  return 1; /* новые пользовательские данные уже в стеке */
}</code></pre>
<p>(Макрос <code>luaL_checkint</code> — это лишь приведение типа над <code>luaL_checkinteger</code>.) Как только функция <code>newarray</code> зарегистрирована в Lua, мы можем создавать новые массивы при помощи операторов наподобие <code>а=аггау.new(1000)</code>.</p>
<p>Для сохранения записи мы будем использовать вызов вроде <code>array.set(a,index,value)</code>. Позже мы увидим, как использовать метатаблицы для поддержки более удобного синтаксиса <code>a[index]=value</code>. В обоих формах записи в основе лежит одна и та же функция. Она предполагает, что индексы начинаются с 1, как это принято в Lua:</p>
<pre><code>static int setarray (lua_State *L) {
  NumArray *a = (NumArray *)lua_touserdata(L, 1);
  int index = luaL_checkint(L, 2) - 1;

  luaL_argcheck(L, a != NULL, 1, &quot;&#39;array&#39; expected&quot;);
  luaL_argcheck(L, 0 &lt;= index &amp;&amp; index &lt; a-&gt;size, 2,
  &quot;index out of range&quot;);
  luaL_checkany(L, 3);

  if (lua_toboolean(L, 3))
    a-&gt;values[I_WORD(index)] |= I_BIT(index); /* set bit */
  else
    a-&gt;values[I_WORD(index)] &amp;= ~I_BIT(index); /* reset bit */
  return 0;
}</code></pre>
<p>Поскольку Lua в качестве логического принимает любое значение, для третьего параметра мы используем <code>luaL_checkany</code>: она лишь проверяет, что для данного параметра есть значение (не важно, какое). Если мы вызовем <code>setarray</code> с некорректными аргументами, то получим подробные сообщения об ошибках:</p>
<pre><code>array.set(0, 11, 0)
  --&gt; stdin:1: bad argument #1 to &#39;set&#39; (&#39;array&#39; expected)
array.set(a, 1)
  --&gt; stdin:1: bad argument #3 to &#39;set&#39; (value expected)</code></pre>
<p>Следующая функция возвращает запись:</p>
<pre><code>static int getarray (lua_State *L) {
  NumArray *a = (NumArray *)lua_touserdata(L, 1);
  int index = luaL_checkint(L, 2) - 1;

  luaL_argcheck(L, a != NULL, 1, &quot;&#39;array&#39; expected&quot;);
  luaL_argcheck(L, 0 &lt;= index &amp;&amp; index &lt; a-&gt;size, 2,
  &quot;index out of range&quot;);

  lua_pushboolean(L, a-&gt;values[I_WORD(index)] &amp; I_BIT(index));
  return 1;
}</code></pre>
<p>Мы определим другую функцию для возвращения размера массива:</p>
<pre><code>static int getsize (lua_State *L) {
  NumArray *a = (NumArray *)lua_touserdata(L, 1);
  luaL_argcheck(L, a != NULL, 1, &quot;&#39;array&#39; expected&quot;);
  lua_pushinteger(L, a-&gt;size);
  return 1;
}</code></pre>
<p>Наконец, нам нужно немного дополнительного кода для инициализации нашей библиотеки:</p>
<pre><code>static const struct luaL_Reg arraylib [] = {
  {&quot;new&quot;, newarray},
  {&quot;set&quot;, setarray},
  {&quot;get&quot;, getarray},
  {&quot;size&quot;, getsize},
  {NULL, NULL}
};

int luaopen_array (lua_State *L) {
  luaL_newlib(L, arraylib);
  return 1;
}</code></pre>
<p>И вновь мы воспользуемся функцией <code>luaL_newlib</code> из вспомогательной библиотеки. Она создает таблицу и заполняет ее парами имя-функция, заданными массивом <code>arraylib</code>.</p>
<p>После открытия библиотеки мы готовы использовать наш новый тип в Lua:</p>
<pre><code>a = array.new(1000)
print(a)                --&gt; userdata: 0x8064d48
print(array.size(a))    --&gt; 1000
for i = 1, 1000 do
  array.set(a, i, i%5 == 0)
end
print(array.get(a, 10)) --&gt; true</code></pre>
<h3 id="Chapter29.xhtml#sigil_toc_id_217">29.2. Метатаблицы</h3>
<p>У нашей текущей реализации есть крупная дыра в безопасности. Допустим, пользователь напишет что-то вроде <code>array.set(io.stdin,l,false)</code>. Значение в <code>io.stdin</code> — это пользовательские данные с указателем на поток (<code>FILE*</code>). Из-за того, что это пользовательские данные, <code>array.set</code> с радостью примет их как допустимый аргумент; вероятно, результатом будет повреждение памяти (если повезет, вы можете получить вместо этого сообщение о выходе индекса за границы индексации). Подобное поведение недопустимо для любой библиотеки Lua. Независимо от того, как вы используете библиотеку, она не должна повреждать данные C или приводить к сбоям с выдачей дампа ядра из Lua.</p>
<p>Обычным методом, чтобы отличать один тип пользовательских данных от других, является создание уникальной метатаблицы для этого типа. Каждый раз, когда мы создаем пользовательские данные, мы помечаем их при помощи соответственной метатаблицы; каждый раз, когда мы получаем пользовательские данные, мы проверяем, есть ли у них правильная метатаблица. Поскольку код Lua не может изменить метатаблицу пользовательских данных, он не сможет подделать наш код.</p>
<p>Нам также нужно место для хранения этой новой метатаблицы, чтобы мы могли обращаться к ней при создании новых пользовательских данных и при проверке того, что у требуемых пользовательских данных правильный тип. Как мы уже видели, есть два варианта для хранения метатаблицы: в реестре или как верхнее значение для функций в библиотеке. В Lua принято регистрировать каждый новый тип С в реестре, используя <em>имя типа</em> как индекс, а метатаблицу как его значение. Как и с любыми другими индексами реестра, во избежание конфликтов мы должны с осторожностью выбирать имя типа. В нашем примере мы будем использовать для нашего нового типа имя &quot;<code>LuaBook.array</code>&quot;.</p>
<p>Как обычно, в этом нам поможет вспомогательная библиотека, предоставив некоторые функции. Эти новые вспомогательные функции, которыми мы будем пользоваться, следующие:</p>
<pre><code>int luaL_newmetatable  (lua_State *L, const char *tname);
void luaL_getmetatable (lua_State *L, const char *tname);
void *luaL_checkudata  (lua_State *L, int index,
                                      const char *tname);</code></pre>
<p>Функция <code>luaL_newmettable</code> создает новую таблицу (для использования в качестве метатаблицы), помещает ее на вершину стека и связывает эту таблицу с заданным именем в реестре. Функция <code>luaL_getmetatable</code> возвращает метатаблицу, связанную с именем <code>tname</code>, из реестра. Наконец, <code>luaL_checkudata</code> проверяет, что объект на заданной позиции стека является пользовательскими данными с метатаблицей, которая соответствует заданному имени. Она вызывает ошибку, если у объекта неправильная метатаблица, или это не пользовательские данные; в противном случае она возвращает адрес объекта.</p>
<p>Теперь мы можем начать нашу реализацию. Первым шагом будет изменение функции, которая открывает нашу библиотеку. Новая версия должна создавать метатаблицу для массивов:</p>
<pre><code>int luaopen_array (lua_State *L) {
  luaL_newmetatable(L, &quot;LuaBook.array&quot;);
  luaL_newlib(L, arraylib);
  return 1;
}</code></pre>
<p>Следующим шагом будет изменение <code>newarray</code> таким образом, чтобы она устанавливала метатаблицу во всех создаваемых ей массивах:</p>
<pre><code>static int newarray (lua_State *L) {
  &lt;как прежде&gt;
  luaL_getmetatable(L, &quot;LuaBook.array&quot;);
  lua_setmetatable(L, -2);

  return 1; /* новые пользовательские данные уже в стеке */
}</code></pre>
<p>Функция <code>lua_setmetatable</code> выталкивает таблицу из стека и устанавливает ее как метатаблицу для объекта по заданному индексу. В нашем случае этим объектом являются новые пользовательские данные.</p>
<p>Наконец, <code>setarray</code>, <code>getarray</code> и <code>getsize</code> должны проверить, что они получили допустимый массив в качестве своего первого аргумента. Чтобы упростить им задачи, мы определим следующий макрос:</p>
<pre><code>#define checkarray(L) \
          (NumArray *)luaL_checkudata(L, 1, &quot;LuaBook.array&quot;)</code></pre>
<p>С помощью этого макроса новое определение <code>getsize</code> не вызывает затруднений:</p>
<pre><code>static int getsize (lua_State *L) {
  NumArray *a = checkarray(L);
  lua_pushinteger(L, a-&gt;size);
  return 1;
}</code></pre>
<p>Поскольку <code>setarray</code> и <code>getarray</code> к тому же имеют общий код для проверки индекса как своего второго аргумента, мы вынесем их общие части в следующую функцию:</p>
<pre><code>static unsigned int *getindex (lua_State *L, unsigned int *mask) {
  NumArray *a = checkarray(L);
  int index = luaL_checkint(L, 2) - 1;

  luaL_argcheck(L, 0 &lt;= index &amp;&amp; index &lt; a-&gt;size, 2,
  &quot;index out of range&quot;);

  /* возвращает адрес элемента */
  *mask = I_BIT(index);
  return &amp;a-&gt;values[I_WORD(index)];
}</code></pre>
<p>После определения <code>getindex</code> несложно написать <code>setarray</code> и <code>getarray</code>:</p>
<pre><code>static int setarray (lua_State *L) {
  unsigned int mask;
  unsigned int *entry = getindex(L, &amp;mask);
  luaL_checkany(L, 3);
  if (lua_toboolean(L, 3))
    *entry |= mask;
  else
    *entry &amp;= ~mask;

  return 0;
}

static int getarray (lua_State *L) {
  unsigned int mask;
  unsigned int *entry = getindex(L, &amp;mask);
  lua_pushboolean(L, *entry &amp; mask);
  return 1;
}</code></pre>
<p>Теперь, если вы попытаетесь выполнить что-то вроде <code>array.get(io.stdin,10)</code>, то получите соответственное сообщение об ошибке:</p>
<pre><code>error: bad argument #1 to &#39;get&#39; (&#39;array&#39; expected)</code></pre>
<h3 id="Chapter29.xhtml#sigil_toc_id_218">29.3. Объектно-ориентированный доступ</h3>
<p>Нашим следующим шагом будет преобразование нашего нового типа в объект, чтобы мы могли работать с его экземплярами при помощи обычного объектно-ориентированного синтаксиса таким образом:</p>
<pre><code>a = array.new(1000)
print(a:size())     --&gt; 1000
a:set(10, true)
print(a:get(10))    --&gt; true</code></pre>
<p>Вспомним, что форма записи <code>a:size()</code> эквивалента <code>a.size(а)</code>. Поэтому мы должны переделать выражение <code>а.size</code> так, чтобы оно возвращало нашу функцию <code>getsize</code>. Ключевым механизмом здесь является метаметод <code>__index</code>. <span>Lua вызывает этот метаметод для таблиц всякий раз, когда он не может найти значение для заданного ключа. Для пользовательских данных Lua вызывает его при каждом обращении, поскольку у пользовательских данных вообще нет ключей.</span></p>
<p>Предположим, что мы выполнили следующий код:</p>
<pre><code>local metaarray = getmetatable(array.new(1))
metaarray.__index = metaarray
metaarray.set = array.set
metaarray.get = array.get
metaarray.size = array.size</code></pre>
<p>В первой строке кода мы создаем массив лишь для получения его метатаблицы, которую мы присваиваем <code>metarray</code>. (Мы не можем установить метатаблицу пользовательских данных из Lua, но мы можем получить ее.) Затем мы устанавливаем <code>metaarray.__index</code> равной <code>metaarray</code>. Когда мы вычисляем <code>a.size</code>, Lua не может найти ключ &quot;<code>size</code>&quot; в объекте <code>а</code>, поскольку этот объект является пользовательскими данными. Поэтому Lua пытается получить это значение из поля <code>__index</code> метатаблицы <code>а</code>, которая совпадает с самим <code>metaarray</code>. Но <code>metaarray.size</code> — это <code>array.size</code>, поэтому <code>а.size(а)</code> возвращает <code>array.size(а)</code>, как и требовалось.</p>
<p>Конечно, мы можем написать то же самое на С. Мы можем сделать еще лучше: теперь, когда массивы являются объектами со своими собственными операциями, нам больше не нужно хранить эти операции в таблице <code>array</code>. Единственной функцией, которую наша библиотека по-прежнему должна экспортировать, является функция <code>new</code> для создания новых массивов. Все прочие операции доступны только как методы. В связи с этим код С может регистрировать их напрямую.</p>
<p>Операции <code>getsize</code>, <code>getarray</code> и <code>setarray</code> останутся такими же, как и в нашем предыдущем подходе. Изменится только то, как мы их зарегистрируем. Для этого нам нужно изменить код, который открывает библиотеку. Во-первых, нам потребуются два отдельных списка функций: список обычных функций и список методов.</p>
<pre><code>static const struct luaL_Reg arraylib_f [] = {
  {&quot;new&quot;, newarray},
  {NULL, NULL}
};
static const struct luaL_Reg arraylib_m [] = {
  {&quot;set&quot;, setarray},
  {&quot;get&quot;, getarray},
  {&quot;size&quot;, getsize},
  {NULL, NULL}
};</code></pre>
<p>Новая версия открывающей функции <code>luaopen_array</code> должна создать метатаблицу, присвоить ее своему собственному полю <code>__index</code>, зарегистрировать там все методы, а затем создать и заполнить таблицу <code>array</code>:</p>
<pre><code>int luaopen_array (lua_State *L) {
  luaL_newmetatable(L, &quot;LuaBook.array&quot;);

  /* metatable.__index = metatable */
  lua_pushvalue(L, -1); /* дублирует эту метатаблицу */
  lua_setfield(L, -2, &quot;__index&quot;);

  luaL_setfuncs(L, arraylib_m, 0);

  luaL_newlib(L, arraylib_f);
  return 1;
}</code></pre>
<p>Здесь мы вновь используем <code>luaL_setfuncs</code>, чтобы записать функции из списка <code>arraylib_m</code> в метатаблицу, которая находится на вершине стека. Затем мы используем <code>luaL_newlib</code> для создания новой таблицы и регистрации там функций из списка <code>arraylib_f</code> (в данном случае только <code>new</code>).</p>
<p>В качестве завершающего штриха мы добавим к нашему новому типу метод <code>__tostring</code>, чтобы <code>print(а)</code> печатал &quot;<code>array</code>&quot; и размер массива в круглых скобках; должно получиться что-то вроде &quot;<code>array(1000)</code>&quot;. Ниже сама функция:</p>
<pre><code>int array2string (lua_State *L) {
  NumArray *a = checkarray(L);
  lua_pushfstring(L, &quot;array(%d)&quot;, a-&gt;size);
  return 1;
}</code></pre>
<p>Вызов <code>lua_pushfstring</code> форматирует строку и оставляет ее на вершине стека. Мы также должны добавить <code>array2string</code> к списку <code>аггауlib_m</code>, чтобы включить ее в метатаблицу из объектов-массивов:</p>
<pre><code>static const struct luaL_Reg arraylib_m [] = {
  {&quot;__tostring&quot;, array2string},
  &lt;другие методы&gt;
};</code></pre>
<h3 id="Chapter29.xhtml#sigil_toc_id_219">29.4. Доступ как к массиву</h3>
<p>Альтернативой объектно-ориентированной нотации является обычная нотация для доступа к нашим массивам. Вместо записи <code>а:get(i)</code> мы могли бы просто писать <code>а[i]</code>. Для нашего примера это сделать легко, поскольку наши функции <code>setarray</code> и <code>getarray</code> уже получают свои аргументы в том порядке, в котором они заданы для соответствующих метаметодов. Быстрым решением будет определение этих метаметодов прямо в нашем коде Lua:</p>
<pre><code>local metaarray = getmetatable(array.new(1))
metaarray.__index = array.get
metaarray.__newindex = array.set
metaarray.__len = array.size</code></pre>
<p>(Мы должны выполнить этот код на нашей первоначальной реализации массивов, без модификаций для объектно-ориентированного доступа.) Это все, что нам нужно для использования стандартного синтаксиса:</p>
<pre><code>a = array.new(1000)
a[10] = true    -- &#39;setarray&#39;
print(a[10])    -- &#39;getarray&#39;    --&gt; true
print(#a)       -- &#39;getsize&#39;     --&gt; 1000</code></pre>
<p>Если потребуется, мы можем зарегистрировать эти метаметоды в коде С. Для этого мы снова должны изменить нашу инициализирующую функцию:</p>
<pre><code>static const struct luaL_Reg arraylib_f [] = {
  {&quot;new&quot;, newarray},
  {NULL, NULL}
};

static const struct luaL_Reg arraylib_m [] = {
  {&quot;__newindex&quot;, setarray},
  {&quot;__index&quot;, getarray},
  {&quot;__len&quot;, getsize},
  {&quot;__tostring&quot;, array2string},
  {NULL, NULL}
};

int luaopen_array (lua_State *L) {
  luaL_newmetatable(L, &quot;LuaBook.array&quot;);
  luaL_setfuncs(L, arraylib_m, 0);
  luaL_newlib(L, arraylib_f);
  return 1;
}</code></pre>
<p>В этой новой версии у нас опять есть лишь одна открытая функция — <code>new</code>. Все прочие функции доступны только как метаметоды для специфических операций.</p>
<h3 id="Chapter29.xhtml#sigil_toc_id_220">29.5. Облегченные пользовательские данные</h3>
<p>Вид пользовательских данных, который мы до сих пор использовали, называется <em>полными пользовательскими данными</em> (ППД) <strong>(full userdata)</strong>. Lua предлагает и другой вид — <em>облегченные пользовательские данные</em> (ОПД) <strong>(light userdata)</strong>.</p>
<p>Тип ОПД представляет собой просто указатель в С (то есть значение типа <code>void*</code>). Это значение, а не объект; мы не создаем его (так же, как мы не создаем числа). Чтобы поместить ОПД в стек, мы вызываем <code>lua_pushlightuserdata</code>:</p>
<pre><code>void lua_pushlightuserdata (lua_State *L, void *p);</code></pre>
<p>Несмотря на похожие имена, полные и облегченные пользовательские данные на самом деле сильно отличаются. ОПД — это не буферы, а всего лишь указатели. У них нет метатаблиц. Сборщик мусора их не удаляет, также как и числа.</p>
<p>Иногда мы используем ОПД как дешевую альтернативу ППД. Однако, это не типичное их применение. Во-первых, у ОПД нет метатаблиц, поэтому мы не можем знать их тип. Во-вторых, несмотря на свое название, ППД тоже довольно дешевы. Они лишь немного снижают производительность по сравнению с вызовом <code>malloc</code>.</p>
<p>Настоящее применение ОПД связано с проверкой на равенство. Так как тип ППД является объектом, то он равен только самому себе. Тип ОПД, с другой стороны, представляет из себя значение указателя C. И как таковой он равен любым пользовательским данным, представляющим тот же самый указатель. Таким образом, мы можем использовать ОПД для нахождения объектов С внутри Lua.</p>
<p>Мы уже видели типичное применение облегченных пользовательских данных как ключей в реестре (см. раздел 28.3). Там равенство ОПД было крайне важным. Каждый раз, когда мы заталкиваем ОПД в стек при помощи <code>lua_pushlightuserdata</code>, мы получаем то же значение Lua и, соответственно, ту же запись в реестре.</p>
<p>Другим типичным сценарием является необходимость получить полные пользовательские данные по их адресу в С. Допустим, мы организуем связь между Lua и графической оконной системой. Тогда мы можем использовать ППД для представления окон. Каждые пользовательские данные содержат или всю структуру, представляющую окно, или только указатель на структуру, созданную системой. Когда внутри окна случается событие (например, нажатие кнопки мыши), система вызывает соответствующий обработчик, идентифицируя окно по его адресу. Чтобы передать в Lua обратный вызов, мы должны найти пользовательские данные, представляющие данное окно. Чтобы их найти, мы можем использовать таблицу, где индексы — это ОПД с адресами окон, а значения — это ППД, представляющие эти окна в Lua. Если у нас есть адрес окна, мы заталкиваем его в стек как ОПД и используем их как индекс в той таблице. (Скорее всего, у той таблицы должны быть слабые значения. Иначе те полные пользовательские данные никогда не будут удалены сборщиком мусора.)</p>
<h3 id="Chapter29.xhtml#sigil_toc_id_221">Упражнения</h3>
<p><strong>Упражнение 29.1.</strong> Измените реализацию <code>setarray</code>, чтобы она принимала только логические значения.</p>
<p><strong>Упражнение 29.2.</strong> Мы можем рассматривать массив логических значений как множество целых чисел (индексы с истинными значениями в массиве). Добавьте к реализации массивов логических значений функции, которые вычисляют объединение и пересечение двух массивов. Эти функции должны получать два массива и возвращать новый массив, не изменяя свои параметры.</p>
<p><strong>Упражнение 29.3.</strong> Измените реализацию метаметода <code>__tostring</code>, чтобы он показывал полное содержимое массива подходящим образом. Используйте буферные средства (см. раздел 28.2) для создания итоговой строки.</p>
<p><strong>Упражнение 29.4.</strong> На основе примера с массивами логических значений реализуйте библиотеку С для работы с массивами целых чисел.</p>
<p><span id="Chapter30.xhtml"></span></p>
<h2>ГЛАВА 30</h2>
<h2 id="Chapter30.xhtml#sigil_toc_id_222">Управление ресурсами</h2>
<p>В нашей реализации массивов логических значений из предыдущей главы мы не беспокоились об управлении ресурсами. Этим массивам нужна лишь память. Каждые пользовательские данные, представляющие массив, обладают своей собственной памятью, которой управляет Lua. Когда массив становится мусором (то есть становится недоступным для программы), Lua со временем утилизирует его и освободит занимаемую им память.</p>
<p>Но жизнь не всегда так легка. Иногда объекту нужны другие ресурсы, кроме необработанной памяти, такие как дескрипторы файлов, дескрипторы окон и т. п. (зачастую эти ресурсы тоже являются памятью, но управляются другой частью системы). В подобных случаях, когда объект становится мусором и утилизируется, необходимо как-то высвободить и эти ресурсы.</p>
<p>Как мы уже видели в разделе 17.6, Lua предоставляет финализаторы в виде метаметода <code>__gc</code>. Чтобы проиллюстрировать применение этого метаметода в С и API в целом, в данной главе мы разработаем две привязки от Lua к внешним средствам. Первый пример — это иная реализация функции для обхода директории. Второй (и более существенный) пример — это привязка к <em>Expat</em>, парсеру XML с открытым исходным кодом. <strong>(Парсер — это программа для синтаксического анализа.)</strong></p>
<h3 id="Chapter30.xhtml#sigil_toc_id_223">30.1. Итератор по директории</h3>
<p>В разделе 27.1 мы реализовали функцию <code>dir</code>, которая возвращала таблицу со всеми файлами из заданной директории. Наша новая реализация вернет итератор, который возвращает новую запись при каждом вызове. С этой новой реализацией мы можем перебрать директорию посредством примерно такого цикла:</p>
<pre><code>for fname in dir.open(&quot;.&quot;) do
  print(fname)
end</code></pre>
<p>Для итерации по директории в С нам понадобится структура <code>DIR</code>. Экземпляры <code>DIR</code> нужно создавать при помощи <code>opendir</code> и явно высвобождать вызовом <code>closedir</code>. Наша предыдущая реализация <code>dir</code> хранила свой экземпляр <code>DIR</code> как локальную переменную и закрывала этот экземпляр после получения имени последнего файла. Наша новая реализация <code>dir</code> не может хранить этот экземпляр <code>DIR</code> в локальной переменной, поскольку она должна запрашивать это значение на протяжении нескольких вызовов. Более того, она не может закрыть директорию, не получив ее последнее имя; если программа прервет цикл, итератор никогда не получит ее последнее имя. Поэтому, чтобы убедиться, что экземпляр <code>DIR</code> всегда высвобожден, мы храним ее адрес в пользовательских данных и используем метаметод <code>__gc</code> для высвобождения структуры этой директории.</p>
<p>Несмотря на свою центральную роль в нашей реализации, этим пользовательским данным, представляющим директорию, не нужно быть видимыми из Lua. Функция <code>dir</code> возвращает итерирующую функцию, которую и видит Lua. Директория может быть верхним значением этой итерирующей функции. Таким образом, итерирующая функция обладает прямым доступом к этой структуре, но код Lua к ней доступа не имеет (и ему это не нужно).</p>
<p>Итого нам нужны три функции С. Во-первых, нам нужна функция <code>dir.open</code> — средство, которое Lua вызывает для создания итераторов; она должна открыть структуру <code>DIR</code> и создать замыкание итерирующей функции с этой структурой в качестве верхнего значения. Во-вторых, нам нужна итерирующая функция. В-третьих, нам нужен метаметод <code>__gc</code>, который закрывает структуру <code>DIR</code>. Как обычно, нам также понадобится дополнительная функция для начальной подготовки, например, для создания и инициализации метатаблицы для директорий.</p>
<p>Давайте начнем наш код с функции <code>dir.open</code>, показанной в листинге 30.1. У нее есть один нюанс — она должна создать пользовательские данные до открытия директории. Если она сначала откроет директорию, то вызов <code>lua_newuserdata</code> приведет к ошибке доступа к памяти, потере функции и утечке структуры <code>DIR</code>. При правильном порядке структура <code>DIR</code>, как только она создана, сразу же привязывается к пользовательским данным; что бы ни случилось после этого, метаметод <code>__gc</code> со временем высвободит эту структуру.</p>
<p><strong>Листинг 30.1.</strong> Фабричная функция <span class="code">dir.open</span></p>
<pre><code>#include &lt;dirent.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#include &quot;lua.h&quot;
#include &quot;lauxlib.h&quot;

/* предваряющее объявление для итерирующей функции */
static int dir_iter (lua_State *L);

static int l_dir (lua_State *L) {
  const char *path = luaL_checkstring(L, 1);

  /* создает объект userdata для хранения адреса DIR */
  DIR **d = (DIR **)lua_newuserdata(L, sizeof(DIR *));

  /* устанавливает его метатаблицу */
  luaL_getmetatable(L, &quot;LuaBook.dir&quot;);
  lua_setmetatable(L, -2);

  /* пытается открыть заданную директорию */
  *d = opendir(path);
  if (*d == NULL) /* ошибка открытия директории? */
    luaL_error(L, &quot;cannot open %s: %s&quot;, path, strerror(errno));

  /* создает и возвращает итерирующую функцию;
      ее единственное верхнее значение,
      пользовательские данные директории,
      уже находится на вершине этого стека */
  lua_pushcclosure(L, dir_iter, 1);
  return 1;
}</code></pre>
<p>Следующая функция — это <code>dir_iter</code> (листинг 30.2), сам итератор. Ее код не требует долгих пояснений. Она получает адрес структуры <code>DIR</code> из ее верхнего значения и вызывает <code>readdir</code> для получения следующей записи.</p>
<p>Функция <code>dir_gc</code> (также в листинге 30.2) — это метаметод <code>__gc</code>. Он закрывает директорию, но при этом он должен соблюдать одну меру предосторожности: так как мы создаем пользовательские данные до открытия директории, эти пользовательские данные должны быть собраны сборщиком мусора независимо от результата <code>opendir</code>. Если <code>opendir</code> даст сбой, закрывать будет нечего.</p>
<p>Последняя функция в листинге 30.2, <code>luaopen_dir</code>, — это функция, которая открывает эту библиотеку с одной функцией.</p>
<p>В этом полном примере есть интересный нюанс. Сперва может показаться, что <code>dir_gc</code> должна проверять, что ее аргумент является директорией. Иначе пользователь-злоумышленник может вызвать ее с другим видом пользовательских данных (например, файлом), что приведет к катастрофическим последствиям. Однако, у программы на Lua нет способа обратиться к этой функции: она хранится только в метатаблице директорий, которые, в свою очередь, хранятся как верхние значения итерирующей функциии. Программы Lua не могут обращаться к этим директориям.</p>
<p><strong>Листинг 30.2.</strong> Другие функции для библиотеки <span class="code">dir</span></p>
<pre><code>static int dir_iter (lua_State *L) {
  DIR *d = *(DIR **)lua_touserdata(L, lua_upvalueindex(1));
  struct dirent *entry;
  if ((entry = readdir(d)) != NULL) {
    lua_pushstring(L, entry-&gt;d_name);
    return 1;
  }
  else return 0; /* больше значений для возврата нет */
}

static int dir_gc (lua_State *L) {
  DIR *d = *(DIR **)lua_touserdata(L, 1);
  if (d) closedir(d);
  return 0;
}

static const struct luaL_Reg dirlib [] = {
  {&quot;open&quot;, l_dir},
  {NULL, NULL}
};

int luaopen_dir (lua_State *L) {
  luaL_newmetatable(L, &quot;LuaBook.dir&quot;);

  /* устанавливает его поле __gc */
  lua_pushcfunction(L, dir_gc);
  lua_setfield(L, -2, &quot;__gc&quot;);

  /* создает библиотеку */
  luaL_newlib(L, dirlib);
  return 1;
}</code></pre>
<h3 id="Chapter30.xhtml#sigil_toc_id_224">30.2. Парсер XML</h3>
<p>Теперь мы взглянем на упрощенную реализацию привязки между Lua и Expat, которую мы назовем <code>lxp</code>. Expat — это парсер XML 1.0 с открытым исходным кодом, написанным на С. Он реализует SAX — <em><strong>S</strong>imple <strong>A</strong>PI for <strong>X</strong>ML</em>. SAX — это событийно-ориентированный API. Это значит, что парсер SAX читает документ XML и по мере чтения сообщает приложению, что он находит, при помощи обратных вызовов. Например, если мы дадим указания Expat разобрать строку наподобие &quot;<code>&lt;tag cap=&quot;5&quot;&gt;hi&lt;/tag&gt;</code>&quot;, то он сгенерирует три события: событие <em>начального элемента</em> <strong>(start-element)</strong>, когда он читает подстроку &quot;<code>&lt;tag cap=&quot;5&quot;&gt;</code>&quot;; событие <em>текста</em> (также называемое событием <em>символьных данных</em> <strong>(character data)</strong>), когда он читает &quot;<code>hi</code>&quot;; и событие <em>конечного элемента</em> <strong>(end-element)</strong>, когда он читает &quot;<code>&lt;/tag&gt;</code>&quot;. Каждое из этих событий вызывает подходящий <em>обработчик обратных вызовов</em> <strong>(callback handler)</strong> в приложении.</p>
<p>Здесь мы не будем охватывать всю библиотеку Expat. Мы сосредоточимся только на тех частях, которые иллюстрируют новые техники взаимодействия с Lua. Хотя Expat обрабатывает более дюжины различных событий, мы рассмотрим лишь те три события, которые мы увидели в предыдущем примере: начальные элементы, конечные элементы и текст. (<span class="underline">Примечание</span>: Пакет LuaExpat предоставляет практически полный интерфейс к Expat.)</p>
<p>Для этого примера нам потребуется лишь малая часть Expat API. Во-первых, нам нужны функции для создания и уничтожения парсера Expat:</p>
<pre><code>XML_Parser XML_ParserCreate (const char *encoding);
void XML_ParserFree (XML_Parser p);</code></pre>
<p>Аргумент <code>encoding</code> не обязателен; в нашей привязке мы используем <code>NULL</code>.</p>
<p>После того, как у нас есть парсер, мы должны зарегистрировать его обработчики обратных вызовов:</p>
<pre><code>void XML_SetElementHandler(XML_Parser p,
                           XML_StartElementHandler start,
                           XML_EndElementHandler end);

void XML_SetCharacterDataHandler(XML_Parser p,
                                 XML_CharacterDataHandler hndl);</code></pre>
<p>Первая функция регистрирует обработчики для начального и конечного элементов. Вторая функция регистрирует обработчики для текста (<em>символьные данные</em> на языке XML).</p>
<p>Все обработчики обратных вызовов получают в качестве своего первого параметра некоторые пользовательские данные. Обработчик начального элемента также получает имя тега и его атрибуты:</p>
<pre><code>typedef void (*XML_StartElementHandler)(void *uData,
                                        const char *name,
                                        const char **atts);</code></pre>
<p>Атрибуты передаются как массив строк, завершенных нуль-символом, где каждая пара последующих строк содержит атрибут и его значение. Обработчик конечного элемента обладает лишь одним дополнительным параметром — именем тега:</p>
<pre><code>typedef void (*XML_EndElementHandler)(void *uData,
                                      const char *name);</code></pre>
<p>Наконец, обработчик текста получает в качестве дополнительного параметра только текст. Эта текстовая строка не завершена нуль-символом; вместо этого она содержит явно заданную длину:</p>
<pre><code>typedef void (*XML_CharacterDataHandler)(void *uData,
                                         const char *s,
                                         int len);</code></pre>
<p><span>Для скармливания текста Expat мы воспользуемся следующей функцией:</span></p>
<pre><code>int XML_Parse (XML_Parser p, const char *s, int len, int isLast);</code></pre>
<p>Expat получает документ, который необходимо разобрать, по частям, через последовательные вызовы <code>XML_Parse</code>. Последний аргумент <code>XML_Parse</code>, <code>isLast</code>, сообщает Expat, была ли та часть последней в документе. Обратите внимание, что каждой части текста не требуется завершаться нуль-символом; вместо этого мы предоставляем явную длину. Функция <code>XML_Parse</code> возвращает нуль, если обнаружит ошибку разбора. (Expat также предоставляет функции для получения информации об ошибке, но для простоты мы не будем их здесь рассматривать.)</p>
<p>Последняя функция, которая нам нужна от Expat, позволяет задать пользовательские данные, которые будут переданы обработчикам:</p>
<pre><code>void XML_SetUserData (XML_Parser p, void *uData);</code></pre>
<p>Теперь давайте посмотрим, как мы можем использовать эту библиотеку в Lua. Первый подход — это прямой подход: просто экспортируем все те функции в Lua. Более удачный подход состоит в адаптации этой функциональности к Lua. Например, поскольку Lua является языком с динамической типизацией, нам не нужны разные функции для каждого вида обратного вызова. Еще лучше то, что мы можем полностью избежать функции для регистрации обратных вызовов. Вместо этого при создании парсера мы зададим таблицу обратных вызовов, которая содержит все обработчики обратных вызовов, каждый с подходящим ключом. Например, если нам потребуется напечатать структуру документа, мы можем использовать следующую таблицу обратных вызовов:</p>
<pre><code>local count = 0

callbacks = {
  StartElement = function (parser, tagname)
    io.write(&quot;+ &quot;, string.rep(&quot; &quot;, count), tagname, &quot;\n&quot;)
    count = count + 1
  end,

EndElement = function (parser, tagname)
  count = count - 1
  io.write(&quot;- &quot;, string.rep(&quot; &quot;, count), tagname, &quot;\n&quot;)
  end,
}</code></pre>
<p>Получив на вход строку &quot;<code>&lt;to&gt; &lt;yes/&gt; &lt;/to&gt;</code>&quot;, эти обработчики напечатали бы следующий вывод:</p>
<pre><code>+ to
+    yes
-    yes
- to</code></pre>
<p>С этим API нам не нужны функции для управления обратными вызовами. Мы управляем ими напрямую в таблице обратных вызовов. Таким образом, для всего API требуется лишь три функции: первая для создания парсеров, вторая для обработки части текста и третья для закрытия парсера. На самом деле мы реализуем последние две функции как методы объектов парсера. Типичное применение данного API могло бы выглядеть следующим образом:</p>
<pre><code>local lxp = require&quot;lxp&quot;

p = lxp.new(callbacks)    -- создает новый парсер

for l in io.lines() do    -- итерирует через введенные строки
  assert(p:parse(l))      -- разбирает эту строку
  assert(p:parse(&quot;\n&quot;))   -- добавляет перевод строки
end

assert(p:parse())         -- завершает документ
p:close()</code></pre>
<p>Теперь давайте обратим наше внимание на реализацию. Первое решение, которое нужно принять, — это как представить парсер в Lua. Вполне естественно будет использовать пользовательские данные, но что нам нужно поместить внутрь них? По меньшей мере нам понадобятся настоящий парсер Expat и таблица обратных вызовов. Мы не можем хранить таблицу Lua внутри пользовательских данных (или внутри какой-либо структуры С), но Lua позволяет каждым пользовательским данным иметь <em>пользовательское значение</em> <strong>(user value)</strong>, которое может быть любой таблицей Lua, связанной с ними. (Примечание: В Lua 5.1 пользовательским значением служит окружение пользовательских данных.) Мы также должны хранить состояние Lua в объекте парсера, поскольку эти объекты парсера — это все, что принимает обратный вызов Expat, а обратные вызовы нужны для вызова Lua. Поэтому определение объекта парсера следующее:</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &quot;expat.h&quot;
#include &quot;lua.h&quot;
#include &quot;lauxlib.h&quot;

typedef struct lxp_userdata {
  XML_Parser parser; /* связанный парсер expat */
  lua_State *L;
} lxp_userdata;</code></pre>
<p>Следующим шагом является функция для создания объектов парсера, <code>lxp_make_parser</code>. Ее код приведен в листинге 30.3. Эта функция состоит из четырех важных шагов:</p>
<ul>
<li>Ее первый шаг следует общепринятому образцу: сначала она создает пользовательские данные; затем она предварительно инициализирует пользовательские данные согласованными значениями; и, наконец, она устанавливает свою метатаблицу. Причина этой предварительной инициализации следующая: если в ходе инициализации возникает какая-либо ошибка, то мы должны убедиться, что финализатор (метаметод <code>__gc</code>) найдет пользовательские данные в согласованном состоянии.</li>
<li>На втором шаге функция создает парсер Expat, сохраняет его в пользовательских данных и проверяет на ошибки.</li>
<li>Третий шаг проверяет, что первым аргументом функции действительно является таблица (таблица обратных вызовов), и устанавливает ее как пользовательское значение для пользовательских данных.</li>
<li>Последний шаг инициализирует парсер Expat. Он устанавливает пользовательские данные как объект для передачи в функции обратного вызова и устанавливает эти функции обратного вызова. Обратите внимание, что эти функции обратного вызова одни и те же для всех парсеров; в конце концов, на С невозможно динамически создавать новые функции. Вместо этого те фиксированные функции C используют таблицу обратных вызовов, чтобы решить, какие функции Lua им следует вызвать, когда придет время.</li>
</ul>
<p><strong>Листинг 30.3.</strong> Функция для создания объектов-парсеров XML</p>
<pre><code>/* предваряющие объявления для функций обратного вызова */
static void f_StartElement (void *ud,
                            const char *name,
                            const char **atts);
static void f_CharData (void *ud, const char *s, int len);
static void f_EndElement (void *ud, const char *name);

static int lxp_make_parser (lua_State *L) {
  XML_Parser p;

  /* (1) создает объект-парсер */
  lxp_userdata *xpu = (lxp_userdata *)lua_newuserdata(L,
                                        sizeof(lxp_userdata));

  /* предварительно инициализирует его на случай ошибки */
  xpu-&gt;parser = NULL;

  /* устанавливает его метатаблицу */
  luaL_getmetatable(L, &quot;Expat&quot;);
  lua_setmetatable(L, -2);

  /* (2) создает парсер Expat */
  p = xpu-&gt;parser = XML_ParserCreate(NULL);
  if (!p)
    luaL_error(L, &quot;XML_ParserCreate failed&quot;);

  /* (3) проверяет и хранит таблицу обратного вызова */
  luaL_checktype(L, 1, LUA_TTABLE);
  lua_pushvalue(L, 1);     /* помещает таблицу на вершину стека */
  lua_setuservalue(L, -2); /* устанавливает ее как пользовательское значение */

  /* (4) конфигурирует парсер Expat */
  XML_SetUserData(p, xpu);
  XML_SetElementHandler(p, f_StartElement, f_EndElement);
  XML_SetCharacterDataHandler(p, f_CharData);
  return 1;
}</code></pre>
<p>Следующим шагом является метод парсера <code>lxp_parse</code> (листинг 30.4), который разбирает часть данных XML. Он получает два аргумента: объект парсера (<em>self</em> из этого метода) и необязательную часть данных XML. При вызове без каких-либо данных он сообщает Expat, что в документе больше не осталось частей.</p>
<p><strong>Листинг 30.4.</strong> Функция для разбора фрагмента XML</p>
<pre><code>static int lxp_parse (lua_State *L) {
  int status;
  size_t len;
  const char *s;
  lxp_userdata *xpu;

  /* получает и проверяет первый аргумент (должен быть парсером) */
  xpu = (lxp_userdata *)luaL_checkudata(L, 1, &quot;Expat&quot;);

  /* проверяет, что он не закрыт */
  luaL_argcheck(L, xpu-&gt;parser != NULL, 1, &quot;parser is closed&quot;);

  /* получает второй аргумент (строку) */
  s = luaL_optlstring(L, 2, NULL, &amp;len);

  /* помещает таблицу обратного вызова в стек по индексу 3 */
  lua_settop(L, 2);
  lua_getuservalue(L, 1);
  xpu-&gt;L = L; /* set Lua state */

  /* вызывает Expat для разбора строки */
  status = XML_Parse(xpu-&gt;parser, s, (int)len, s == NULL);

  /* возвращает код ошибки */
  lua_pushboolean(L, status);
  return 1;
}</code></pre>
<p>Когда <code>lxp_parse</code> вызывает <code>XML_Parse</code>, последняя функция вызовет обработчики для каждого подходящего элемента, который она найдет в данной части документа. Этим обработчикам понадобится доступ к таблице обратных вызовов, поэтому <code>lxp_parse</code> заталкивает эту таблицу в стек по индексу 3 (сразу после параметров). Есть один нюанс в вызове <code>XML_Parse</code>: помните, что последний аргумент этой функции сообщает Expat, является ли данная часть текста последней. Когда мы вызываем <code>parse</code> без аргументов, <code>s</code> будет равна <code>NULL</code>, поэтому последний аргумент будет равен true.</p>
<p>Теперь давайте обратим наше внимание на функции обратного вызова: <code>f_StartElement</code>, <code>f_EndElement</code> и <code>f_CharData</code>. Все три функции обладают одинаковой структурой: каждая из них проверяет, определяет ли таблица обратных вызовов обработчик Lua для своего конкретного события, и, если определяет, то подготавливает аргументы и затем вызывает этот обработчик Lua.</p>
<p>Давайте сначала рассмотри обработчик <code>f__CharData</code> в листинге 30.5. Его код довольно прост. Обработчик получает структуру <code>lxp_userdata</code> как свой первый аргумент, поскольку мы вызвали <code>XML_setuserData</code> при создании парсера. После получения состояния Lua обработчик может обратиться к таблице обратных вызовов в стеке по индексу 3, заданному <code>lxp_parse</code>, и к самому парсеру по индексу 1. Затем он вызывает соответствующий обработчик на Lua (когда он есть) с двумя аргументами: парсером и символьными данными (строкой).</p>
<p><strong>Листинг 30.5.</strong> Обработчик символьных данных</p>
<pre><code>static void f_CharData (void *ud, const char *s, int len) {
  lxp_userdata *xpu = (lxp_userdata *)ud;
  lua_State *L = xpu-&gt;L;

  /* получает обработчик */
  lua_getfield(L, 3, &quot;CharacterData&quot;);
  if (lua_isnil(L, -1)) {        /* обработчика нет? */
  lua_pop(L, 1);
  return;
}

  lua_pushvalue(L, 1);           /* заталкивает парсер (&#39;self&#39;) */
  lua_pushlstring(L, s, len);    /* заталкивает символьные данные */
  lua_call(L, 2, 0);             /* вызывает этот обработчик */
}</code></pre>
<p>Обработчик <code>f_EndElement</code> довольно похож на <code>f_CharData</code>; взгляните на листинг 30.6. Он также вызывает соответствующий обработчик Lua с двумя аргументами — парсером и именем тега (снова строкой, но на этот раз завершенной нуль-символом).</p>
<p><strong>Листинг 30.6.</strong> Обработчик конечных элементов</p>
<pre><code>static void f_EndElement (void *ud, const char *name) {
  lxp_userdata *xpu = (lxp_userdata *)ud;
  lua_State *L = xpu-&gt;L;

  lua_getfield(L, 3, &quot;EndElement&quot;);
  if (lua_isnil(L, -1)) {     /* обработчика нет? */
  lua_pop(L, 1);
  return;
}

  lua_pushvalue(L, 1);        /* заталкивает парсер (&#39;self&#39;) */
  lua_pushstring(L, name);    /* заталкивает имя тега */
  lua_call(L, 2, 0);          /* вызывает этот обработчик */
}</code></pre>
<p>Листинг 30.7 показывает последний обработчик, <code>f_startElement</code>. Он вызывает Lua с тремя аргументами: парсером, именем тега и списком атрибутов. Этот обработчик немного сложнее остальных, поскольку ему необходимо перевести список атрибутов тега в Lua. Он использует вполне естественный перевод, строя таблицу, которая связывает имена атрибутов с их значениями. Например начальный тег наподобие</p>
<pre><code>&lt;to method=&quot;post&quot; priority=&quot;high&quot;&gt;</code></pre>
<p>генерирует следующую таблицу атрибутов:</p>
<pre><code>{method = &quot;post&quot;, priority = &quot;high&quot;}</code></pre>
<p><strong>Листинг 30.7.</strong> Обработчик начальных элементов</p>
<pre><code>static void f_StartElement (void *ud,
                            const char *name,
                            const char **atts) {
  lxp_userdata *xpu = (lxp_userdata *)ud;
  lua_State *L = xpu-&gt;L;

  lua_getfield(L, 3, &quot;StartElement&quot;);
  if (lua_isnil(L, -1)) {          /* обработчика нет? */
    lua_pop(L, 1);
    return;
  }

  lua_pushvalue(L, 1);             /* заталкивает парсер (&#39;self&#39;) */
  lua_pushstring(L, name);         /* заталкивает имя тега */

  /* создает и заполняет таблицу атрибутов */
  lua_newtable(L);
  for (; *atts; atts += 2) {
    lua_pushstring(L, *(atts + 1));
    lua_setfield(L, -2, *atts);    /* table[*atts] = *(atts+1) */
  }

  lua_call(L, 3, 0);               /* вызывает этот обработчик */
}</code></pre>
<p>Последний метод для парсеров — это <code>close</code>, показанный в листинге 30.8. Когда мы закрываем парсер, нам нужно высвободить все его ресурсы, а именно структуру Expat. Помните, что из-за происходящих временами ошибок при создании у парсера может и не быть этой структуры. Обратите внимание, как мы поддерживаем парсер в согласованном состоянии по мере его закрытия, так что не будет никаких проблем, если мы попытаемся закрыть его снова, или когда сборщик мусора его финализирует. На самом деле мы будем использовать эту функцию именно как финализатор. Это нужно для того, чтобы каждый парсер со временем обязательно освобождал свои ресурсы, даже если программист не закрыл его.</p>
<p><strong>Листинг 30.8.</strong> Метод для закрытия парсера XML</p>
<pre><code>static int lxp_close (lua_State *L) {
  lxp_userdata *xpu = (lxp_userdata *)luaL_checkudata(L, 1, &quot;Expat&quot;);

  /* бесплатный парсер Expat (если есть) */
  if (xpu-&gt;parser)
    XML_ParserFree(xpu-&gt;parser);
  xpu-&gt;parser = NULL;    /* предотвращает его повторное закрытие */
  return 0;
}</code></pre>
<p>Листинг 30.9 — это завершающий шаг: он показывает функцию <code>luaopen_lxp</code>, которая открывает библиотеку, совмещая в себе все ранее рассмотренные функции. Здесь мы используем ту же схему, что и для объектно-ориентированного примера массива логических значений в разделе 29.3: мы создаем метатаблицу, устанавливаем ее точку поля <code>__index</code> на нее саму и помещаем внутрь нее все методы. Для этого нам понадобится список с методами парсера (<code>lxp_meths</code>). Также нам нужен список функций этой библиотеки (<code>lxp_funcs</code>). Как и принято в объектно-ориентированных библиотеках, этот список содержит всего одну функцию, которая создает новые парсеры.</p>
<p><strong>Листинг 30.9.</strong> Код инициализации для библиотеки <span class="code">lхр</span></p>
<pre><code>static const struct luaL_Reg lxp_meths[] = {
  {&quot;parse&quot;, lxp_parse},
  {&quot;close&quot;, lxp_close},
  {&quot;__gc&quot;, lxp_close},
  {NULL, NULL}
};

static const struct luaL_Reg lxp_funcs[] = {
  {&quot;new&quot;, lxp_make_parser},
  {NULL, NULL}
};

int luaopen_lxp (lua_State *L) {
  /* создает метатаблицу */
  luaL_newmetatable(L, &quot;Expat&quot;);

  /* metatable.__index = metatable */
  lua_pushvalue(L, -1);
  lua_setfield(L, -2, &quot;__index&quot;);

  /* регистрирует методы */
  luaL_setfuncs(L, lxp_meths, 0);

  /* регистрирует функции (только lxp.new) */
  luaL_newlib(L, lxp_funcs);
  return 1;
}</code></pre>
<h3 id="Chapter30.xhtml#sigil_toc_id_225">Упражнения</h3>
<p><strong>Упражнение 30.1.</strong> Модифицируйте функцию <code>dir_iter</code> в примере с директорией так, чтобы она закрывала структуру <code>DIR</code>, когда она достигает конца обхода. При этом изменении программе не нужно ждать сборки мусора для освобождения ресурса, который, как она знает, ей больше не нужен.</p>
<p>(Когда вы закрываете директорию, вы должны выставить адрес, сохраненный в пользовательских данных, на <code>NULL</code>, чтобы сообщить финализатору, что директория уже закрыта. Также функция <code>dir_iter</code> перед использованием директории должна проверять, что она не закрыта.)</p>
<p><strong>Упражнение 30.2.</strong> В примере с <code>lхр</code> обработчик начальных элементов получает таблицу с атрибутами элемента. В этой таблице утерян первоначальный порядок, в котором атрибуты стояли внутри элемента. Как вы можете передать эту информацию в обратный вызов?</p>
<p><strong>Упражнение 30.3.</strong> В примере с <code>lxp</code> мы использовали пользовательские значения, чтобы связать таблицу обработчиков с пользовательскими данными, представляющими парсер. Этот выбор создал небольшую проблему, поскольку то, что получают обратные вызовы С, — это структура <code>lxp_userdata</code>, и эта структура не предоставляет прямой доступ к данной таблице. Мы решили эту проблему путем сохранения таблицы обратных вызовов по индексу стека фиксированного размера во время разбора каждого фрагмента.</p>
<p>Альтернативным подходом может быть связывание таблицы обратных вызовов с пользовательскими данными посредством ссылок (раздел 28.3): мы создаем ссылку на таблицу обратных вызовов и храним эту ссылку (целое число) в структуре <code>lxp_userdata</code>. Реализуйте данный подход. Не забудьте высвободить ссылку при закрытии парсера.</p>
<p><span id="Chapter31.xhtml"></span></p>
<h2>ГЛАВА 31</h2>
<h2 id="Chapter31.xhtml#sigil_toc_id_226">Нити и состояния</h2>
<p>Lua не поддерживает настоящую многонитевость, то есть вытесняющие нити, использующие память совместно. Есть две причины отсутсвия данной поддержки. Первая причина состоит в том, что ANSI С не предоставляет ее, и поэтому не существует переносимого способа реализовать этот механизм в Lua. Второй и более серьезной причиной является то, что мы не считаем многонитевость хорошей идеей для Lua.</p>
<p>Многонитевость была разработана для низкоуровневого программирования. Механизмы синхронизации вроде семафоров и мониторов были разработаны для операционных систем (и опытных программистов), а не для прикладных программ. Крайне сложно находить и исправлять ошибки, связанные с многонитевостыо, и некоторые из них могут привести к брешам в безопасности. Более того, многонитевость может стать причиной снижения быстродействия из-за необходимости синхронизации в ряде критических мест программы, например при распределении памяти.</p>
<p>Проблемы с многонитевостыо возникают из-за комбинации вытесняющих нитей и общей памяти, поэтому мы можем избежать их, либо не используя вытесняющие нити, либо не используя общую память. Lua поддерживает оба подхода. Нити Lua (также известные как сопрограммы) являются совместными и поэтому избегают проблем, связанных с непредсказуемым переключением между нитями. Состояния Lua не имеют общей памяти, и поэтому формируют в Lua хорошую базу для параллельных вычислений. В данной главе мы охватим оба варианта.</p>
<h3 id="Chapter31.xhtml#sigil_toc_id_227">31.1. Многонитевость</h3>
<p><em>Нить</em> <strong>(thread)</strong> — это суть сопрограммы в Lua. Мы рассматриваем сопрограмму как нить с удобным интерфейсом, или же мы можем рассматривать нить как сопрограмму с низкоуровневым API.</p>
<p>С точки зрения С, может быть удобно думать о нити как о стеке — чем на самом деле и является нить с точки зрения реализации. Каждый стек хранит информацию об ожидающих вызовах нити, а также параметрах и локальных переменных каждого вызова. Иными словами, стек содержит всю информацию, которая нужна нити для возобновления ее выполнения. Поэтому много нитей означает много независимых стеков.</p>
<p>Когда мы вызываем большинство функций из Lua-C API, эти функции работают с определенным стеком. Например, <code>lua_pushnumber</code> должна заталкивать число в определенный стек; <code>lua_pcall</code> нужен стек вызовов. Как Lua узнает, какой стек следует использовать? Секрет заключается в типе <code>lua_State</code>, первом аргументе этих функций, который представляет не только состояние Lua, но и нить внутри этого состояния. (Многие убеждены, что этот тип должен называться <code>lua_Thread</code>.)</p>
<p>Каждый раз, когда вы создаете состояние Lua, Lua автоматически создает новую нить внутри этого состояния и возвращает <code>lua_State</code>, представляющее эту нить. Эта <em>главная нить</em> <strong>(main thread)</strong> никогда не утилизируется. Она высвобождается вместе с состоянием, когда вы закрываете состояние при помощи <code>lua_close</code>.</p>
<p>Вы можете создавать другие нити внутри состояния путем вызова <code>lua_newthread</code>:</p>
<pre><code>lua_State *lua_newthread (lua_State *L);</code></pre>
<p>Эта функция возвращает указатель на <code>lua_State</code>, представляющее новую нить, а также заталкивает новую нить в стек как значение типа &quot;<code>thread</code>&quot;. Например, после выполнения оператора</p>
<pre><code>L1 = lua_newthread(L);</code></pre>
<p>у нас будет две нити, <code>L1</code> и <code>L</code>, которые будут внутренне ссылаться на одно и то же состояние Lua. Каждая нить обладает собственным стеком. Новая нить <code>L1</code> начинает с пустого стека; у старой нити <code>L</code> есть новая нить на вершине стека:</p>
<pre><code>printf(&quot;%d\n&quot;, lua_gettop(L1));          --&gt; 0
printf(&quot;%s\n&quot;, luaL_typename(L, -1));    --&gt; thread</code></pre>
<p>За исключением главной нити, все нити подвержены сборке мусора, как и любой другой объект Lua. Когда вы создаете новую нить, то значение, которое заталкивается в стек, гарантирует, что эта нить не является мусором. Вы никогда не должны использовать нить, которая должным образом не привязана к состоянию. (Главная нить внутренне привязана с самого начала, поэтому о ней можно не беспокоиться.) Любой вызов Lua API может уничтожить непривязанную нить, даже вызов, использующий эту самую нить. Например, рассмотрим следующий фрагмент:</p>
<pre><code>lua_State *L1 = lua_newthread (L);
lua_pop(L, 1);    /* L1 теперь является мусором для Lua */
lua_pushstring(L1, &quot;hello&quot;);</code></pre>
<p>Вызов <code>lua_pushstring</code> может запустить сборщик мусора и собрать <code>L1</code> (и привести к сбою приложения), несмотря на то, что <code>L1</code> все еще используется. Во избежание этого всегда оставляйте ссылку на нити, которые вы используете, например в стеке привязанной нити или в реестре.</p>
<p>Как только у нас появляется новая нить, мы можем использовать ее тем же образом, что и главную. Мы можем заталкивать и выталкивать элементы из стека, мы можем использовать ее для вызова функций и т.п. Например, следующий код выполняет вызов <code>f(5)</code> в новой нити и затем перемещает результат в старую нить:</p>
<pre><code>lua_getglobal(L1, &quot;f&quot;);    /* допускает глобальную функцию &#39;f&#39; */
lua_pushinteger(L1, 5);
lua_call(L1, 1, 1);
lua_xmove(L1, L, 1);</code></pre>
<p>Функция <code>lua_xmove</code> перемещает значение Lua между двумя стеками в одном и том же состоянии. Вызов наподобие <code>lua_xmove(F,т,n)</code> выталкивает <code>n</code> элементов из стека <code>F</code> и заталкивает их в <code>T</code>.</p>
<p>Однако, для этих целей нам не нужна новая нить; с таким же успехом мы могли бы использовать главную нить. Основной целью использования нескольких нитей является реализация сопрограмм, чтобы мы могли приостанавливать их выполнение и возобновлять их позже. Для этого нам нужна функция <code>lua_resume</code>:</p>
<pre><code>int lua_resume (lua_State *L, lua_State *from, int narg);</code></pre>
<p>Для запуска выполнения сопрограммы мы используем <code>lua_resume</code> так же, как мы используем <code>lua_pcall</code>: мы заталкиваем функцию для вызова, заталкиваем ее аргументы и вызываем <code>lua_resume</code>, передавая в <code>narg</code> число аргументов. (Параметр <code>from</code> — это нить, которая совершает вызов.) Данное поведение также очень похоже на <code>lua_pcall</code>, но с тремя отличиями. Во-первых, у <code>lua_resume</code> нет параметра для числа требуемых результатов; она всегда возвращает все значения из вызванной функции. Во-вторых, у нее нет параметра для обработчика сообщений; ошибка не раскручивает стек, поэтому после нее вы можете изучить стек. В-третьих, если выполняемая функция уступает управление, то <code>lua_resume</code> возвращает особый код <code>LUA_YIELD</code> и оставляет нить в состоянии, из которого она может быть возобновлена позже.</p>
<p>Когда <code>lua_resume</code> возвращает <code>LUA_YIELD</code>, видимая часть стека нити содержит только значения, переданные <code>yield</code>. Вызов <code>lua_gettop</code> вернет число выработанных значений. Для перемещения этих значений в другую нить мы можем использовать <code>lua_xmove</code>.</p>
<p>Чтобы возобновить приостановленную нить, мы вновь вызываем <code>lua_resume</code>. При таких вызовах Lua считает, что все значения в стеке должны быть возвращены вызовом <code>yield</code>. Например, если вы не трогаете стек нити между возвращением из <code>lua_resume</code> и следующим возобновлением, то <code>yield</code> вернет именно те значения, которые он выработал при уступке управления.</p>
<p>Обычно мы запускаем сопрограмму с функцией Lua в качестве ее тела. Эта функция Lua может вызывать другие функции, и любая из этих функций порой может уступать управление, завершая вызов <code>lua_resume</code>. Например, допустим, у нас есть следующие определения:</p>
<pre><code>function foo (x) coroutine.yield(10, x) end

function foo1 (x) foo(x + 1); return 3 end</code></pre>
<p>Теперь мы выполним этот код C:</p>
<pre><code>lua_State *L1 = lua_newthread(L);
lua_getglobal(L1, &quot;foo1&quot;);
lua_pushinteger(L1, 20);
lua_resume(L1, L, 1);</code></pre>
<p>Этот вызов <code>lua_resume</code> вернет <code>LUA_YIELD</code>, чтобы сообщить, что нить уступила управление. В этот момент стек <code>L1</code> содержит значения, переданные в <code>yield</code>:</p>
<pre><code>printf(&quot;%d\n&quot;, lua_gettop(L1));          --&gt; 2
printf(&quot;%d\n&quot;, lua_tointeger(L1, 1));    --&gt; 10
printf(&quot;%d\n&quot;, lua_tointeger(L1, 2));     --&gt; 21</code></pre>
<p>Когда мы вновь возобновим эту нить, она продолжится с того места, где была остановлена (вызовом <code>yield</code>). Отсюда <code>foo</code> вернет управление <code>foo1</code>, а она, в свою очередь, вернет управление <code>lua_resume</code>:</p>
<pre><code>lua_resume(L1, L, 0);
printf(&quot;%d\n&quot;, lua_gettop(L1));          --&gt; 1
printf(&quot;%d\n&quot;, lua_tointeger(L1, 1));    --&gt; 3</code></pre>
<p>Этот второй вызов <code>lua_resume</code> вернет <code>LUA_OK</code>, что означает обычный возврат.</p>
<p>Сопрограммы также могут вызывать функции С, которые могут обратно вызывать другие функции Lua. Мы уже обсуждали, как использовать продолжения, чтобы позволить этим функциям Lua уступать управление (раздел 27.2). Сама по себе функция С также может уступать управление. В этом случае она также должна предоставить продолжающую функцию для вызова при возобновлении нити. Для уступки управления функция C должна вызвать следующую функцию:</p>
<pre><code>int lua_yieldk (lua_State *L, int nresults, int ctx,
lua_CFunction k);</code></pre>
<p>Мы всегда должны использовать эту функцию в операторе возврата, как, например, здесь:</p>
<pre><code>static inf myCfunction (lua_State *L) {
...
return lua_yieldk(L, nresults, ctx, k);
}</code></pre>
<p>Этот вызов немедленно приостанавливает выполняющуюся сопрограмму. Параметр <code>nresults</code> — это количество значений в стеке, которые нужно вернуть соответствующему <code>lua_resume</code>; <code>ctx</code> — это контекстная информация, которая должна быть передана продолжению; а <code>k</code> — это продолжающая функция. Когда сопрограмма возобновляется, управление переходит напрямую к продолжающей функции <code>k</code>. После уступки управления <code>myCfunction</code> не может больше ничего сделать; она должна делегировать всю дальнейшую работу своему продолжению.</p>
<p>Давайте рассмотрим типичный гипотетический пример. Пусть мы хотим написать код функции, которая читает некоторые данные, уступая управление, пока данные не доступны. Мы можем написать эту функцию на С следующим образом:</p>
<pre><code>int prim_read (lua_State *L) {
  if (nothing_to_read())
    return lua_yieldk(L, 0, 0, &amp;prim_read);
  lua_pushstring(L, read_some_data());
  return 1;
}</code></pre>
<p>Если у функции есть какие-то данные для чтения, то она читает и возвращает эти данные. В противном случае, если ей нечего читать, она уступает управление. При возобновлении нить вызовет продолжающую функцию. В этом примере продолжающей функцией является сама <code>prim_read</code>, поэтому нить снова вызывает <code>prim_read</code> и вновь попытается считать некоторые данные. (Этот образец функции, вызывающей <code>lua_yieldk</code>, которая является продолжающей функцией, встречается довольно часто.)</p>
<p>Если функции С нечего делать после уступки управления, то она может вызвать <code>lua_yieldk</code> без продолжающей функции или использовать макрос <code>lua_yield</code>:</p>
<pre><code>return lua_yield(L, nres);</code></pre>
<p>После этого вызова, когда нить снова возобновиться, управление вернется к функции, которая вызывала <code>myCfunction</code>.</p>
<h3 id="Chapter31.xhtml#sigil_toc_id_228">31.2. Состояния Lua</h3>
<p>Каждый вызов <code>luaL_newstate</code> (или <code>lua_newstate</code>, как мы увидим в главе 32) создает новое состояние Lua. Разные состояния Lua полностью независимы друг от друга. У них вообще нет общих данных. Это значит, что независимо от того, что происходит внутри одного состояния Lua, оно не может повредить данные другого. Это также значит, что состояния Lua не могут взаимодействовать друг с другом напрямую; мы должны использовать в качестве посредника какой-нибудь код С. Например, если даны два состояния, <code>L1</code> и <code>L2</code>, то следующая команда затолкнет в <code>L2</code> строку с вершины стека в <code>L1</code>:</p>
<pre><code>lua_pushstring(L2, lua_tostring(L1, -1));</code></pre>
<p>Поскольку данные должны быть переданы посредством C, состояния Lua могут обмениваться только типами, которые могут быть представлены в C, например, строками и числами. Другие типы, такие как таблицы, должны быть сериализованы для осуществления переноса.</p>
<p>В системах, которые предлагают многонитевость, интересной схемой построения является создание независимого состояния Lua для каждой нити. Эта схема в результате дает нити, похожие на процессы UNIX, где мы получаем согласованность без общей памяти. В этом разделе мы разработаем прототипную реализацию многонитевости, следуя данному подходу. Для этой реализации я буду использовать нити POSIX (<code>pthreads</code>). При портировании данного кода на другие нитевые системы не должно возникнуть сложностей, так как в нем используются лишь базовые средства .</p>
<p>Система, которую мы собираемся построить, очень проста. Ее основным предназначением является показать использование нескольких состояний Lua в контексте многонитевости. После того, как она будет готова, вы можете реализовать на ее основе некоторые продвинутые возможности. Мы назовем нашу библиотеку <code>lproc</code>. Она предлагает всего четыре функции:</p>
<ul>
<li><code>lproc.start(chunk)</code> запускает новый процесс для выполнения заданного куска (строки). Данная библиотека реализует <em>процесс</em> Lua как <em>нить</em> С плюс связанное с ней состояние Lua.</li>
<li><code>lproc.send(channel, val1, val2, ...)</code> отправляет все заданные значения (которые должны быть строками) заданному каналу (который идентифицируют по его имени, тоже строке).</li>
<li><code>lproc.receive(channel)</code> получает значения, отправленные заданному каналу.</li>
<li><code>lproc.exit()</code> завершает процесс. Эта функция требуется только для главного процесса. Если этот процесс завершается без вызова <code>lproc.exit</code>, то вся программа прекращает свое выполнение без ожидания завершения других процессов.</li>
</ul>
<p>Библиотека идентифицирует каналы при помощи строк и использует их для сопоставления отправителей и получателей. Операция отправки может отправить любое количество строковых значений, которые возвращаются сопоставленной с ней операцией получения. Все взаимодействие синхронно: процесс, отправляющий сообщение каналу, блокируется до тех пор, пока есть процесс, принимающий из этого канала, в то время как процесс, получающий из канала, блокируется до тех пор, пока есть процесс, отправляющий ему.</p>
<p>Реализация <code>lproc</code> также проста, как и ее интерфейс. Она использует два кольцевых двунаправленных списка, один для процессов, ожидающих отправки сообщения, а другой для процессов, ожидающих приема сообщения. Она использует один единственный мьютекс <strong>(объект взаимоисключающей блокировки)</strong> для управления доступом к этим спискам. У каждого процесса есть связанная с ним условная переменная. Когда процесс хочет отправить каналу сообщение, он обходит список получателей в поисках процесса, ожидающего этот канал. Если поиск успешен, то отправляющий процесс убирает найденный процесс из списка ожидания, перемещает из себя в него значения сообщения и предупреждает об этом другой процесс. В противном случае он вставляет себя в список отправителей и ожидает своей условной переменной. Получение сообщения происходит симметричным образом.</p>
<p>Главным элементом данной реализации является структура, представляющая процесс:</p>
<pre><code>#include &lt;pthread.h&gt;
#include &quot;lua.h&quot;

typedef struct Proc {
  lua_State *L;
  pthread_t thread;
  pthread_cond_t cond;
  const char *channel;
  struct Proc *previous, *next;
} Proc;</code></pre>
<p>Первые два поля представляют из себя состояние Lua, используемое процессом, и нить С, выполняющую данный процесс. Другие поля используются лишь тогда, когда процесс должен ждать подходящего отправителя или получателя. Третье поле, <code>cond</code>, — это условная переменная, которую нить использует для блокировки самой себя; четвертое поле хранит ожидаемый процессом канал; последние два поля, <code>previous</code> и <code>next</code>, используются для связывания структуры процесса в списке ожидания.</p>
<p>Следующий код объявляет два списка ожидания и связанный с ними мьютекс:</p>
<pre><code>static Proc *waitsend = NULL;
static Proc *waitreceive = NULL;

static pthread_mutex_t kernel_access = PTHREAD_MUTEX_INITIALIZER;</code></pre>
<p>Каждому процессу нужна структура <code>Proc</code> и доступ к этой структуре всякий раз, когда скрипт вызывает <code>send</code> <span>или</span> <code>receive</code><span>. Единственный параметр, который принимают эти функции — это состояние Lua для процесса.</span> <span>Таким образом, каждый процесс должен хранить свою структуру</span> <code>Proc</code> <span>внутри своего состояния Lua</span><span>. В нашей реализации каждое состояние хранит свою соответственную структуру</span> <code>Proc</code> <span>в реестре как полные пользовательские данные, связанные с ключом &quot;</span><code>_SELF</code><span>&quot;. Вспомогательная функция</span> <code>getself</code> <span>возвращает структуру</span> <code>Proc</code><span>, связанную с данным состоянием</span><span>:</span></p>
<pre><code>static Proc *getself (lua_State *L) {
  Proc *p;
  lua_getfield(L, LUA_REGISTRYINDEX, &quot;_SELF&quot;);
  p = (Proc *)lua_touserdata(L, -1);
  lua_pop(L, 1);
  return p;
}</code></pre>
<p>Следующая фyнкция, <code>movevalues</code>, перемещает знaчeния из отправляющего процесса в принимающий:</p>
<pre><code>static void movevalues (lua_State *send, lua_State *rec) {
  int n = lua_gettop(send);
  int i;
  for (i = 2; i &lt;= n; i++) /* переносит значения в получателя */
    lua_pushstring(rec, lua_tostring(send, i));
}</code></pre>
<p>Она перемещает в получателя все значения из стека отправителя, кроме самого первого, которым является канал.</p>
<p>Листинг 31.1 определяет функцию <code>searchmatch</code>, которая обходит список ожидания в поисках процесса, ожидающего заданный канал. Если функция находит такой канал, то она удаляет его из списка и возвращает его; иначе она возвращает <code>NULL</code>.</p>
<p><strong>Листинг 31.1.</strong> Функция для поиска процесса, ожидающего заданного канала</p>
<pre><code>static Proc *searchmatch (const char *channel, Proc **list) {
  Proc *node = *list;
  if (node == NULL) return NULL; /* пустой список */
  do {
  if (strcmp(channel, node-&gt;channel) == 0) { /* совпадение? */
    /* удаляет узел из этого списка */
    if (*list == node) /* этот узел является первым элементом? */
      *list = (node-&gt;next == node) ? NULL : node-&gt;next;
    node-&gt;previous-&gt;next = node-&gt;next;
    node-&gt;next-&gt;previous = node-&gt;previous;
    return node;
  }
  node = node-&gt;next;
  } while (node != *list);
  return NULL; /* совпадений нет */
}</code></pre>
<p>Последняя вспомогательная функция, определенная в листинге 31.2, вызывается, когда процесс не может найти соответствие. В этом случае процесс ставит себя в конец соответствующего списка ожидания и ожидает, пока с ним не будет сопоставлен другой процесс, который его и разбудит. (Цикл вокруг <code>pthread_cond_wait</code> защищает от случайных пробуждений, которые возможны в нитях POSIX.) Когда один процесс будит другой, он устанавливает поле <code>channel</code> другого процесса в <code>NULL</code>. Поэтому, если <code>p-&gt;channel</code> не равен <code>NULL</code>, это означает, что ни один процесс не подошел процессу <code>p</code>, и поэтому он должен ждать дальше.</p>
<p><strong>Листинг 31.2.</strong> Функция для добавления процесса в список ожидания</p>
<pre><code>static void waitonlist (lua_State *L, const char *channel,
                                      Proc **list) {
  Proc *p = getself(L);

  /* link itself at the end of the list */
  if (*list == NULL) { /* empty list? */
    *list = p;
    p-&gt;previous = p-&gt;next = p;
  }
  else {
    p-&gt;previous = (*list)-&gt;previous;
    p-&gt;next = *list;
    p-&gt;previous-&gt;next = p-&gt;next-&gt;previous = p;
  }

  p-&gt;channel = channel;

  do { /* waits on its condition variable */
  pthread_cond_wait(&amp;p-&gt;cond, &amp;kernel_access);
  } while (p-&gt;channel);
}</code></pre>
<p>Имея эти вспомогательные функции, мы можем написать <code>send</code> и <code>receieve</code> (листинг 31.3). Функция <code>send</code> начинает с проверки канала. Затем она блокирует мьютекс и ищет подходящего получателя. Если она его находит, то она перемещает свои значения в этого получателя, помечает получателя как готового к выполнению и будит его. В противном случае она ставит себя в режим ожидания. По завершении этой операции она разблокирует мьютекс и возвращается без значений в Lua. Функция <code>receive</code> аналогична, но она должна вернуть все полученные значения.</p>
<p><strong>Листинг 31.3.</strong> Функции для отправки и получения сообщений</p>
<pre><code>static int ll_send (lua_State *L) {
  Proc *p;
  const char *channel = luaL_checkstring(L, 1);

  pthread_mutex_lock(&amp;kernel_access);

  p = searchmatch(channel, &amp;waitreceive);

  if (p) {                  /* найден подходящий ресивер? */
    movevalues(L, p-&gt;L);    /* перемещает значения в получателя */
    p-&gt;channel = NULL;      /* помечает получателя как не ожидающего */
    pthread_cond_signal(&amp;p-&gt;cond); /* будит его */
  }
  else
    waitonlist(L, channel, &amp;waitsend);

  pthread_mutex_unlock(&amp;kernel_access);
  return 0;
}

static int ll_receive (lua_State *L) {
  Proc *p;
  const char *channel = luaL_checkstring(L, 1);
  lua_settop(L, 1);
  pthread_mutex_lock(&amp;kernel_access);

  p = searchmatch(channel, &amp;waitsend);

  if (p) {                  /* найден подходящий отправитель? */
    movevalues(p-&gt;L, L);    /* получает значения от отправителя */
    p-&gt;channel = NULL;      /* помечает отправителя как не ожидающего */
    pthread_cond_signal(&amp;p-&gt;cond); /* будит его */
  }
  else
    waitonlist(L, channel, &amp;waitreceive);

  pthread_mutex_unlock(&amp;kernel_access);

  /* возвращает все значения из стека, кроме канала */
  return lua_gettop(L) - 1;
}</code></pre>
<p>Теперь давайте посмотрим, как создавать новые процессы. Новому процессу нужна новая нить POSIX, а новой нити нужно тело для выполнения. Мы определим это тело позже; ниже приведен ее прототип на основе <code>pthreads</code>:</p>
<pre><code>static void *ll_thread (void *arg);</code></pre>
<p>Для создания и запуска нового процесса системе нужно создать новое состояние Lua, начать новую нить, cкомпилировать переданный кусок, вызвать его и в конце освободить его ресурсы. Исходная нить выполняет первые три задачи, а новая нить делает остальное. (Для упрощения обработки ошибок система начинает новую нить только после того, как она успешно скомпилирует переданный кусок.)</p>
<p>Функция <code>ll_start</code> создает новый процесс (листинг 31.4). Эта функция создает новое состояние Lua <code>L1</code> и компилирует заданный кусок в этом новом состоянии. В случае ошибки функция сообщает о ней исходному состоянию <code>L</code>. Затем она создает новую нить (при помощи <code>pthread_create</code>) с телом <code>ll_thread</code>, передавая новое состояние <code>L1</code> как аргумент тела. Вызов <code>pthread_detach</code> сообщает системе, что мы не ожидаем никакого окончательного ответа от этой нити.</p>
<p><strong>Листинг 31.4.</strong> Функция для создания новых процессов</p>
<pre><code>static int ll_start (lua_State *L) {
  pthread_t thread;
  const char *chunk = luaL_checkstring(L, 1);
  lua_State *L1 = luaL_newstate();

  if (L1 == NULL)
    luaL_error(L, &quot;unable to create new state&quot;);

  if (luaL_loadstring(L1, chunk) != 0)
    luaL_error(L, &quot;error starting thread: %s&quot;,
    lua_tostring(L1, -1));

  if (pthread_create(&amp;thread, NULL, ll_thread, L1) != 0)
    luaL_error(L, &quot;unable to create new thread&quot;);

  pthread_detach(thread);
  return 0;
}</code></pre>
<p>Телом каждой новой нити является функция <code>ll_thread</code> (листинг 31.5). Она получает свое соответственное состояние Lua (созданное <code>ll_start</code>) с уже скомпилированным главным куском в стеке. Новая нить открывает стандартные библиотеки Lua, открывает библиотеку <code>lproc</code> и затем вызывает свой главный кусок. В конце она уничтожает свою условную переменную (которая была создана <code>luaopen_lproc</code>) и закрывает свое состояние Lua.</p>
<p><strong>Листинг 31.5.</strong> Тело для новых нитей</p>
<pre><code>int luaopen_lproc (lua_State *L);

static void *ll_thread (void *arg) {
  lua_State *L = (lua_State *)arg;
  luaL_openlibs(L); /* open standard libraries */
  luaL_requiref(L, &quot;lproc&quot;, luaopen_lproc, 1);
  lua_pop(L, 1);
  if (lua_pcall(L, 0, 0, 0) != 0) /* call main chunk */
    fprintf(stderr, &quot;thread error: %s&quot;, lua_tostring(L, -1));
  pthread_cond_destroy(&amp;getself(L)-&gt;cond);
  lua_close(L);
  return NULL;
}</code></pre>
<p>(Обратите внимание на использование <code>luaL_requiref</code> для открытия библиотеки <code>lproc</code> (<span class="underline">Примечание</span>: Эта функция появилась в Lua 5.2). Эта функция в чем-то эквивалентна <code>require</code>, но вместо поиска загрузчика использует заданную функцию (в нашем случае <code>luaopen_lproc</code>) для открытия библиотеки. После вызова этой открывающей функции, <code>luaL_requiref</code> регистрирует результат в таблице <code>package.loaded</code>, чтобы при будущих вызовах <code>require</code> для библиотеки она не пыталась открыть ее снова. Если последним параметром является true, то она также регистрирует эту библиотеку в соответственной глобальной переменной (в нашем случае <code>lproc</code>).)</p>
<p>Последняя функция в нашем модуле, <code>exit</code>, довольно проста:</p>
<pre><code>static int ll_exit (lua_State *L) {
  pthread_exit(NULL);
  return 0;
}</code></pre>
<p>Лишь главному процессу необходимо вызывать эту функцию по завершении, чтобы избежать немедленного окончания всей программы.</p>
<p>Нашим последний шагом является определение открывающей функции для модуля <code>lproc</code>. Открывающая функция <code>luaopen_lproc</code> (листинг 31.6) должна, как обычно, зарегистрировать функции модуля, но также она должна создать и инициализировать структуру <code>Ргос</code> выполняемого процесса.</p>
<p><strong>Листинг 31.6.</strong> Открывающая функция для модуля <span class="code">lproc</span></p>
<pre><code>static const struct luaL_reg ll_funcs[] = {
  {&quot;start&quot;, ll_start},
  {&quot;send&quot;, ll_send},
  {&quot;receive&quot;, ll_receive},
  {&quot;exit&quot;, ll_exit},
  {NULL, NULL}
};

int luaopen_lproc (lua_State *L) {
  /* создает собственный блок управления */
  Proc *self = (Proc *)lua_newuserdata(L, sizeof(Proc));
  lua_setfield(L, LUA_REGISTRYINDEX, &quot;_SELF&quot;);
  self-&gt;L = L;
  self-&gt;thread = pthread_self();
  self-&gt;channel = NULL;
  pthread_cond_init(&amp;self-&gt;cond, NULL);
  luaL_register(L, &quot;lproc&quot;, ll_funcs); /* открывает библиотеку */
  return 1;
}</code></pre>
<p>Как я сказал ранее, данная реализация процессов в Lua очень простая. Есть бесконечное число улучшений, которые вы можете произвести. Здесь я кратко расскажу о некоторых из них.</p>
<p>Первым очевидным улучшением будет замена линейного поиска подходящего канала. Прекрасной заменой является использование хэш-таблицы для поиска канала и использование независимых списков ожидания для каждого канала.</p>
<p>Другое улучшение относится к эффективности создания процесса. Создание нового состояния Lua — это быстрая операция. Однако, открытие всех стандартных библиотек происходит уже не так быстро, а большинству процессов, скорее всего, не понадобятся все стандартные библиотеки. Мы можем избежать затрат на открытие библиотеки при помощи предварительной регистрации библиотек, которую мы обсуждали в разделе 15.1. При данном подходе вместо вызова <code>luaL_requiref</code> для каждой стандартной библиотеки мы лишь помещаем функцию, открывающую библиотеку, в таблицу <code>package.preload</code>. Если процесс вызовет <code>require&quot;lib</code><code>&quot;</code>, то тогда и только тогда <code>require</code> вызовет связанную с ней функцию для открытия библиотеки. Функция <code>registerlib</code>, в листинге 31.7, проводит эту регистрацию.</p>
<p><strong>Листинг 31.7.</strong> Регистрация библиотек для открытия по запросу</p>
<pre><code>static void registerlib (lua_State *L, const char *name,
                                       lua_CFunction f) {
  lua_getglobal(L, &quot;package&quot;);
  lua_getfield(L, -1, &quot;preload&quot;); /* получает &#39;package.preload&#39; */
  lua_pushcfunction(L, f);
  lua_setfield(L, -2, name); /* package.preload[name] = f */
  lua_pop(L, 2); /* выталкивает таблицы &#39;package&#39; и &#39;preload&#39; */
}

static void openlibs (lua_State *L) {
  luaL_requiref(L, &quot;_G&quot;, luaopen_base, 1);
  luaL_requiref(L, &quot;package&quot;, luaopen_package, 1);
  lua_pop(L, 2); /* удаляет результаты из предыдущих вызовов */
  registerlib(L, &quot;io&quot;,     luaopen_io);
  registerlib(L, &quot;os&quot;,     luaopen_os);
  registerlib(L, &quot;table&quot;,  luaopen_table);
  registerlib(L, &quot;string&quot;, luaopen_string);
  registerlib(L, &quot;math&quot;,   luaopen_math);
  registerlib(L, &quot;debug&quot;,  luaopen_debug);
}</code></pre>
<p>Открыть основную библиотеку — это всегда хорошая идея. Вам также понадобится библиотека для пакетов; иначе <code>require</code> не будет доступна для открытия других библиотек. (У вас даже не будет таблицы <code>package.preload</code>.) Все другие библиотеки могут быть необязательными. Поэтому <span>вместо вызова</span> <code>luaL_openlibs</code> <span>мы можем вызвать нашу собственную функцию</span> <code>openlibs</code> <span>(также показанную в листинге 31.7) при открытии новых состояний. Всякий раз, когда процессу требуется одна на этих библиотек, он запрашивает ее явным образом,</span> <span>и</span> <code>require</code> <span>вызовет соответствующую функцию</span> <code>lunopen_*</code><span>.</span></p>
<p>Другие улучшения включают в себя примитивные коммуникационные функции. Например, было бы удобно задавать лимит времени для <code>lproc.send</code> и <code>lproc.receive</code>, определяющий, сколько они должны ждать совпадения. В частности, нулевой лимит делал бы эти функции неблокирующими. В нитях POSIX мы можем реализовать данные средства при помощи <code>pthread_cond_timedwait</code>.</p>
<h3 id="Chapter31.xhtml#sigil_toc_id_229">Упражнения</h3>
<p><strong>Упражнение 31.1.</strong> Как мы видели, если функция вызывает <code>lua_yield</code> (версию без продолжающей функции), то управление возвращается функции, которая ее вызвала, когда нить была вновь возобновлена. Какие значения вызывающая функция получит в качестве результатов того вызова?</p>
<p><strong>Упражнение 31.2.</strong> Измените библиотеку <code>lproc</code> так, чтобы она могла отправлять и принимать другие примитивные типы, такие как логические значения и числа. (Подсказка: вам нужно изменить лишь функцию <code>movevalues</code>.)</p>
<p><strong>Упражнение 31.3.</strong> Реализуйте в библиотеке <code>lproc</code> неблокирующую операцию <code>send</code>.</p>
<p><span id="Chapter32.xhtml"></span></p>
<h2>ГЛАВА 32</h2>
<h2 id="Chapter32.xhtml#sigil_toc_id_230">Управление памятью</h2>
<p>Lua выделяет все свои структуры данных динамически. Все эти структуры растут по мере надобности и со временем сокращаются или исчезают.</p>
<p>Lua строго следит за своим использованием памяти. Когда мы закрываем состояние Lua, то Lua явно освобождает всю его память. Более того, все объекты внутри Lua подвержены сборке мусора: не только таблицы и строки, но также функции, нити и модули (поскольку на самом деле они являются таблицами).</p>
<p>Способ, которым Lua управляет памятью, удобен для большинства приложений. Однако, для некоторых особых приложений может потребоваться адаптация, например для работы в условиях ограниченного объема памяти или для уменьшения пауз между сборкой мусора до минимума. Lua позволяет осуществлять подобные адаптации на двух уровнях. На нижнем уровне мы можем задать функцию выделения памяти, используемую Lua. На более высоком уровне мы можем задать некоторые параметры для управления сборщиком мусора или можем даже получить над ним прямой контроль. В данной главе мы рассмотрим эти средства.</p>
<h3 id="Chapter32.xhtml#sigil_toc_id_231">32.1. Выделяющая функция</h3>
<p>Ядро Lua не строит предположений о том, как выделить память. Для выделения памяти оно не вызывает ни <code>malloc</code>, ни <code>realloc</code>. Вместо этого оно осуществляет все свое выделение и освобождение памяти через одну единственную <em>выделяющую функцию</em> <strong>(allocation function)</strong>, которую пользователь должен предоставить при создании состояния Lua.</p>
<p>Функция <code>luaL_newstate</code>, которую мы использовали для создания состояний, является вспомогательной функцией, которая создает состояние Lua с выделяющей функцией по умолчанию. Эта функция по умолчанию использует стандартные функции <code>malloc-realloc-free</code> из стандартной библиотеки С, которых (должно быть) достаточно для обычных приложений. Однако, можно довольно легко получить полный контроль над выделением памяти в Lua, создав ваше состояние при помощи примитивной функции <code>lua_newstate</code>:</p>
<pre><code>lua_State *lua_newstate (lua_Alloc f, void *ud);</code></pre>
<p>Эта функция получает два аргумента: выделяющую функцию и пользовательские данные. Состояние, созданное таким образом, осуществляет все выделение и освобождение памяти при помощи вызовов функции <code>f</code>. (Даже сама структура <code>lua_state</code> выделяется при помощи <code>f</code>.)</p>
<p>Тип выделяющей функции <code>lua_Alioc</code> определен следующим образом:</p>
<pre><code>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</code></pre>
<p>Первый параметр — это всегда пользовательские данные, которые мы предоставили <code>lua_newstate</code>; второй параметр — это адрес блока, который мы хотим заново выделить или освободить; третий параметр — это исходный размер этого блока; и четвертый параметр — это запрашиваемый размер блока.</p>
<p>Lua гарантирует, что если <code>ptr</code> не равен <code>NULL</code>, то он был ранее выделен с размером <code>osize</code>.</p>
<p>Lua использует <code>NULL</code> для блоков нулевого размера. Когда <code>nsize</code> равен нулю, выделяющая функция должна освободить блок, на который указывает <code>ptr</code>, и вернуть <code>NULL</code>, который соответствует блоку запрошенного размера (нулевого). Когда <code>ptr</code> равен <code>NULL</code>, функция должна выделить и вернуть блок заданного размера; если она не может выделить блок заданного размера, то она должна вернуть <code>NULL</code>. Если и <code>ptr</code> равен <code>NULL</code>, и <code>nsize</code> равен нулю, то функция ничего не делает и возвращает <code>NULL</code>.</p>
<p>Наконец, когда и <code>ptr</code> не равен <code>NULL</code>, и <code>nsize</code> не равен нулю, функция должна заново выделить этот блок, как это делает <code>realloc</code>, и вернуть новый адрес (который может как совпадать, так и отличаться от исходного). Опять же, в случае ошибки она должна вернуть <code>NULL</code>. Lua предполагает, что выделяющая функция никогда не дает сбоев в случае, когда новый размер меньше или равен старому размеру. (Lua сжимает некоторые структуры во время сборки мусора и потому не способен при этом восстановиться после ошибок.)</p>
<p>Стандартная выделяющая функция, используемая <code>luaL_newstate</code>, имеет следующее определение (извлечено напрямую из файла <code>lauxlib.с</code>):</p>
<pre><code>void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
  if (nsize == 0) {
    free(ptr);
    return NULL;
}
else
  return realloc(ptr, nsize);
}</code></pre>
<p>Она допускает, что <code>free(NULL)</code> не делает ничего, и что вызов <code>realloc(NULL,size)</code> эквивалентен <code>malloc(size)</code>. Стандарт ANSI C поддерживает оба этих режима.</p>
<p>Вы можете получить выделяющую функцию из состояния Lua посредством вызова <code>lua_getallocf</code>:</p>
<pre><code>lua_Alloc lua_getallocf (lua_State *L, void **ud);</code></pre>
<p>Если <code>ud</code> не равен <code>NULL</code>, to функция установит <code>*ud</code> в значения пользовательских данных, используемых для данной выделяющей функции. Вы можете изменить выделяющую функцию для состояния Lua при помощи вызова <code>lua_setallocf</code>:</p>
<pre><code>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</code></pre>
<p>Имейте в виду, что любая новая выделяющая функция будет ответственна за освобождение блоков, выделенных предыдущей функцией. Чаще всего новая функция является оберткой над старой, например, для отслеживания выделений или синхронизации доступа к куче.</p>
<p>Внутри себя Lua не кэширует свободные блоки для их повторного использования. Она предполагает, что кэширование проводит выделяющая функция; хорошие выделяющие функции так и делают. Lua не пытается минимизировать фрагментацию памяти. Исследования показывают, что фрагментация — это больше результат плохой схемы выделения памяти, чем поведения программы; хорошие выделяющие функции не создают сильной фрагментации.</p>
<p>Сложно улучшить хорошо реализованную выделяющую функцию, но иногда вы можете попытаться. Например, Lua дает вам старый размер любого блока при его освобождении или выделении заново. Соответственно, специализированной выделяющей функции не нужно хранить информацию о размере блока, тем самым снижая объем требуемой памяти под каждый блок.</p>
<p>Другой случай, когда вы можете улучшить выделение памяти — это случай многонитевых систем. Такие системы обычно требуют синхронизации для своих выделяющих функций, так как они используют глобальный ресурс (память). Однако, доступ к состоянию Lua также должен быть синхронизирован — или, что еще лучше, ограничен всего одной нитью, как в нашей реализации <code>lproc</code> в главе 31. Поэтому если каждое состояние Lua будет выделять память из закрытого пула, выделяющая функция может избежать расходов на дополнительную синхронизацию.</p>
<h3 id="Chapter32.xhtml#sigil_toc_id_232">32.2. Сборщик мусора</h3>
<p>До версии 5.0 Lua использовал простой сборщик мусора типа «пометь и почисти» <strong>(mark-and-sweep)</strong>, также называемый сборщиком типа «останови мир» <strong>(stop-the-world)</strong>. Это значит, что время от времени Lua прекращает интерпретировать главную программу для выполнения полного цикла сборки мусора. Каждый такой цикл состоит из трех фаз: <em>пометка</em> <strong>(mark)</strong>, <em>уборка</em> <strong>(cleaning)</strong> и <em>очистка</em> <strong>(sweep)</strong>.</p>
<p>Lua начинает фазу пометки с того, что помечает как живой свой <em>корневой набор</em> <strong>(root set)</strong>, который включает в себя все объекты, к которым Lua имеет прямой доступ: реестр и главная нить. Любой объект, который хранится в живом объекте, доступен программе, и поэтому тоже помечается как живой. Фаза пометки заканчивается, когда все доступные объекты помечены как живые.</p>
<p>Перед началом фазы очистки Lua выполняет фазу уборки, которая связана с финализаторами и слабыми таблицами. Во-первых, она обходит все объекты, помеченные для финализации, в поисках непомеченных объектов. Эти объекты помечаются как живые (возрожденные) и помещаются в отдельный список для использования в фазе финализации. Во-вторых, Lua обходит свои слабые таблицы и удаляет из них все записи, где либо ключ, либо само значение не помечено.</p>
<p>Фаза очистки обходит все объекты Lua. (Чтобы данный обход был возможен, Lua хранит все создаваемые объекты с связанном списке.) Если объект не помечен как живой, Lua собирает его как мусор. В противном случае Lua снимает его пометку для подготовки к следующему циклу. Во время фазы очистки Lua также вызывает финализаторы объектов, которые были отделены во время фазы уборки.</p>
<p>С версией 5.1 Lua получил <em>инкрементальный сборщик мусора</em>. Этот сборщик выполняет те же шаги, что и прежний, но во время выполнения ему не нужно «останавливать мир». Вместо этого он выполняется вместе с интерпретатором. Каждый раз, когда интерпретатор выделяет некоторое количество памяти, сборщик мусора выполняет небольшой шаг. Это значит, что во время работы сборщика интерпретатор может изменить доступность объекта. Чтобы обеспечить правильность работы сборщика некоторые операции в интерпретаторе имеют барьеры, которые обнаруживают опасные изменения и поправляют пометки вовлеченных объектов.</p>
<h4 id="Chapter32.xhtml#sigil_toc_id_233">API сборщика мусора</h4>
<p>Lua предлагает API, который позволяет получить некоторый контроль над сборщиком мусора. Из С мы можем вызвать <code>lua_gc</code>:</p>
<pre><code>int lua_gc (lua_State *L, int what, int data);</code></pre>
<p>Из Lua мы используем функцию <code>collectgarbage</code>:</p>
<pre><code>collectgarbage(what [, data])</code></pre>
<p>Обе функции предоставляют одну и ту же функциональность. Аргумент <code>what</code> (перечислимое значение в С, строка в Lua) определяет, что требуется делать. Возможные варианты:</p>
<ul>
<li><code>LUA_CGSTOP (&quot;stop&quot;)</code><span>: останавливает сборщик мусора до другого вызова <code>collectgarbage</code> (или до <code>lua_gc</code>) с опцией &quot;<code>restart</code>&quot;.</span></li>
<li><code>LUA_GSRESTART (&quot;restart&quot;)</code><span>: перезапускает сборщик мусора.</span></li>
<li><code>LUA_GCCOLLECT (&quot;collect&quot;)</code><span>: осуществляет полный цикл сборки мусора, при этом все недоступные объекты собираются и финализируются. Это значение по умолчанию для <code>collectgarbage</code>.</span></li>
<li><code>LUA_GCSTEP (&quot;step&quot;)</code><span>: выполняет некоторую работу по сборке мусора. Объем этой работы эквивалентен тому, что сборщик мусора сделает после выделения <code>data</code> байт.</span></li>
<li><code>LUA_GCCOUNT (&quot;count&quot;)</code><span>: возвращает количество килобайт памяти, используемой Lua в данный момент. Это количество включает в себя «мертвые», но еще не собранные объекты.</span></li>
<li><code>LUA_GCCOUNTB (</code><em>без аргументов</em><code>)</code><span>: возвращает дробную часть числа килобайт памяти, используемой Lua в данный момент. В C следующее выражение возвращает полный объем памяти в байтах (полагая, что это число поместится в <code>int</code>):</span></li>
<li><pre><code>(lua_gc(L, LUA_GCCOUNT, 0) * 1024)
    + lua_gc(L, LUA_GCCOUNTB, 0)</code></pre>
<p>В Lua результат <code>collectgarbage (&quot;count&quot;)</code> — это число с плавающей точкой, и полное число байт памяти может быть вычислено следующим образом:</p>
<pre><code>collectgarbage(&quot;count&quot;) * 1024</code></pre>
<p>Поэтому у <code>collectgarbage</code> нет аналога для этой опции.</p></li>
<li><code>LUA_GCSETPAUSE (&quot;setpause&quot;)</code><span>: задает параметр <code>pause</code> сборщика мусора. Это значение задается параметром <code>data</code> в процентах: когда <code>data</code> равен 100, параметр устанавливается на единицу (100%).</span></li>
<li><code>LUA_GCSETSTEPMUL (&quot;setstepmul&quot;)</code><span>: задает параметр пошагового множителя (</span><span><code>stepmul</code>) для сборщика мусора. Эта значение также задано <code>data</code> в процентах.</span></li>
</ul>
<p>Любой сборщик мусора расплачивается за память процессорным временем. В одном крайнем случае сборщик может вообще не запуститься. Он совсем не будет расходовать процессорное время за счет огромного потребления памяти. В другом крайнем случае сборщик может производить полный цикл сборки мусора при каждом изменении графа доступности. Такая программа будет использовать самый минимум необходимой ей памяти ценой гигантского потребления процессорного времени. Настоящие сборщики мусора пытаются найти хороший баланс между этими двумя крайностями<span>.</span></p>
<p>Как и ее выделяющая функция, сборщик мусора Lua достаточно хорош для большинства приложений. Тем не менее, в некоторых случаях сборщик мусора стоит попробовать оптимизировать. Два параметра, — <code>pause</code> <span>и</span> <code>stepmul</code><span>, предоставляют некоторое управление поведением сборщика</span><span>.</span></p>
<p>Параметр <code>pause</code> управляет тем, как долго сборщик ждет между окончанием последней сборки мусора и началом новой. <span>Значение</span> <code>pause</code> <span>равное нулю заставит Lua запустить новую сборку мусора сразу по завершении предыдущей.</span> <span>Параметр</span> <code>pause</code> <span>в 200% ожидает удвоения использования памяти перед тем, как начать сборку мусора. Вы можете понизить значение</span> <code>pause</code><span>, если хотите пожертвовать процессорным временем ради меньшего потребления памяти. Обычно вы должны держать это значение между</span> <span>0 и 200%.</span></p>
<p>Параметр <code>stepmul</code> управляет тем, как много работы сборщик мусора выполняет для каждого килобайта выделенной памяти. Чем выше это значение, тем менее инкрементальным становится сборщик мусора. Огромное значение вроде 100 000 000% заставит сборщик мусора вести себя как неинкрементальный сборщик. Значением по умолчанию является 200%. Значения, меньшие 100%, сделают сборщик настолько медленным, что он может так никогда и не завершить сборку мусора.</p>
<p>Другие опции <code>lua_gc</code> дают вам контроль над тем, когда запускается сборщик мусора. Игры являются типичными клиентами для данного вида контроля. Например, если вы не хотите, чтобы сборка мусора выполнялась во время определенных периодов времени, вы можете остановить его при помощи <code>collectgarbage(&quot;stop&quot;)</code> и затем запустить снова при помощи <code>collectgarbage(&quot;restart&quot;)</code>. В системах, где возникают постоянные периоды ожидания, вы можете держать сборщик мусора остановленным и вызывать <code>collectgarbage(&quot;step&quot;,n)</code> лишь в эти периоды. Чтобы определить, как много работы нужно выполнить во время такого периода, либо экспериментально подберите подходящее значение для <code>n</code>, либо в цикле вызывайте <code>collectgarbage</code> с <code>n</code>, равным нулю, до самого истечения этого периода ожидания.</p>
<h3 id="Chapter32.xhtml#sigil_toc_id_234">Упражнения</h3>
<p><strong>Упражнение 32.1.</strong> Напишите библиотеку, которая позволит скрипту ограничить общий объем памяти, используемый состоянием в Lua. Она может предлагать единственную функцию <code>setlimit</code> для задания этого ограничения.</p>
<p>Библиотека должна задавать свою собственную выделяющую функцию. Эта функция перед вызовом исходной выделяющей функции проверяет общий объем используемой памяти и возвращает <code>NULL</code>, если запрашиваемый объем превысит максимальное значение.</p>
<p>(Подсказка: эта библиотека может использовать <code>lua_gc</code> для инициализации своего счетчика памяти при запуске. Она также может использовать пользовательские данные выделяющей функции, чтобы хранить свое состояние: число байт, текущее ограничение объема памяти и т. п. Не забудьте использовать исходные пользовательские данные при вызове исходной выделяющей функции.)</p>
<p><strong>Упражнение 32.2.</strong> Для этого упражнения вам понадобится как минимум один скрипт Lua, использующий очень много памяти. Если у вас такого нет, то напишите его. (Он может быть простым, наподобие цикла, создающего таблицы.)</p>
<ul>
<li>Запустите ваш скрипт с различными параметрами сборщика мусора. Насколько они влияют на быстродействие?</li>
<li>Что случится, если вы установите параметр <code>pause</code> на ноль? Что случится, если вы установите его на 1000?</li>
<li>Что случится, если вы установите параметр <code>stepmul</code> на ноль? Что случится, если вы установите его на 1 000 000?</li>
<li>Поправьте ваш скрипт таким образом, чтобы он получил полный контроль над сборщиком мусора. Он должен держать сборщик мусора остановленным и вызывать его время от времени.</li>
<li>Можете ли вы повысить быстродействие вашего скрипта с данным подходом?</li>
</ul>
<p><span id="Appendix.xhtml"></span></p>
<div style="text-align: center; padding: 0pt; margin: 0pt;">
<h1>Приложения</h1>
<h1 id="Appendix.xhtml#sigil_toc_id_185" class="part">Lua 5.3</h1>
<svg xmlns="http://www.w3.org/2000/svg" height="75%" preserveaspectratio="xMidYMid meet" version="1.1" viewbox="0 0 1400 1300" width="100%" xlink="http://www.w3.org/1999/xlink">

</svg>
</div>
<p><span id="AppendixA.xhtml"></span></p>
<h2>ПРИЛОЖЕНИЕ А</h2>
<h2 id="AppendixA.xhtml#sigil_toc_id_236">Переход на Lua 5.3</h2>
<h3>А.1. Изменения в языке</h3>
<p>Главным отличием между Lua 5.2 и Lua 5.3 является введение подтипа целых чисел — <strong>integer</strong>. Хотя данное изменение не должно повлиять на «обычные» вычисления, некоторые из них (главным образом те, что содержат какое-либо переполнение) могут выдавать другие результаты.</p>
<p>Вы можете убрать влияние этих отличий путем принудительного выставления подтипа чисел с плавающей точкой <strong>float</strong> (в Lua 5.2 все числа были с плавающей точкой), например, записав константы с окончанием <code>.0</code> или воспользовавшись <code>x = x + 0.0</code> для преобразования переменной. (Данная рекомендация служит лишь для быстрого исправления редко встречающейся несовместимости подтипов; она не является нормой в хорошем программировании. Для хорошего программирования используйте <strong>float</strong> там, где вам нужны числа с плавающей точкой, и <strong>integer</strong> там, где вам нужны целые числа.</p>
<p>Преобразование числа с плавающей точкой в строку теперь добавляет суффикс <code>.0</code> к результату, если этот результат выглядит как целое число. (Например, число <code>2.0</code> будет напечатано как <code>2.0</code>, а не как <code>2</code>.) Вы всегда должны явно указывать формат, когда вам нужен конкретный формат для чисел.</p>
<p>(Формально это не является изменением, поскольку Lua не определяет, каким образом числа форматируются как строки, но некоторые программы ожидают конкретный формат.)</p>
<p>Из сборщика мусора был убран накопительный режим <strong>(generational mode)</strong>. (Он был экспериментальной возможностью в Lua 5.2.)</p>
<h3 id="AppendixA.xhtml#sigil_toc_id_237">А.2. Изменения в библиотеках</h3>
<p>Библиотека <code>bit32</code> была исключена. Несложно подобрать совместимую внешнюю библиотеку или, что еще лучше, заменить ее функции соответственными побитовыми операциями. (Имейте в виду, что <code>bit32</code> оперирует 32-битными целыми числами, т.е. частью <strong>float</strong>, в то время как побитовые операции в Lua 5.3 оперируют целыми числами Lua, у которых по умолчанию 64 бит.)</p>
<p>Библиотека <code>table</code> теперь распознает метаметоды для установки и получения элементов.</p>
<p>Итератор <code>ipairs</code> теперь распознает метаметоды, а его метаметод <code>__ipairs</code> был исключен.</p>
<p>Необязательным именам в <code>io.read</code> больше не нужно начинаться с '<code>*</code>'. Для совместимости Lua продолжить принимать (и игнорировать) данный символ.</p>
<p>Следующие функции были исключены из математической библиотеки: <code>atan2</code>, <code>cosh</code>, <code>sinh</code>, <code>tanh</code>, <code>pow</code>, <code>frexp</code> и <code>ldexp</code>. Вы можете заменить <code>math.pow(x,y)</code> на <code>x^y</code>; вы можете заменить <code>math.atan2</code> на <code>math.atan</code>, который теперь принимает один или два параметра; вы можете заменить <code>math.ldexp(x,exp)</code> на <code>x * 2.0^exp</code>. Для остальных операций вы можете либо воспользоваться внешней библиотекой, либо реализовать их в Lua самостоятельно.</p>
<p>Искатель загрузчиков модулей C, используемый <code>require</code>, изменил способ обработки имен с номером версии. Теперь версия должна идти после имени модуля (как это принято в большинстве других инструментов). Для совместимости этот искатель по-прежнему пользуется старым форматом, когда он не может найти открывающую функцию, соответствующую этому новому стилю. (Lua 5.2 уже работал таким образом, но это изменение не было документировано.)</p>
<p>Вызов <code>collectgarbage(&quot;count&quot;)</code> теперь возвращает только один результат. (Вы можете вычислить второй результат из дробной части первого.)</p>
<h3 id="AppendixA.xhtml#sigil_toc_id_238">А.3. Изменения в API</h3>
<p>Продолжающие функции теперь принимают все, что им нужно, в виде параметров, и не нуждаются в <code>lua_getctx</code>, поэтому <code>lua_getctx</code> была убрана. Внесите соответственные изменения в ваш код.</p>
<p>У функции <code>lua_dump</code> появился дополнительный параметр с именем <code>strip</code>. Используйте <code>0</code> как значение данного параметра, чтобы вернуть прежнее поведение.</p>
<p>Функции для инъекции-проекции беззнаковых целых чисел (<code>lua_pushunsigned</code>, <code>lua_tounsigned</code>, <code>lua_tounsignedx</code>, <code>luaL_checkunsigned</code>, <code>luaL_optunsigned</code>) были исключены. Используйте их эквиваленты со знаком посредством приведения типов.</p>
<p>Макросы для проекции нестандартных целочисленных типов (<code>luaL_checkint</code>, <code>luaL_optint</code>, <code>luaL_checklong</code>, <code>luaL_optlong</code>) были исключены. Используйте их эквивалент посредством <code>lua_Integer</code> с приведением типа (или, если есть возможность, используйте в вашем коде <code>lua_Integer</code>).</p>
<p><span id="AppendixB.xhtml"></span></p>
<h2>ПРИЛОЖЕНИЕ Б</h2>
<h2 id="AppendixB.xhtml#sigil_toc_id_236">Новое в Lua 5.3</h2>
<h3>Б.1. Язык</h3>
<p>Новое в языке:</p>
<ul>
<li>целые числа, по умолчанию 64-битные;</li>
<li>официальная поддержка 32-битных чисел;</li>
<li>побитовые операции;</li>
<li>базовая поддержка UTF-8;</li>
<li>целочисленное деление;</li>
<li>пользовательские данные могут содержать любое значение Lua в качестве пользовательского.</li>
</ul>
<h4 id="AppendixB.xhtml#sigil_toc_id_240">Целые числа</h4>
<p>У типа <strong>number</strong> два внутренних представления, или два подтипа, один называется <strong>integer</strong>, а другой <strong>float</strong>. У Lua есть строго обозначенные правила о том, когда применять каждое из этих представлений, но при этом он может автоматически переводить их друг в друга. Таким образом, у программиста есть выбор: или по большей части не обращать внимание на разницу между целыми и вещественными числами, или получить полный контроль над представлением каждого числа. Стандартная реализация Lua использует для подтипов <strong>integer</strong> и <strong>float</strong> 64-битные числа.</p>
<h4 id="AppendixB.xhtml#sigil_toc_id_241">Официальная поддержка 32-битных чисел</h4>
<p>Возможно скомпилировать Lua так, чтобы он по умолчанию использовал 32-битные целые числа и/или 32-битные числа с плавающей точкой (одинарной точности). Опция с одновременным включением 32 бит для целых чисел и чисел с плавающей точкой особенно привлекательна для микрокомпьютеров и встраиваемых систем. Смотрите макрос <code>LUA_32BITS</code> внутри файла <code>luaconf.h</code>.</p>
<h4 id="AppendixB.xhtml#sigil_toc_id_242">Побитовые операции</h4>
<p>Lua поддерживает следующие побитовые операции:</p>
<table>
<tbody>
<tr class="odd">
<td>'<code>&amp;</code>' побитовое И<br />
'<code>|</code>' побитовое ИЛИ<br />
'<code>~</code>' побитовое взаимоисключающее ИЛИ<br />
'<code>&gt;&gt;</code>' сдвиг вправо<br />
'<code>&lt;&lt;</code>' сдвиг влево<br />
'<code>~</code>' унарное побитовое НЕ</td>
</tr>
</tbody>
</table>
<p>Все побитовые операции преобразуют свои операнды в целые числа, оперируют всеми битами этих целых чисел и выдают результат в виде целого числа.</p>
<p>Сдвиги вправо и влево заполняют освободившиеся биты нулями. Отрицательные смещения приводят к сдвигу в обратном направлении; смещения с абсолютными значениями, которые равны или больше числа битов в целом числе, дают ноль (так как при этом задвигаются все биты).</p>
<h4 id="AppendixB.xhtml#sigil_toc_id_243">Базовая поддержка UTF-8</h4>
<p>Библиотека <code>utf8</code> в виде таблицы обеспечивает базовую поддержку кодировки UTF-8. Она не предлагает никакой поддержки Юникода кроме выполнения преобразования. Любая операция, которой нужно значение символа, например его классификация, лежит вне ее компетенции.</p>
<p>Если только не указано иначе, все функции, которые ожидают позицию байта в качестве параметра, считают, что заданная позиция либо является началом байтовой последовательности, либо равна длине обрабатываемой строки, увеличенной на единицу. Как и в строковой библиотеке, отрицательные индексы отсчитываются от конца строки.</p>
<p><br />
</p>
<p><code>utf8.char (···)</code></p>
<p>Получает ноль или более целых чисел, переводит каждое из них в его соответственную последовательность байтов для UTF-8 и возвращает строку, в которой все эти последовательности соединены.</p>
<p><br />
</p>
<p><code>utf8.charpattern</code></p>
<p>Данный образец (т.е. это строка, а не функция) равен &quot;<code>[\0-\x7F\xC2-\xF4][\x80-\xBF]*</code>&quot;, что соответствует ровно одной байтовой последовательности UTF-8 при условии, что субъект является допустимой строкой UTF-8.</p>
<p><br />
</p>
<p><code>utf8.codes (s)</code></p>
<p>Возвращает значения таким образом, что конструкция</p>
<pre><code>for p, c in utf8.codes(s) do body end</code></pre>
<p>переберет все символы в строке <code>s</code>, где <code>p</code> является позицией (в байтах), а <code>c</code> является кодовой точкой каждого символа. Вызывает ошибку, если встречает любую недопустимую последовательность байтов.</p>
<p><br />
</p>
<p><code>utf8.codepoint (s [, i [, j]])</code></p>
<p>Возвращает кодовые точки (как целые числа) из всех символов в <code>s</code>, которые находятся между байтовыми позициями <code>i</code> и <code>j</code> (включительно). По умолчанию <code>i</code> равна <code>1</code>, а <code>j</code> равна <code>i</code>. Вызывает ошибку, если встречает любую недопустимую последовательность байтов.</p>
<p><br />
</p>
<p><code>utf8.len (s [, i [, j]])</code></p>
<p>Возвращает число символов UTF-8 в строке <code>s</code>, которые находятся между байтовыми позициями <code>i</code> и <code>j</code> (включительно). По умолчанию i равна <code>1</code>, а <code>j</code> равна <code>-1</code>. Если находит любую недопустимую последовательность байтов, то возвращает false и позицию первого недопустимого байта.</p>
<p><br />
</p>
<p><code>utf8.offset (s, n [, i])</code></p>
<p>Возвращает позицию (в байтах), с которой начинается кодировка символа строки <code>s</code> под номером <code>n</code> (считая от позиции <code>i</code>). Отрицательный <code>n</code> получает символы до позиции <code>i</code>. По умолчанию <code>i</code> равна <code>1</code>, когда <code>n</code> не является отрицательным, и <code>#s + 1</code> в остальных случаях, поэтому <code>utf8.offset(s, -n)</code> получит смещение <code>n</code>-ного символа от конца строки. Если заданный символ не находится внутри строки или сразу после ее конца, функция возвращает nil.</p>
<p>Как особый случай, когда <code>n</code> равен 0, функцию возвращает начало кодировки символа, который содержит <code>i</code>-ый по счету байт строки <code>s</code>.</p>
<p>Данная функция полагается на то, что <code>s</code> является допустимой строкой UTF-8.</p>
<h4 id="AppendixB.xhtml#sigil_toc_id_244">Целочисленное деление</h4>
<p>Для целочисленного деления введена новая операция — '<code>//</code>', а операция '<code>/</code>' служит для деления вещественного.</p>
<p>Вещественное деление ('<code>/</code>') всегда преобразует свои операнды в <strong>float</strong> и дает в результате <strong>float</strong>.</p>
<p>Целочисленное деление ('<code>//</code>') всегда преобразует свои операнды в <strong>integer</strong> и дает в результате <strong>integer</strong>. Преобразование происходит посредством округления операндов в меньшую сторону, как это делает функция <code>math.floor</code>.</p>
<h3 id="AppendixB.xhtml#sigil_toc_id_245">Б.2. Библиотеки</h3>
<p>Новое в библиотеках:</p>
<ul>
<li>итератор <code>ipairs</code> распознает метаметоды;</li>
<li>библиотека <code>table</code> распознает метаметоды;</li>
<li>опция <code>strip</code> в <code>string.dump</code>;</li>
<li>функция <code>table.move</code>;</li>
<li>функции <code>string.pack</code>, <code>string.unpack</code>, <code>string.packsize</code>.</li>
</ul>
<h4 id="AppendixB.xhtml#sigil_toc_id_246">Опция <code>strip</code> в string.dump</h4>
<p><code>string.dump (function [, strip])</code></p>
<p>Возвращает строку, содержащую бинарное представление (бинарный кусок) заданной функции <code>function</code>, чтобы позже функция <code>load</code>, примененная к этой строке, вернула копию этой функции (но с новыми верхними значениями). Если параметр <code>strip</code> равен true, то бинарное представление может не включать всю отладочную информацию о функции, чтобы сэкономить место.</p>
<h4 id="AppendixB.xhtml#sigil_toc_id_247">Функция <code>table.move</code></h4>
<p><code>table.move (a1, f, e, t [,a2])</code></p>
<p>Перемещает элементы из таблицы <code>a1</code> в таблицу <code>a2</code>. Эта функция делает то же, что и следующее множественное присваивание: <code>a2[t],··· = a1[f],···,a1[e]</code>. По умолчанию <code>a2</code> равна <code>a1</code>. Диапазон конечной таблицы <code>a2</code> может перекрывать диапазон исходной таблицы <code>a1</code>. Количество перемещаемых элементов должно укладываться в целое число Lua.</p>
<h4 id="AppendixB.xhtml#sigil_toc_id_248">Функции <code>string.pack</code>, <code>string.unpack</code>, <code>string.packsize</code></h4>
<p><code>string.pack (fmt, v1, v2, ···)</code></p>
<p>Возвращает бинарную строку, содержащую значения <code>v1</code>, <code>v2</code> и т.д., упакованные (т.е. сериализованные в бинарной форме) в соответствии с форматирующей строкой <code>fmt</code> (см. ниже).</p>
<p><br />
</p>
<p><code>string.unpack (fmt, s [, pos])</code></p>
<p>Возвращает значения, упакованные в строке <code>s</code> (при помощи <code>string.pack</code>) в соответствии с форматирующей строкой <code>fmt</code> (см. ниже). Необязательный параметр <code>pos</code> отмечает место, с которого начинается чтение строки <code>s</code> (по умолчанию равен 1). После чтения значений эта функция также возвращает индекс первого непрочитанного байта в <code>s</code>.</p>
<p><br />
</p>
<p><code>string.packsize (fmt)</code></p>
<p>Возвращает размер строки, которая получается в результате применения <code>string.pack</code> с заданным форматом. Форматирующая строка <code>fmt</code> (см. ниже) не может иметь опции переменной длины '<code>s</code>' или '<code>z</code>'.</p>
<p><br />
</p>
<p>Форматирующая строка <code>fmt</code> является первым аргументом вышеперечисленных функций. Она описывает разбивку создаваемой или читаемой структуры. Форматирующая строка является последовательностью <span style="text-indent: 1.5em;">конверсионных опций. Конверсионные опции следующие:</span></p>
<table>
<tbody>
<tr class="odd">
<td>'<code>&lt;</code>' задает порядок байтов от младшего к старшему <strong>(little endian)</strong><br />
'<code>&gt;</code>' задает порядок байтов от старшего к младшему <strong>(big endian)</strong><br />
'<code>=</code>' задает нативный порядок байтов <strong>(native endian)</strong><br />
'<code>![n]</code>' задает максимальное выравнивание для <code>n</code> (по умолчанию выравнивание нативное)<br />
'<code>b</code>' <strong>signed byte</strong> (один символ, т.е. <strong>char</strong>)<br />
'<code>B</code>' <strong>unsigned byte</strong> (один символ, т.е. <strong>char</strong>)<br />
'<code>h</code>' <strong>signed short</strong> (нативный размер)<br />
'<code>H</code>' <strong>unsigned short</strong> (нативный размер)<br />
'<code>l</code>' <strong>signed long</strong> (нативный размер)<br />
'<code>L</code>' <strong>unsigned long</strong> (нативный размер)<br />
'<code>j</code>' <code>lua_Integer</code><br />
'<code>J</code>' <code>lua_Unsigned</code><br />
'<code>T</code>' <code>size_t</code> (нативный размер)<br />
'<code>i[n]</code>' <strong>signed int</strong> размером <code>n</code> байт (по умолчанию нативный размер)<br />
'<code>I[n]</code>' <strong>unsigned int</strong> размером <code>n</code> байт (по умолчанию нативный размер)<br />
'<code>f</code>' <strong>float</strong> (нативный размер)<br />
'<code>d</code>' <strong>double</strong> (нативный размер)<br />
'<code>n</code>' <code>lua_Number</code><br />
'<code>cn</code>' строка фиксированного размера размером <code>n</code> байт<br />
'<code>z</code>' нуль-завершенная строка<br />
'<code>s[n]</code>' строка, перед которой стоит ее длина, закодированная в виде <strong>unsigned integer</strong>, равная <code>n</code> байт (по умолчанию <code>n</code> равен <code>size_t</code>)<br />
'<code>x</code>' один байт для создания отступа<br />
'<code>Xop</code>' пустой элемент, который варавнивает в соответствии с опцией <code>op</code> (в остальных случаях игнорируется)<br />
' ' (пустое пространство) игноририруется<br />
</td>
</tr>
</tbody>
</table>
<p>(Элемент &quot;<code>[n]</code>&quot; означает необязательный целочисленный нумерал. За исключением отступов, пробелов и кофигураций (опции &quot;<code>xX &lt;=&gt;!</code>&quot;), каждая опция отвечает за свой аргумент (в <code>string.pack</code>) или результат (в <code>string.unpack</code>).</p>
<p>Для опций &quot;<code>!n</code>&quot;, &quot;<code>sn</code>&quot;, &quot;<code>in</code>&quot; и &quot;<code>In</code>&quot;, <code>n</code> может быть любым целым числом между 1 и 16. Все целочисленные опции производят проверку на переполнение; <code>string.pack</code> проверяет, помещается ли заданное значение в заданный размер; <code>string.unpack</code> проверяет, помещается ли прочитанное значение в целое число Lua.</p>
<p>Любая форматирующая строка начинается, как если бы она была предварена &quot;<code>!1=</code>&quot;, то есть с максимальным варавниванием, равным 1 (отсутствие выравнивания) и нативным порядком байтов.</p>
<p>Выравнивание работает следующим образом: Для каждой опции формт вставляет дополнительные отступы, пока данные не станут начинаться со смещения, которое кратно минимуму между размером опции и максимальным выравниванием; этот минимум должен быть степенью 2. Опции &quot;<code>c</code>&quot; и &quot;<code>z</code>&quot; не выравниваются; опция &quot;<code>s</code>&quot; следует выравниванию своего начального целого числа.</p>
<p>Все отступы заполняются нулями функцией <code>string.pack</code> (и игнорируются <code>string.unpack</code>).</p>
<h3 id="AppendixB.xhtml#sigil_toc_id_249">Б.3. C API</h3>
<p>Новое в C API:</p>
<ul>
<li>более простой API для продолжающих функций в C;</li>
<li>функция <code>lua_gettable</code> и подобные ей возвращают тип итогового значения;</li>
<li>опция <code>strip</code> в <code>lua_dump</code>;</li>
<li>функции <code>lua_geti</code>, <code>lua_seti</code>, <code>lua_isyieldable</code>, <code>lua_numbertointeger</code>, <code>lua_rotate</code>, <code>lua_stringtonumber</code>.</li>
</ul>
<h4 id="AppendixB.xhtml#sigil_toc_id_250">Опция <code>strip</code> в lua.dump</h4>
<p><code>int lua_dump (lua_State *L, lua_Writer writer, void *data, int strip);</code></p>
<p>Сбрасывает на диск функцию в виде бинарного куска. Получает функцию Lua с вершины стека и производит бинарный кусок, который, если загружен повторно, дает функцию, эквивалентную ранее сброшенной. По мере производства частей куска, <code>lua_dump</code> вызывает записывателя функций (см. в справочнике <code>lua_Writer</code>) с указанными данными для записи этих частей.</p>
<p>Если <code>strip</code> равен true, бинарное представление может не включать в себя какую-либо отладочную информацию о функции, чтобы сэкономить место.</p>
<p>Возвращаемое значение — это код ошибки, возвращенной последним вызовом записывателя; 0 означает отсутствие ошибок.</p>
<p>Данная функция не выталкивает функцию Lua из стека.</p>
<h4 id="AppendixB.xhtml#sigil_toc_id_251">Функции</h4>
<p><code>int lua_geti (lua_State *L, int index, lua_Integer i);</code></p>
<p>Заталкивает в стек значение <code>t[i]</code>, где <code>t</code> — это значение в заданном индексе. Как и в Lua, данная функция может привести к срабатыванию метаметода для события &quot;<code>index</code>&quot;.</p>
<p>Возвращает тип вставленного в стек значения.</p>
<p><br />
</p>
<p><code>void lua_seti (lua_State *L, int index, lua_Integer n);</code></p>
<p>Выполняет действия, эквивалентные <code>t[n] = v</code>, где <code>t</code> — это значения в заданном индексе, а <code>v</code> — это значение на вершине стека.</p>
<p>Данная функция вытакливает значение из стека. Как и в Lua, данная функция может привести к срабатыванию метаметода для события &quot;<code>newindex</code>&quot;.</p>
<p><code></code></p>
<p><code>int lua_isyieldable (lua_State *L);</code></p>
<p>Возвращает 1, если заданная сопрограмма может уступить управление, или 0 в ином случае.</p>
<p><code></code></p>
<p><code>int lua_numbertointeger (lua_Number n, lua_Integer *p);</code></p>
<p>Преобразует число Lua из <strong>float</strong> в <strong>integer</strong>. Данный макрос ожидает, что <code>n</code> обладает целочисленным значением. Если его значение лежит внутри диапазона целых чисел Lua, то оно преобразуется в целое число и присваивается <code>*p</code>. Этот макрос возвращает булево значение, указывающее на то, было ли успешно преобразование. (Обратите внимание, что без этого макроса в связи с округлениями данная проверка диапазона может не всегда давать ожидаемый результат.)</p>
<p>Данный макрос может вычислять свои аргументы более одного раза.</p>
<p><code></code></p>
<p><code>void lua_rotate (lua_State *L, int idx, int n);</code></p>
<p>Циклически сдвигает элементы стека между допустимым индексом <code>idx</code> и вершиной стека. Элементы сдвигаются на <code>n</code> позиций в направлении вершины в случае положительного <code>n</code>, или на <code>-n</code> позиции в направлении основания в случае отрицательного <code>n</code>. Абсолютное значение <code>n</code> не должно быть больше размера сдвигаемой секции. Данная функция не может быть вызвана для псевдоиндекса, поскольку псевдоиндекс не является действительной позицией в стеке.</p>
<p><code></code></p>
<p><code>size_t lua_stringtonumber (lua_State *L, const char *s);</code></p>
<p>Преобразует нуль-завершенную строку <code>s</code> в число, заталкивает это число в стек и возвращает итоговый размер этой строки, т.е. ее длину, увеличенную на 1. Данное преобразование может выдать либо целое число, либо <strong>integer</strong>, либо <strong>float</strong>, в зависимости от лексических соглашений Lua. Эта строка может содержать знак, а также пробелы в начале и в конце. Если она не является допустимым нумералом, будет возвращен 0 и заталкивания не произойдет. (Обратите внимание, что результат может быть использован как булево значение, например, true, если преобразование пройдет успешно.)</p>
<h3 id="AppendixB.xhtml#sigil_toc_id_252">Б.4. Автономный интерпретатор Lua</h3>
<p>Новое в автономном интерпретаторе:</p>
<ul>
<li>Может быть использован как калькулятор без необходимости предварять выражение знаком '<code>=</code>';</li>
<li>Таблица <code>arg</code> доступна всему коду.</li>
</ul>
</body>
</html>
